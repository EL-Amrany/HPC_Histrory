Get an Account

In order to use the ULHPC facilities, you need to have a user account with an associated user login name (also called username) placed under an account hierarchy.

Conditions of acceptance

Acceptable Use Policy (AUP)

There are a number of policies which apply to ULHPC users.

 UL HPC Acceptable Use Policy (AUP) [pdf]

Important
All users of UL HPC resources and PIs must abide by the UL HPC Acceptable Use Policy (AUP). You should read and keep a signed copy of this document before using the facility.

Access and/or usage of any ULHPC system assumes the tacit acknowledgement to this policy.

Remember that you are expected to acknowledge ULHPC in your publications. See Acceptable Use Policy for more details.

ULHPC Platforms are meant ONLY for R&D!
Resource allocation policies

 ULHPC Usage Charging and Resource allocation policy

UL internal R&D and training

ULHPC resources are free of charge for UL staff for their internal work and training activities. Principal Investigators (PI) will nevertheless receive on a regular basis a usage report of their team activities on the UL HPC platform. The corresponding accumulated price will be provided even if this amount is purely indicative and won't be charged back.

Any other activities will be reviewed with the rectorate and are a priori subjected to be billed.

Research Projects

Externals and private partners

How to Get a New User account?

 Account Request Form

University staff - you can submit a request for a new ULHPC account by using the ServiceNow portal (Research > HPC > User access & accounts > New HPC account request).
Students - submit your account request on the Student Service Portal.
Externals - a University staff member must request the account for you, using the section New HPC account for external. Enter the professional data (organization and institutional email address). Specify the line manager / project PI if needed.
If you need to access a specific project directory, ask the project directory owner to open a ticket using the section Add user within project.
Your account will undergo user checks, in accordance with ULHPC policies, to verify your identity and the information proposed. Under some circumstances, there could be a delay while this vetting takes place.
After vetting has completed, you will receive a welcome email with your login information, and a unique link to a PrivateBin 1 holding a random temporary password. That link will expire if not used within 24 hours. The PI and PI Proxies for the project will be notified when applicable.
Finally, you will need to log into the HPC IPA Portal to set up your initial password and Multi-Factor Authentication (MFA) for your account.
Your new password must adhere to ULHPC's password requirements
see Password policy and guidelines
ULHPC Identity Management (IPA portal) documentation
UL HPC  University credentials
Managing User Accounts

ULHPC user accounts are managed in through the HPC IPA web portal.

Security Incidents

If you think there has been a computer security incident, you should contact the ULHPC Team and the University CISO team as soon as possible:

To: hpc-team@uni.lu,laurent.weber@uni.lu

Subject: Security Incident for HPC account '<login>' (ADAPT accordingly)

Please save any evidence of the break-in and include as many details as possible in your communication with us.

How to Get a New Project account?

Projects are defined for accounting purposes and are associated to a set of user accounts allowed by the project PI to access its data and submit jobs on behalf of the project account. See Slurm Account Hierarchy.

You can request (or be automatically added) to project accounts for accounting purposes. For more information, please see the Project Account documentation

FAQ

Can I share an account? – Account Security Policies

Danger
The sharing of passwords or login credentials is not allowed under UL HPC and University information security policies. Please bear in mind that this policy also protects the end-user.

Sharing credentials removes the ability to audit and accountability for the account holder in case of account misuse. Accounts which are in violation of this policy may be disabled or otherwise limited. Accounts knowingly skirting this policy may be banned.

If you find that you need to share resources among multiple individuals, shared projects are just the way to go, and remember that the University extends access to its HPC resources (i.e., facility and expert HPC consultants) to the scientific staff of national public organizations and external partners for the duration of joint research projects under the conditions defined above.

When in doubt, please contact us and we will be happy to assist you with finding a safe and secure way to do so.

PrivateBin is a minimalist, open source online pastebin where the server has zero knowledge of pasted data. Data is encrypted / decrypted in the browser using 256bit AES in Galois Counter mode. ↩
Last update: March 13, 2025

Password Policy

Password and Account Protection

A user is given a username (also known as a login name) and associated password that permits her/him to access ULHPC resources. This username/password pair may be used by a single individual only: passwords must not be shared with any other person. Users who share their passwords will have their access to ULHPC disabled.

Do not confuse your UL[HPC] password/passphrase and your SSH passphrase
We sometimes receive requests to reset your SSH passphrase, which is something you control upon SSH key generation - see SSH documentation.

Passwords must be changed as soon as possible after exposure or suspected compromise. Exposure of passwords and suspected compromises must immediately be reported to ULHPC and the University CISO (see below). In all cases, recommendations for the creation of strong passwords is proposed below.

Password Manager

You are strongly encouraged also to rely on password manager applications to store your different passwords. You may want to use your browser embedded solution but it's not the safest option. Here is a list of recommended applications:

BitWarden - free with no limits ($10 per year for families) - Github
Dashlane - free for up to 50 passwords - 40€ per year for premium (60€ for families)
LastPass
NordPass - free version limited to one device with unlimited number of passwords; 36$ per year for premium plan
1Password - paid version only (yet worth it) with 30-day free trial, 36$ per year (60$ for families)
Self-Hosted solutions:
KeepassXC
pass: the Standard Unix Password Manager.
Forgotten Passwords

If you forget your password or if it has recently expired, you can simply contact us to initiate the process of resetting your password.

Login Failures

Your login privileges will be disabled if you have several login failures while entering your password on a ULHPC resource. You do not need a new password in this situation. The login failures will be automatically cleared after a couple of minutes. No additional actions are necessary.

How To Change Your Password on IPA

See IPA documentation

Tip
Passwords must be changed under any one of the following circumstances:

Immediately after someone else has obtained your password (do NOT give your password to anyone else).
As soon as possible, but at least within one business day after a password has been compromised or after you suspect that a password has been compromised.
On direction from ULHPC staff, or by IPA password policy requesting to frequently change your password.
Your new password must adhere to ULHPC's password requirements.

Password Requirements and Guidelines

One of the potentially weakest links in computer security is the individual password. Despite the University's and ULHPC's efforts to keep hackers out of your personal files and away from University resources (e.g., email, web files, licensed software), easily-guessed passwords are still a big problem so you should really pay attention to the following guidelines and recommendations.

Recently, the National Institute of Standards and Technology (NIST) has updated their Digital Identity Guidelines in Special Publication 800-63B. We have updated our password policy to bring it in closer alignment with this guidelines. In particular, the updated guidance is counter to the long-held philosophy that passwords must be long and complex. In contrast, the new guidelines recommend that passwords should be "easy to remember" but "hard to guess", allowing for usability and security to go hand-in-hand. Inpired with other password policies and guidelines (Stanford, NERSC), ULHPC thus recommends the usage of "pass phrases" instead of passwords. Pass phrases are longer, but easier to remember than complex passwords, and if well-chosen can provide better protection against hackers. In addition, the following rules based on password length and usage of Multi-Factor Authentication (MFA) must be satisfied:

The enforced minimum length for accounts with MFA enabled is 8 characters. If MFA is not enabled for your account the minimum password length is 14 characters.
The ability to use all special characters according to the following guidelines (see also the Stanford Password Requirements Quick Guide) depending on the password length:
8-11: mixed case letters, numbers, & symbols
12-15: mixed case letters & numbers
16-19: mixed case letters
20+: no restrictions
illustrating image
Restrict sequential and repetitive characters (e.g. 12345 or aaaaaa)
Restrict context specific passwords (e.g. the name of the site, etc.)
Restrict commonly used passwords (e.g. p@ssw0rd, etc.) and dictionary words
Restrict passwords obtained from previous breach corpuses
Passwords must be changed every six months.
If you are struggling to come up with a good password, you can inspire from the following approach:

Collaboration Accounts

All ULHPC login accounts are associated with specific individuals and must not be shared. In some HPC centers, you may be able to request Collaboration Accounts designed to handle the following use cases:

Collaborative Data Management: Large scale experimental and simulation data are typically read or written by multiple collaborators and are kept on disk for long periods.
Collaborative Software Management
Collaborative Job Management
Info
By default, we DO NOT provide Collaboration Accounts and encourage the usage of shared research projects <name> stored on the Global project directory to enable the group members to manipulate project data with the appropriate use of unix groups and file permissions.

For dedicated job billing and accounting purposes, you should also request the creation of a project account (this will be done for all accepted funded projects).

For more details, see Project Accounts documentation.

We are aware nevertheless that a problem that often arises is that the files are owned by the collaborator who did the work and if that collaborator changes roles the default unix file permissions usually are such that the files cannot be managed (deleted) by other members of the collaboration and system administrators must be contacted. Similarly, for some use cases, Collaboration Accounts would enable members of the team to manipulate jobs submitted by other team members as necessary. Justified and argued use cases can be submitted to the HPC team to find the appropriate solution by opening a ticket on the HPC Helpdesk Portal.



Projects Accounts

Shared project in the Global project directory.

We can setup for you a dedicated project directory on the GPFS/SpectrumScale Filesystem for sharing research data with other colleagues.

Whether to create a new project directory or to add/remove members to the group set to access the project data, use the Service Now HPC Support Portal.

 Service Now HPC Support Portal

Data Storage Charging

Slurm Project Account

As explained in the Slurm Account Hierarchy, projects account can be created at the L3 level of the association tree.

To quickly list a given project accounts and the users attached to it, you can use the sassoc helper function:


# /!\ ADAPT project acronym/name <name>accordingly
sassoc project_<name>
Alternatively, you can rely on sacctmgr, typically coupled with the withassoc attribute:


# /!\ ADAPT project acronym/name <name>accordingly
sacctmgr show account where name=project_<name> format="account%20,user%20,Share,QOS%50" withassoc
As per HPC Resource Allocations for Research Project, creation of such project accounts is mandatory for funded research projects, since usage charging may occur when a detailed reporting will be provided for auditing purposes.

With the help of the University Research Support department, we will create automatically project accounts from the list of accepted project which acknowledge the need of computing resources. Feel free nevertheless to use the Service Now HPC Support Portal to request the creation of a new project account or to add/remove members to the group - this might be pertinent for internal research projects or specific collaboration with external partners requiring a separate usage monitoring.

Important
Project account is a natural way to access the higher priority QOS not granted by default to your personal account on the ULHPC. For instance, the high QOS is automatically granted as soon as a contribution to the HPC budget line is performed by the project.

ULHPC Identity Management Portal (IdM/IPA)

 ULHPC Identity Management Portal

Red Hat Identity Management (IdM), formally referred to as IPA ("Identity, Policy, and Audit" -- see also https://www.freeipa.org), provides a centralized and unified way to manage identity stores, authentication, policies, and authorization policies in a Linux-based domain. IdM significantly reduces the administrative overhead of managing different services individually and using different tools on different machines.

All services (HPC and complementary ones) managed by the ULHPC team rely on a highly redundant setup involving several Redhat IdM/IPA server.

SSH Key Management
You are responsible for uploading and managing your authorized public SSH keys for your account, under the terms of the Acceptable Use Policy. Be aware that the ULHPC team review on a periodical basis the compliance to the policy, as well as the security of your keys. See also the note on deprecated/weak DSA/RSA keys

References

Redhat 7 Documentation
Upload your SSH key on the ULHPC Identity Management Portal

You should upload your public SSH key(s) *.pub to your user entry on the ULHPC Identity Management Portal. For that, connect to the ULHPC IdM portal (use the URL communicated to you by the UL HPC team in your "welcome" mail) and enter your ULHPC credentials.



First copy the content of the key you want to add


# Example with ED25519 **public** key
(laptop)$> cat ~/.ssh/id_ed25519.pub
ssh-ed25519 AAAA[...]
# OR the RSA **public** key
(laptop)$> cat ~/.ssh/id_rsa.pub
ssh-rsa AAAA[...]
Then on the portal:

Select Identity / Users.
Select your login entry
Under the Settings tab in the Account Settings area, click SSH public keys: Add.


Paste in the Base 64-encoded public key string, and click Set.



Click Save at the top of the page. Your key fingerprint should be listed now.

IPA user portal

Listing SSH keys attached to your account through SSSD
SSSD is a system daemon used on ULHPC computational resources. Its primary function is to provide access to local or remote identity and authentication resources through a common framework that can provide caching and offline support to the system. To easily access the authorized keys configured for your account from the command-line (i.e. without login on the ULHPC IPA portal), you can use:


sss_ssh_authorizedkeys $(whoami)
Change Your Password

connect to the ULHPC IdM portal (use the URL communicated to you by the UL HPC team in your "welcome" mail) and enter your ULHPC credentials.
On the top right under your name, select the entry "Change Password"
In the dialog window that appears, enter the current password, and your new password. Your password should meet the password requirements explained in the next section below, and must be 'safe' or 'very safe' according to the provided password strength meter.

ULHPC Open On Demand (OOD) Portal


Open OnDemand (OOD) is a Web portal compatible with Windows, Linux and MacOS. You should login with your ULHPC credential using the URL communicated to you by the UL HPC team.

OOD provides a convenient web access to the HPC resources and integrates

a file management system
a job management system (job composer, monitoring your submitted jobs, ...)
an interactive command-line shell access
interactive apps with graphical desktop environments
ULHPC OOD Portal limitations
The ULHPC OOD portal is NOT accessible outside the UniLu network. If you want to use it, you will need to setup a VPN to access the UniLu network Note: The portal is in _still under active development state: missing features and bugs can be reported to the ULHPC team via the support portal

Live tests and demo are proposed during the ULHPC Tutorial: Preliminaries / OOD.

Below are illustrations of OOD capabilities on the ULHPC facility.

File management



Job composer and Job List





Shell access



Interactive sessions

 

Graphical Desktop Environment

Troubleshooting

There are several possibilities and usually the error message can give you some hints.

Your account has expired

Please open a ticket on ServiceNow (HPC → User access & accounts → Report issue with cluster access) or send us an email to hpc-team@uni.lu with the current end date of your contract and we will extend your account accordingly.

"Access Denied" or "Permission denied (publickey)"

Basically, you are NOT able to connect to the access servers until your SSH public key is configured. There can be several reason that explain the denied connection message:

Make sure you are using the proper ULHPC user name (and not your local username or University/Eduroam login).
Check your mail entitled "[HPC@Uni.lu] Welcome - Account information" to get your ULHPC login
Log into IPA and double check your SSH public key settings.
Ensure you have run your SSH agent
If you have a new computer or for some other reason you have generated new ssh key, please update your ssh keys on the IPA user portal.
See IPA for more details
You are using (deprecated) DSA/RSA keys. As per the OpenSSH website:
"OpenSSH 7.0 and greater similarly disable the ssh-dss (DSA) public key algorithm. It too is weak and we recommend against its use". Solution: generate a new RSA keypair (3092 bit or more) and re-upload it on the IPA web portal (use the URL communicated to you by the UL HPC team in your “welcome” mail). For more information on keys, see this website.


Your public key is corrupted, please verify and re-upload it on the IPA web portal.
We have taken the cluster down for maintenance and we forgot to activate the banner message mentioning this. Please check the calendar, the latest Twitter messages (box on the right of this page) and the messages sent on the hpc-users mailing list.
If the above steps did not permit to solve your issue, please open a ticket on ServiceNow (HPC → User access & accounts → Report issue with cluster access) or send us an email to hpc-team@uni.lu.

Host identification changed


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
...
Ensure that your ~/.ssh/known_hosts file contains the correct entries for the ULHPC clusters and confirm the fingerprints using the posted fingerprints

Open ~/.ssh/known_hosts
Remove any lines referring Iris and Aion and save the file
Paste the specified host key entries (for all clusters) OR retry connecting to the host and accept the new host key after verify that you have the correct "fingerprint" from the reference list.
Be careful with permission changes to your $HOME

If you change your home directory to be writeable by the group, ssh will not let you connect anymore. It requires drwxr-xr-x or 755 (or less) on your $HOME and ~/.ssh, and -rw-r--r-- or 644 (or less) on ~/.ssh/authorized_keys.

File and folder permissions can be verified at any time using stat $path, e.g.:


$> stat $HOME
$> stat $HOME/.ssh
$> stat $HOME/.ssh/authorized_keys
Check out the description of the notation of file permissions in both symbolic and numeric mode.

On your local machine, you also need to to have read/write permissions to ~/.ssh/config for your user only. This can be ensured with the following command:


chmod 600 ~/.ssh/config
Open a ticket

If you cannot solve your problem, do not hesitate to open a ticket on the Service Now portal.

ULHPC User Environment

Your typical journey on the ULHPC facility is illustrated in the below figure.



Typical workflow on UL HPC resources
For more information:

Getting Started
Connecting to ULHPC supercomputers
ULHPC Storage Systems Overview
'-bash: module: command not found' on access/login servers
Recall that by default, the module command is (on purpose) NOT available on the access/login servers. You HAVE to be on a computing node (within a slurm job)

Home and Directories Layout

All UL HPC systems use global home directories. You also have access with environment variables to several other pre-defined directories setup over several different File Systems which co-exist on the UL HPC facility and are configured for different purposes. They are listed below:

Cluster file systems
Directory	Environment variable	File system	Backup	Interconnect
/home/users/<username>	${HOME}	GPFS/Spectrumscale[1]	no	Infiniband
/work/projects/<project name>	${PROJECTHOME}/<project name>	GPFS/Spectrumscale[1]	yes (partial, only backup subdirectory)	Infiniband
/scratch/users/<username>	${SCRATCH}	Lustre	no	Infiniband
/mnt/isilon/projects/<project name>	-	OneFS	yes (and live sync[2])	Ehternet
The file system mounted on the home directories (/home/users) and project directories (/work/projects) are both exported by the GPFS/Spectrumscale file system.
Storage for both directories is redundant, so they are safe against hardware failure.
Only /home/users is mirrored in a SSD cache, so /home/users is a significantly faster for random and small file I/O.
Live sync replicates data across multiple OneFS instances for high availability.
Shell and Dotfiles

The default login shell is bash -- see /etc/shells for supported shells.

ULHPC dotfiles vs. default dotfiles
The ULHPC team DOES NOT populate shell initialization files (also known as dotfiles) on users' home directories - the default system ones are used in your home -- you can check them in /etc/skel/.* on the access/login servers. However, you may want to install the ULHPC/dotfiles available as a Github repository. See installation notes. A working copy of that repository exists in /etc/dotfiles.d on the access/login servers. You can thus use it:


$ /etc/dotfiles.d/install.sh -h
# Example to install ULHPC GNU screen configuration file
$ /etc/dotfiles.d/install.sh -d /etc/dotfiles.d/ --screen -n   # Dry-run
$ /etc/dotfiles.d/install.sh -d /etc/dotfiles.d/ --screen      # real install
Changing Default Login Shell (or NOT)
System Profile

/etc/profile contains Linux system wide environment and startup programs. Specific scripts are set to improve your ULHPC experience, in particular those set in the ULHPC/tools repository, for instance:

/etc/profile.d/slurm-prompt.sh: provide info of your running Slurm job on your prompt
/etc/profile.d/slurm.sh: several helper function to
Customizing Shell Environment

You can create dotfiles (e.g., .bashrc, .bash_profile, or .profile, etc) in your $HOME directory to put your personal shell modifications.

Custom Bash Initialisation Files
Understanding Bash Startup Files order
Since all ULHPC systems share the Global HOME filesystem, the same $HOME is available regardless of the platform. To make system specific customizations use the pre-defined environment ULHPC_CLUSTER variable:

Example of cluster specific settings

case $ULHPC_CLUSTER in
    "iris")
        : # Settings for iris
        export MYVARIABLE="value-for-iris"
        ;;
    "aion")
        : # settings for aion
        export MYVARIABLE="value-for-aion"
        ;;
    *)
        : # default value for
        export MYVARIABLE="default-value"
        ;;
esac
Rocky Linux
Operating Systems 

RedHat
The ULHPC facility runs RedHat-based Linux Distributions, in particular:

the Iris cluster and the Aion cluster run RedHat (RHEL) Linux operating system, version 8 on the access and compute nodes. Servers (not accessible to users) run Rocky Linux 8, which is RHEL compatible, when appropriate. 
Experimental Grid5000 clusters run Debian Linux, version 11
Thus, you are more than encouraged to become familiar - if not yet - with Linux commands. We can recommend the following sites and resources:

Software Carpentry: The Unix Shell
Unix/Linux Command Reference
Discovering, visualizing and reserving UL HPC resources

See ULHPC Tutorial / Getting Started

ULHPC User Software Environment


The UL HPC facilities provides a large variety of scientific applications to its user community, including domain-specific codes and general purpose development tools for a wide range of applications.1 An environment module system, LMod, is used to manage the shell environment and provide access to installed software.

The main advantages of using an environment module system are the following:

Many different versions and/or installations of a single software package can be provided on a given machine, including a default version as well as several older and newer version.
Users can easily switch to different versions or installations of a software package without having to explicitly modify their shell environment.
Most UL HPC modules are automatically generated by Easybuild.

EasyBuild is a software build and installation framework that allows you to manage scientific and other software on High Performance Computing systems in an efficient way. A large number of scientific software are supported (at least 3670 supported software packages since the 4.9.4 release).2

For several years now, Easybuild is used to manage the ULHPC User Software Set and generate automatically the module files available to you on our computational resources in either release (default) or testing (pre-release/testing) environment. This enables users to easily extend the global software set with their own local software builds, either stored within their global home directory, or preferably in a shared project directory. Easybuild generates automatically module files compliant with the ULHPC module setup.

 ULHPC Environment modules  Using Easybuild on ULHPC Clusters

Self management of work environments in UL HPC with Conda

Packages provided through the standard channels of modules and containers are optimized for the ULHPC clusters to ensure their performance and stability. However, many packages where performance is not critical and are used by few users are not provided through the standard channels. These packages can still be installed locally by the users through an environment management system such as Conda.

Contact the ULHPC before installing any software with Conda
Prefer binaries provided through modules or containers. Conda installs generic binaries that may be suboptimal for the configuration of the ULHPC clusters. Furthermore, installing packages locally with Conda consumes quotas in your or your project's account in terms of storage space and number of files.

Contact the ULHPC High Level Support Team in the service portal [Home > Research > HPC > Software environment > Request expertise] to discuss possible options before installing any software.

Conda is an open source environment and package management system. With Conda you can create independent environments, where you can install applications such as python and R, together with any packages which will be used by these applications. The environments are independent, with the Conda package manager managing the binaries, resolving dependencies, and ensuring that package used in multiple environments are stored only once. In a typical setting, each user has their own installation of a Conda and a set of personal environments.

ULHPC Software/Modules Environment


The UL HPC facilities provides a large variety of scientific applications to its user community, including domain-specific codes and general purpose development tools for a wide range of applications.1 An environment module system, LMod, is used to manage the shell environment and provide access to installed software.

The main advantages of using an environment module system are the following:

Many different versions and/or installations of a single software package can be provided on a given machine, including a default version as well as several older and newer version.
Users can easily switch to different versions or installations of a software package without having to explicitly modify their shell environment.
Most UL HPC modules are automatically generated by Easybuild.
Environment modules

Environment module systems are a standard set of tools deployed in most HPC sites to allow dynamic modification of user environments. The environment module framework was fist implement in Environment Modules in Tcl and later in other tools such as Lmod that is written in Lua. All implementations provide the module command to

manage the PATH, LD_LIBRARY_PATH, MANPATH, and other shell environment variables,
define shell functions, and
call other environment modifying tools, like Conda and Python virtual environments.
By automatically modifying the shell environment, the modules can load and unload an application, and any profile files and libraries on which it depends. This enables the

automatic management of complex liking dependencies in libraries used in scientific software, and
the provision of multiple version of software packages that can co-exists independently in different module environments.
The module command is only available on the compute nodes
There is no environment module system installed in login nodes. This is a deliberate choice to prevent users from running large jobs on login nodes. You need to be within a job (interactive or not) to load modules provided by UL HPC or private modules.

Inner working of environment modules systems
Tcl/C Environment Modules vs. Tcl Environment Modules vs. Lmod
Working with environment modules

In the UL HPC systems Lmod is used to provide an environment management system. The associated Modulefiles are almost exclusively generated automatically by Easybuild. The module command supports the following subcommands:

Command	Description
module avail	Lists all the modules which are available to be loaded
module spider <pattern>	Search for <pattern> among available modules (Lmod only)
module load <mod1> [mod2...]	Load a module
module unload <module>	Unload a module
module list	List loaded modules
module purge	Unload all modules (purge)
module display <module>	Display what a module does
module use <path>	Prepend the directory to the MODULEPATH environment variable
module unuse <path>	Remove the directory from the MODULEPATH environment variable
At the heart of environment modules interaction resides the following components:

the MODULEPATH environment variable, which defines a colon-separated list of directories to search for module files, and
a modulefile (see an example) associated with each available software package.
Example of ULHPC toolchain/foss (auto-generated) module file
Modules for software sets in UL HPC

In UL HPC we are using environment modules to modify the available module set. This is done to prevent accidental mixing of modules from different software sets. To load a set of software modules, simply load the appropriate module the modifies the available software set. There are two types of software sets.

Modules under env: this is a set of modules sticky optimized for the UL HPC systems. The modules are designed to load a different natively optimized set of modules for each system in UL HPC.
Modules under EESSI: this modules load EESSI software sets. The software sets distributed under EESSI are generically optimized software sets for a number of architectures that are designed to support reproducibility and are available across multiple HPC centers.
When to use EESSI
While the performance of EESSI modules is slightly lower that the natively optimized software set (env), it is easier to move your computations to new systems that support EESSI. If you plan to also run your computations in a centre where EESSI is available, you should consider using EESSI. Otherwise use the local modules.

When you login to a compute node, the default software set is loaded automatically. You can change that by loading another software set.

Loading a natively optimized software set under env

Each software set under env corresponds to a different software set release on UL HPC. The local software sets under env are mutually exclusive, you cannot have 2 of them loaded at the same time. This is done to prevent accidental mixing of modules from different software sets. To load for instance env/development/2023b, use the command:


$ module load env/development/2023b

Lmod is automatically replacing "env/release/default" with "env/development/2023b".
The command informs us that the default software set was replaces with the 2023b software set from the development category. The modules setting the environment are sticky modules, meaning that you can only unload/purge them with the --force flag:

$ module unload env/development/2023b
The following modules were not unloaded:
  (Use "module --force purge" to unload all):

  1) env/development/2023b
$ module --force unload env/development/2023b
This saves you from loading environment setting module every time you purge your environment modules during normal operations.
Loading an EESSI software set

The EESSI software set is distributed in a flat manner, meaning that all modules from all releases are available in the same software set. While there is no danger when using a software set like that, the sheer number of available alternatives can lead to mistakes if someone is not careful. Furthermore, the EESSI modules that load the EESSI software set are not sticky, so when you purge your modules you have to reload your EESSI software environment module. For instance, consider loading EESSI/2023.06:


$ module load EESSI/2023.06
Then, listing the available modules


$ module avail
---- /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all ----
...
   Abseil/20240116.1-GCCcore-13.2.0         (D)
   Archive-Zip/1.68-GCCcore-12.2.0
   Armadillo/11.4.3-foss-2022b
   Armadillo/12.6.2-foss-2023a
   Armadillo/12.8.0-foss-2023b              (D)
   Arrow/11.0.0-gfbf-2022b
...
there are multiple versions of the same software available from multiple toolchains (foss-2023a, foss-2023b). Loading a module and purging the loaded modules also removes the EESSI/2023.06 module.


$ module load foss/2023b
$ module list EESSI

Currently Loaded Modules Matching: EESSI
  1) EESSI/2023.06

$ module purge
The following modules were not unloaded:
  (Use "module --force purge" to unload all):

  1) env/development/2023b

$ module list EESSI

Currently Loaded Modules Matching: EESSI
  None found.
UL HPC toolchains and software set versioning

Our centre offers a yearly release of the UL HPC software set based on corresponding release of EasyBuid toolchains.2 Count at least 6 months of validation and testing after an EasyBuild release before a UL HPC release.

Tool chains and software releases
The idea behind toolchains is that a core set of modules is fixed per release and the rest of the software in the release is built around the core set. Only one version of the toolchain modules is present in the software set, where as multiple versions of other software can be present.

For an exhaustive list of components version fixed per release have a look as the foss and intel toolchains.

An overview of the currently available core toolchain component versions in the UL HPC releases is depicted below:

Name	Type	2019b (legacy)	2020b (release)	2023b (development)	(testing)
GCCCore	compiler	8.3.0	10.2.0	13.2.0	
foss	toolchain	2019b	2020b	2023b	
intel	toolchain	2019b	2020b	2023b	
binutils		2.32	2.35	2.40	
Python		3.7.4 (and 2.7.16)	3.8.6	3.11.5	
Clang	compiler	9.0.1	11.0.0	17.0.6	
OpenMPI	MPI	3.1.4	4.0.5	4.1.6	
When using the natively optimized software sets loaded with the module under env, you should always have a single core component available. With the flat layout used in EESSI there will be multiple core components available with you load modules providing the EESSI software sets.

Architecture of the software set

By default, the environment module system uses the contents of the ${MODULEPATH} environment variable as the path where is will look for modules. In UL HPC the environment variable contains by default the following paths.

/opt/apps/easybuild/environment/modules: Location of sticky modules under env that provide the native optimized software modules.
/cvmfs/software.eessi.io/init/modules: Location of modules under EESSI, a module that provide the EESSI software sets.
There is also a default version of a natively optimized env module loaded. The natively optimized module under env append the following path to ${MODULEPATH} in the order described below.

On all nodes except for the gpu partition of Iris:
/opt/apps/easybuild/systems/<cluster name>/<build version>/<software set version>/<target architecture>/modules/all: Location of natively optimized modules.
/opt/apps/easybuild/systems/binary/<build version>/<software set version>/generic/modules/all: Location of software distributed as binaries that cannot be optimized for any target architecture.
On nodes of the gpu partition of Iris:
/opt/apps/easybuild/systems/iris/<build version>/<software set version>/gpu/modules/all: Location of natively optimized modules that use the GPU.
/opt/apps/easybuild/systems/iris/<build version>/<software set version>/skylake/modules/all: Location of natively optimized modules.
/opt/apps/easybuild/systems/binary/<build version>/<software set version>/generic/modules/all: Location of software distributed as binaries that cannot be optimized for any target architecture.
Note that the GPU optimized modules still need the CPU modules to function, like for instance MPI modules, and GPU nodes use Skylake CPUs.
Parameters in the software set directory paths
Organization of software set files and manual selection of the software set

There are nodes with broadwell and nodes with skylake CPUs in the CPU partitions (batch and interactive) of Iris. To ensure that a compatible binary is used in all CPUs of the partition, modules loading software sets are configured to load binaries that are compatible for broadwell, the older architecture of the two (note that the binary is selected in the primary node of an allocation).

The RESIF_ARCH environment variable is used to load the software set for the appropriate architecture in the natively optimized software sets under env. The ${RESIF_ARCH} value used for all nodes in the CPU partitions of Iris is broadwell.

Similarly to RESIF_ARCH, EESSI provides the EESSI_ARCHDETECT_OPTIONS_OVERRIDE environment variable to enforce an architecture; by default EESSI_ARCHDETECT_OPTIONS_OVERRIDE is unset, and the EESSI module selects an appropriate architecture for the software set (as the name suggests). The EESSI_ARCHDETECT_OPTIONS_OVERRIDE variable is set to x86_64/intel/haswell in the CPU partitions of iris by default and unset in every other partition. Note that architectural support in EESSI is relatively limited. The available CPU architectures in EESSI for Iris nodes are


- `x86_64/intel/haswell` for `broadwell` CPUs, and
- `x86_64/intel/skylake` for `skylake` CPUs.
EESSI does not provide builds optimized for all architectures, so the older haswell was chosen as the best alternative for broadwell which is missing.

Values for the RESIF_ARCH and EESSI_ARCHDETECT_OPTIONS_OVERRIDE environment variables in UL HPC systems
Cluster	Partition (--parition=)	Architecture (${RESIF_ARCH})	EESSI Architecture (EESSI_ARCHDETECT_OPTIONS_OVERRIDE)
Iris	batch	broadwell	x86_64/intel/haswell
Iris	interactive	broadwell	x86_64/intel/haswell
Iris	bigmem	skylake	
Iris	gpu	gpu	
Aion	batch	epyc	
Aion	interactive	epyc	
Note that all bigmen and skylake nodes use Skylake CPUs.

There are occasion where a user may want to set the software set manually. For instance, a job can be constrained to run on a single kind of CPU, using for instance the --constraint=skylake flag on sbatch or salloc to force the job to run only on Skylake nodes of the batch partition in Iris. In this case it makes sense to use a software set optimized for Skylake.

Selecting a natively optimized software set for Skylake CPUs in the Iris CPU partitions
Use an optimal EESSI software sets for Skylake CPUs in the Iris CPU partitions
You can always add a software set manually to MODULEPATH using the use option of the module command. To facilitate the organization of the natively optimized software sets the values of the RESIF_ARCH are used to determine the storage path of each software set. These location are summarized in the following table.

Location of natively optimized software set
Cluster	Arch. ${RESIF_ARCH}	${MODULEPATH} Environment variable
Iris	broadwell	/opt/apps/easybuild/systems/iris/<build version>/<software set version>/broadwell/modules/all
Iris	skylake	/opt/apps/easybuild/systems/iris/<build version>/<software set version>/skylake/modules/all
Iris	gpu	/opt/apps/easybuild/systems/iris/<build version>/<software set version>/gpu/modules/all
Aion	epyc	/opt/apps/easybuild/systems/aion/<build version>/<software set version>/epyc/modules/all
Module Naming Schemes

Module Naming Schemes on ULHPC system
ULHPC modules are organised through the Categorized Naming Scheme.

Format: <category>/<name>/<version>-<toolchain><versionsuffix>

This means that the typical module hierarchy has as prefix a category level, taken from one of the supported software category or module class:


$ eb --show-default-moduleclasses
Default available module classes:

        base:      Default module class
        ai:        Artificial Intelligence (incl. Machine Learning)
        astro:     Astronomy, Astrophysics and Cosmology
        bio:       Bioinformatics, biology and biomedical
        cae:       Computer Aided Engineering (incl. CFD)
        chem:      Chemistry, Computational Chemistry and Quantum Chemistry
        compiler:  Compilers
        data:      Data management & processing tools
        debugger:  Debuggers
        devel:     Development tools
        geo:       Earth Sciences
        ide:       Integrated Development Environments (e.g. editors)
        lang:      Languages and programming aids
        lib:       General purpose libraries
        math:      High-level mathematical software
        mpi:       MPI stacks
        numlib:    Numerical Libraries
        perf:      Performance tools
        quantum:   Quantum Computing
        phys:      Physics and physical systems simulations
        system:    System utilities (e.g. highly depending on system OS and hardware)
        toolchain: EasyBuild toolchains
        tools:     General purpose tools
        vis:       Visualization, plotting, documentation and typesetting
It follows that the ULHPC software modules are structured accordingly.

Using Easybuild to Create Custom Modules

You may want to use Easybuild to complete the existing software set with your own modules and software builds. See Building Custom (or missing) software documentation for more details.

Creating a Custom Module Environment

You can modify your environment so that certain modules are loaded whenever you log in. Use module save [<name>] and module restore [<name>] for that purpose, see Lmod documentation on User collections for more details.

You can also create and install your own modules for your convenience or for sharing software among collaborators. See the modulefile documentation for details of the required format and available commands. These custom modulefiles can be made visible to the module command by:


module use /path/to/the/custom/modulefiles
Warning
Make sure the UNIX file permissions grant access to all users who want to use the software.
Do not give write permissions to your home directory to anyone else.
Note
The module use command adds new directories before other module search paths (defined as ${MODULEPATH}), so modules defined in a custom directory will have precedence if there are other modules with the same name in the module search paths. If you prefer to have the new directory added at the end of ${MODULEPATH}, use module use -a instead of module use.

Module FAQ

What is module?
Is there an environment variable that captures loaded modules?
What is a Module Naming Scheme?
See our software list for a detailed list of available applications. ↩
See the basic info section for the terminology related to toolchains. 

Easybuild


EasyBuild is a software build and installation framework that allows you to manage scientific and other software on High Performance Computing systems in an efficient way. A large number of scientific software are supported (at least 3670 supported software packages since the 4.9.4 release).1

For several years now, Easybuild is used to manage the ULHPC User Software Set and generate automatically the module files available to you on our computational resources in either release (default) or testing (pre-release/testing) environment. This enables users to easily extend the global software set with their own local software builds, either stored within their global home directory, or preferably in a shared project directory. Easybuild generates automatically module files compliant with the ULHPC module setup.

Why use automatic building tools like Easybuild or Spack on HPC environments?
Easybuild Concepts and terminology

 Official Easybuild Tutorial

EasyBuild relies on two main concepts, toolchains and EasyConfig files. A toolchain corresponds to a compiler and a set of libraries which are commonly used to build a software. The two main toolchains frequently used on the UL HPC platform are foss (Free and Open Source Software) and intel toolchains.

foss is based on the GCC compiler and on open-source libraries (OpenMPI, OpenBLAS, etc.).
intel is based on the oneAPI Intel compiler suit and on Intel libraries, such as Intel MPI and Intel Math Kernel Library (MKL).
An EasyConfig file is a simple text file that describes the build process of a software. For most software that uses standard procedures (like configure, make and make install), this file is very simple. Many EasyConfig files are already provided with EasyBuild.

ULHPC Easybuild Configuration

To build software with Easybuild compliant with the configuration of the ULHPC facility, you need to be aware of the following setup:

Modules tool (${EASYBUILD_MODULES_TOOL}): Lmod
Module Naming Scheme (${EASYBUILD_MODULE_NAMING_SCHEME}): we use the hierarchical organization where the software are classified/categorized under a pre-defined class.
These variables are defined at the global profile level, under /etc/profile.d/ulhpc_resif.sh on the compute nodes with environment variables:


export EASYBUILD_MODULES_TOOL=Lmod
export EASYBUILD_MODULE_NAMING_SCHEME=CategorizedModuleNamingScheme
Configuring the build process

All builds and installations are performed at user level, so you don't need the admin (i.e. root) rights. The Easybuild prefix path for instance determines the location where the compiled software is configured and installed. You can configure EasyBuild variables such as the prefix path either through

environment variables, like ${EASYBUILD_PREFIX}, or
with flags like --prefix.
You can change the prefix path either by exporting the environment variable


export EASYBUILD_PREFIX=/path/to/desired/location/easybuild
or by passing the flag


eb --prefix=/path/to/desired/location/easybuild
when calling EasyBuild.

Flags and environment variable in EasyBuild
Each setting in EasyBuild can be controlled by an environment variable ${EASYBUILD_<NAME>} or the corresponding option flag, --<name>, of the EasyBuild (eb) script. The flags take precedence over the corresponding environment variable.

When installing software with EasyBuild, the program automatically detects the modules loaded in the system and only compiles the missing modules in the location pointed by ${EASYBUILD_PREFIX}. Both system modules and modules previously build by the user are detected by EasyBuild. The installed software effectively extends the ULHPC software set with your own local builds.

Selecting the installation location

The installation path of locally compiled EasyBuild modules is by default a subdirectory of the EasyBuild prefix path, ${EASYBUILD_PREFIX},


${EASYBUILD_PREFIX}/${EASYBUILD_SUBDIR_SOFTWARE}
where


${EASYBUILD_SUBDIR_SOFTWARE} = software
by default. The default value of prefix path is


${HOME}/.local/easybuild
which implies that software is installed in you home directory by default. As a rule of thump,

install any software on shared project directories, so that is can be shared by all project members and save space, by setting

export EASYBUILD_PREFIX=${PROJECTHOME}/<name>/easybuild
for a project <name>;
install any software that is used by yourself only on your home directory; set explicitly

export EASYBUILD_PREFIX=${HOME}/.local/easybuild
or use the --prefix flag in case the default location is modified in the future.
Configuring the structure of the installation directory

In order to integrate the modules that you create in your local directories seamlessly in the modules of the software set you need to set some environment variables. The default location where modules are stored is


${EASYBUILD_PREFIX}/${EASYBUILD_SUBDIR_MODULES}/${EASYBUILD_SUFFIX_MODULES_PATH}
where by default

${EASYBUILD_SUBDIR_MODULES} = modules and
${EASYBUILD_SUFFIX_MODULES_PATH} = all.
To access the compiled modules, you need to add the module path to the ${MODULEPATH} environment variable. Add the variable to the module using the use sub-command of the module environment management program:


module use ${EASYBUILD_PREFIX}/${EASYBUILD_SUBDIR_MODULES}/${EASYBUILD_SUFFIX_MODULES_PATH}
Structuring the module directory
The value


${EASYBUILD_MODULE_NAMING_SCHEME} = CategorizedModuleNamingScheme
ensures that the modules will appear in the correct category along side the software set modules when loading the module directory with module use.

Building optimized binaries

The advantage of EasyBuild over manual configuration and compilation of software is that it builds optimized binaries targeting the hardware used. If you build a single executable for all the architectures available in the UL HPC clusters you are achieving sub-par performance in all but the architecture for which your build is optimized. To help you configure your compilation, UL HPC systems export the following variables in all compute nodes,

${ULHPC_CLUSTER} with values
aion: in Aion compute nodes,
iris: in Iris compute nodes;
${RESIF_ARCH} with values
epyc: in Aion compute nodes;
broadwell: in Iris Broadwell and Skylake compute nodes in the batch partition;2
skylake: in Iris large memory nodes;
gpu: in Iris GPU nodes.
Compiling against the optimized software set
When compiling your software you have to ensure that

you are using the software set modules that are optimized for your target hardware, and
you are installing in a location where only modules for the target hardware are installed.
To load the correct modules for the compilation, simply login to a session on a compute node and load the desired environment setting module with the command,


module load env/<environment type>/<environment name>
where by default the env/release/default is loaded implicitly at login. Then, set your prefix path in your bashrc to:

export EASYBUILD_PREFIX=<path to desired root directory>/easybuild/${ULHPC_CLUSTER}/<environment type>/<environment name>/${RESIF_ARCH}
Automatically load local modules when logging in to compute nodes
You can optionally add the following to your bashrc to automatically load your modules in compute nodes,


if command -v module >/dev/null 2>&1; then
    module use "<path to desired root directory>/easybuild/${ULHPC_CLUSTER}/<environment type>/<environment name>/${RESIF_ARCH}/modules/all"
fi
assuming that you used the default values for ${EASYBUILD_SUBDIR_MODULES} and ${EASYBUILD_SUFFIX_MODULES_PATH}.

Installation and update of local Easybuild

The ULHPC software provides an EasyBuild module that can be loaded with the command:


module load tools/EasyBuild
You can use EasyBuild to bootstrap the installation of an up-to-date version of EasyBuild in your local module set. More detailed instructions are available in the official documentation.

See also "What is EasyBuild?". ↩
We don't optimize the binaries for the Skylake architecture in the batch partition of Iris; jobs in Iris may use a mix of Broadwell and Skylake architectures, so we try to use the same binary in all machines. ↩

Self management of work environments in UL HPC with Conda

Packages provided through the standard channels of modules and containers are optimized for the ULHPC clusters to ensure their performance and stability. However, many packages where performance is not critical and are used by few users are not provided through the standard channels. These packages can still be installed locally by the users through an environment management system such as Conda.

Contact the ULHPC before installing any software with Conda
Prefer binaries provided through modules or containers. Conda installs generic binaries that may be suboptimal for the configuration of the ULHPC clusters. Furthermore, installing packages locally with Conda consumes quotas in your or your project's account in terms of storage space and number of files.

Contact the ULHPC High Level Support Team in the service portal [Home > Research > HPC > Software environment > Request expertise] to discuss possible options before installing any software.

Conda is an open source environment and package management system. With Conda you can create independent environments, where you can install applications such as python and R, together with any packages which will be used by these applications. The environments are independent, with the Conda package manager managing the binaries, resolving dependencies, and ensuring that package used in multiple environments are stored only once. In a typical setting, each user has their own installation of a Conda and a set of personal environments.

TL;DR: install and use the Micromamba package manager.

A brief introduction to Conda

A few concepts are necessary to start working with Conda. In brief, these are package managers which are the programs used to create and manage environments, channels which are the repositories that contain the packages from which environments are composed, and distributions which are methods for shipping package managers.

Package managers

Package managers are the programs that install and manage the Conda environments. There are multiple package managers, such as conda, mamba, and micromamba.

The UL HPC centre supports the use of micromamba for the creation and management of personal Conda environments.

Channels

Conda channels are the locations where packages are stored. There are also multiple channels, with some important channels being:

defaults, the default channel,
anaconda, a mirror of the default channel,
bioconda, a distribution of bioinformatics software, and
conda-forge, a community-led collection of recipes, build infrastructure, and distributions for the conda package manager.
The most useful channel that comes pre-installed in all distributions, is Conda-Forge. Channels are usually hosted in the official Anaconda page, but in some rare occasions custom channels may be used. For instance the default channel is hosted independently from the official Anaconda page. Many channels also maintain web pages with documentation both for their usage and for packages they distribute:

Default Conda channel
Bioconda
Conda-Forge
Distributions

Quite often, the package manager is not distributed on its own, but with a set of packages that are required for the package manager to work, or even with some additional packages that required for most applications. For instance, the conda package manager is distributed with the Miniconda and Anaconda distributions. Miniconda contains the bare minimum packages for the conda package manager to work, and Anaconda contains multiple commonly used packages and a graphical user interface. The relation between these distributions and the package manager is depicted in the following diagram.



The situation is similar for Mamba distributions. These distributions are supported by Conda-Forge, and their default installation options set-up conda-forge as the default and only channel during installation. The defaults or its mirror anaconda must be explicitly added if required. The distribution using the Mamba package manager was originally distributed as Mambaforge and was recently renamed to Miniforge. Miniforge comes with a minimal set of python packages required by the Mamba package manager. The distribution using the Micromamba package manager ships no accompanying packages, as Micromamba is a standalone executable with no dependencies. Micromamba is using libmamba, a C++ library implementing the Conda API.

The Micromamba package manager


The Micromaba package manager is a minimal yet fairly complete implementation of the Conda interface in C++, that is shipped as a standalone executable. The package manager operates strictly on the user-space and thus it requires no special permissions are required to install packages. It maintains all its files in a couple of places, so uninstalling the package manager itself is also easy. Finally, the package manager is also lightweight and fast.

UL HPC provides support only for the Micromamba package manager.

Installation

A complete guide regarding Micromamba installation can be found in the official documentation. To install micromamaba in the HPC clusters, log in to Aion or Iris. Working on a login node, run the installation script,


"${SHELL}" <(curl -L micro.mamba.pm/install.sh)
which will install the executable and setup the environment. There are 4 options to select during the installation of Micromamba:
The directory for the installation of the binary file:

Micromamba binary folder? [~/.local/bin]
Leave empty and press enter to select the default displayed within brackets. Your .bashrc script should include ~/.local/bin in the $PATH by default.
The option to add to the environment autocomplete options for micromamba:

Init shell (bash)? [Y/n]
Press enter to select the default option Y. This will append a clearly marked section in the .bashrc shell. Do not forget to remove this section when uninstalling Micromamba.
The option to configure the channels by adding conda-forge:

Configure conda-forge? [Y/n]
Press enter to select the default option Y. This will setup the ~/.condarc file with conda-forge as the default channel. Note that Mamba and Micromamba will not use the defaults channel if it is not present in ~/.condarc like conda.
The option to select the directory where environment information and packages will be stored:

Prefix location? [~/micromamba]
Press enter to select the default option displayed within brackets.
To setup the environment log-out and log-in again. Now you can use micromamba, including the auto-completion feature.

Managing environments

As an example, the creation and use of an environment for R jobs is presented. The command,


micromamba create --name R-project
creates an environment named R-project. The environment is activated with the command

micromamba activate R-project
anywhere in the file system.
Next, install the base R environment package that contains the R program, and any R packages required by the project. To install packages, first ensure that the R-project environment is active, and then install any package with the command


micromamba install <package_name>
all the required packages. Quite often, the channel name must also be specified:

micromamba install --chanell <chanell_name> <package_name>
Packages can be found by searching the conda-forge channel.
For instance, the basic functionality of the R software environment is contained in the r-base package. Calling


micromamba install --channel conda-forge r-base
will install all the components required to run standalone R scripts. More involved scripts use functionality defined in various packages. The R packages are prepended with a prefix 'r-'. Thus, plm becomes r-plm and so on. After all the required packages have been installed, the environment is ready for use.
Packages in the conda-forge channel come with instructions for their installation. Quite often the channel is specified in the installation instructions, -c conda-forge or --channel conda-forge. While the Micromamba installer sets-up conda-forge as the default channel, latter modification in ~/.condarc may change the channel priority. Thus it is a good practice to explicitly specify the source channel when installing a package.

After work in an environment is complete, deactivate the environment,


micromamba deactivate
to ensure that it does not interfere with any other operations. In contrast to modules, Conda is designed to operate with a single environment active at a time. Create one environment for each project, and Conda will ensure that any package that is shared between multiple environments is installed once.
Micromamba supports almost all the subcommands of Conda. For more details see the official documentation.

Using environments in submission scripts

Since all computationally heavy operations must be performed in compute nodes, Conda environments are also used in jobs submitted to the queuing system. Returning to the R example, a submission script running a single core R job can use the R-project_name environment as follows:


#SBATCH --job-name R-test-job
#SBATCH --nodes 1
#SBATCH --ntasks-per-node 1
#SBATCH --cpus-per-task 1
#SBATCH --time=0-02:00:00
#SBATCH --partition batch
#SBATCH --qos normal

echo "Launched at $(date)"
echo "Job ID: ${SLURM_JOBID}"
echo "Node list: ${SLURM_NODELIST}"
echo "Submit dir.: ${SLURM_SUBMIT_DIR}"
echo "Numb. of cores: ${SLURM_CPUS_PER_TASK}"

micromamba activate R-project

export OMP_NUM_THREADS=1
srun Rscript --no-save --no-restore script.R

micromamba deactivate
Useful scripting resources

Formatting submission scripts for R (and other systems)
Cleaning up package data

The Conda environment managers download and store a sizable amount of data to provided packages to the various environments. Even though the package data are shared between the various environments, they still consume space in your or your project's account. There are limits in the storage space and number of files that are available to projects and users in the cluster. Since Conda packages are self managed, you need to clean unused data yourself.

There are two main sources of unused data, the compressed archives of the packages that Conda stores in its cache when downloading a package, and the data of removed packages. All unused data in Micromoamba can be removed with the command


micromamba clean --all
that opens up an interactive dialogue with details about the operations performed. You can follow the default option, unless you have manually edited any files in you package data directory (default location ${HOME}/micromamba).
Updating environments to remove old package versions
Sources

Oficial Conda clean documentation
Understanding Conda clean
Combining Conda with other package and environment management tools

It may be desirable to use Conda to manage environments but a different tool to manage packages, such as pip. Or subenvironments may need to be used inside a Conda environment, as for instance with tools for creating and managing isolated Python installation, such as virtualenv, or with tools for integrating managed Python installations and packages in project directories, such as Pipenv and Poetry.

Conda integrates well with any such tool. Some of the most frequent cases are described bellow.

Managing packages with external tools

Quite often a package that is required in an environment is not available through a Conda channel, but it is available through some other distribution channel, such as the Python Package Index (PyPI). In these cases the only solution is to create a Conda environment and install the required packages with pip from the Python Package Index.

Using an external packaging tool is possible because of the method that Conda uses to install packages. Conda installs package versions in a central directory (e.g. ~/micromamba/pkgs). Any environment that requires a package links to the central directory with hard links. Links are added to the home directory (e.g. ~/micromamba/envs/R-project for the R-project environment) of any environment that requires them. When using an external package tool, package components are installed in the same directory where Conda would install the corresponding link. Thus, external package management tools integrate seamlessly with Conda, with a couple of caveats:

each package must be managed by one tool, otherwise package components will get overwritten, and
packages installed by the package tool are specific to an environment and cannot be shared as with Conda, since components are installed directly and not with links.
Prefer Conda over external package managers
Installing the same package in multiple environments with an external package tool consumes quotas in terms of storage space and number of files, so prefer Conda when possible. This is particularly important for the inode limit, since some packages install a large number of files, and the hard links used by Conda do not consume inodes or disk space.

Pip

In this example pip is used to manage packages in a Conda environment with MkDocs related packages. To install the packages, create an environment


micromamba env create --name mkdocs
activate the environment,

micromamba activate mkdocs
and install pip

micromamba install --channel conda-forge pip
which will be used to install the remaining packages.
The pip will be the only package that will be managed with Conda. For instance, to update Pip activate the environment,


micromamba activate mkdocs
and run

micromaba update --all
to update all installed packaged (only pip in our case). All other packages are managed by pip.
For instance, assume that a mkdocs project requires the following packages:

mkdocs
mkdocs-minify-plugin
The package mkdocs-minify-plugin is less popular and thus is is not available though a Conda channel, but it is available in PyPI. To install it, activate the mkdocs environment


micromamba activate mkdocs
and install the required packages with pip

pip install --upgrade mkdocs mkdocs-minify-plugin
inside the environment. The packages will be installed inside a directory that micromamba created for the Conda environment, for instance

${HOME}/micromamba/envs/mkdocs
along side packages installed by micromamba. As a results, 'system-wide' installations with pip inside a Conda environment do not interfere with system packages.
Do not install packages in Conda environments with pip as a user
User installed packages (e.g.pip install --user --upgrade mkdocs-minify-plugin) are installed in the same directory for all environments, typically in ~/.local/, and can interfere with other versions of the same package installed from other Conda environments.

Pkg

The Julia programming language provides its own package and environment manager, Pkg. The package manager of Julia provides many useful capabilities and it is recommended that it is used with Julia projects. Details about the use of Pkg can be found in the official documentation.

The Pkg package manager comes packages with Julia. Start by creating an environment,


mocromamba env create --name julia
activate the environment,

micromamba activate julia
and install Julia,

micromamba install --channel conda-forge julia
to start using Pkg.
In order to install a Julia package, activate the Julia environment, and start an interactive REPL session,


$ julia
julia>
by just calling julia without any input files.
Enter the Pkg package manager by pressing ].
Exit the package manager by clearing all the input from the line with backspace, and then pressing backspace one more time.
In the package manager you can see the status of the current environment,


(@julia) pkg> status
Status `~/micromamba/envs/julia/share/julia/environments/julia/Project.toml` (empty project)
add or remove packages,

(@julia) pkg> add Example
(@julia) pkg> remove Example
update the packages in the environment,

(@julia) pkg> update
and perform many other operations, such as exporting and importing environments from plain text files which describe the environment setup, and pinning packages to specific versions. The Pkg package manager maintains a global environment, but also supports the creation and use of local environments that are used within a project directory. The use of local environments is highly recommended, please read the documentation for more information.
After installing the Julia language in a Conda environment, the language distribution itself should be managed with micromamba and all packages in global or local environments with the Pkg package manager. To update Julia activate the Conda environment where Julia is stored and call


micromamba update julia
where as to update packages installed with Pgk use the update command of Pkg. The packages for local and global environments are stored in the Julia installation directory, typically

${HOME}/micromamba/envs/julia/share
if the default location for the Micromamba environment directory is used.
Advanced management of package data
Useful resources

Pkg documentation
Combining Conda with external environment management tools

Quite often it is required to create isolated environments using external tools. For instance, tools such as virtualenv can install and manage a Python distribution in a given directory and export and import environment descriptions from text files. This functionalities allows for instance the shipping of a description of the Python environment as part of a project. Higher level tools such as pipenv automate the process by managing the Python environment as part of a project directory. The description of the environment is stored in version controlled files, and the Python packages are stored in a non-tracked directory within the project directory. Some wholistic project management tools, such as poetry, further integrate the management of the Python environment withing the project management workflow.

Installing and using in Conda environments tools that create isolated environments is relatively straight forward. Create an environment where only the required that tool is installed, and manage any subenvironments using the installed tool.

Create a different environment for each tool
While this is not a requirement it is a good practice. For instance, pipenv and poetry used to and may still have conflicting dependencies; Conda detects the dependency and aborts the conflicting installation.

Pipenv

To demonstrate the usage of pipenv, create a Conda environment,


micromamba enc create --name pipenv
activate it

micromamba activate pipenv
and install the pipenv package

micromamba install --channel conda-forge pipenv
as the only package in this environment. Now the pipenv is managed with Conda, for instance to update pipenv activate the environment

micromamba activate pipenv
and call

micromamba update --all
to update the single installed package. Inside the environment use pipenv as usual to create and manage project environments.

Acceptable Use Policy (AUP) 2.1

The University of Luxembourg operates since 2007 a large academic HPC facility which remains the reference implementation within the country, offering a cutting-edge research infrastructure to Luxembourg public research while serving as edge access to the upcoming Euro-HPC Luxembourg supercomputer. The University extends access to its HPC resources (including facilities, services and HPC experts) to its students, staff, research partners (including scientific staff of national public organizations and external partners for the duration of joint research projects) and to industrial partners.

UL HPC AUP

There are a number of policies which apply to ULHPC users.

 UL HPC Acceptable Use Policy (AUP) [pdf]

Important
All users of UL HPC resources and PIs must abide by the UL HPC Acceptable Use Policy (AUP). You should read and keep a signed copy of this document before using the facility.

Access and/or usage of any ULHPC system assumes the tacit acknowledgement to this policy.

The purpose of this document is to define the rules and terms governing acceptable use of resources (core hours, license hours, data storage capacity as well as network connectivity and technical support), including access, utilization and security of the resources and data.

Crediting ULHPC in your research

One of the requirements stemming from the AUP, is to credit and acknowledge the usage of the University of Luxembourg HPC facility for ALL publications and contributions having results and/or contents obtained or derived from that usage.

Publication tagging

You are also requested to tag the publication(s) you have produced thanks to the usage of the UL HPC platform upon their registration on Orbilu:

Login on MyOrbiLu
Select your publication entry and click on the "Edit" button
Select the "2. Enrich" category at the top of the page
In the "Research center" field, enter "ulhpc" and select the proposition


This tag is a very important indicator for us to quantify the concrete impact of the HPC facility on the research performed at the University.

Maintenance and Downtime Policy


Scheduled Maintenance

The ULHPC team will schedule maintenance in one of three manners:

Rolling reboots Whenever possible, ULHPC will apply updates and do other maintenance in a rolling fashion in such a manner as to have either no or as little impact as possible to ULHPC services
Partial outages We will do these as needed but in a manner that impacts only some ULHPC services at a time
Full outages These are outages that will affect all ULHPC services, such as outages of core datacenter networking services, datacenter power of HVAC/cooling system maintenance or global GPFS/Spectrumscale filesystem updates. Such maintenance windows typically happen on a quarterly basis. It should be noted that we are not always able to anticipate when these outages are needed.
ULHPC's goal for these downtimes is to have them completed as fast as possible. However, validation and qualification of the full platform takes typically one working day, and unforeseen or unusual circumstances may occur. So count for such outages a multiple-day downtime.

Notifications

We normally inform users of cluster maintenance at least 3 weeks in advance by mail using the HPC User community mailing list (moderated): hpc-users@uni.lu. A second reminder is sent a few days prior to actual downtime.

The news of the downtimes is also posted on the hpc/support/infra issue tracker/.

A colored "message of the day" (motd) banner is displayed on all access/login servers such that you can quickly be informed of any incoming maintenance operation upon connection to the cluster. You can see this when you login or (again),any time by issuing the command:


cat /etc/motd
Detecting maintenance... During the maintenance
During the maintenance period, access to the involved cluster access/login serveur is DENIED and any users still logged-in are disconnected at the beginning of the maintenance
you will receive a written message in your terminal
if for some reason during the maintenance you urgently need to collect data from your account, please contact the UL HPC Team by sending a mail to: hpc-team@uni.lu.
We will notify you of the end of the maintenance with a summary of the performed operations.
Exceptional "EMERGENCY" maintenance

Unscheduled downtimes can occur for any number of reasons, including:

Loss of cooling and/or power in the data center.
Loss of supporting infrastructure (i.e. hardware).
Critical need to make changes to hardware or software that negatively impacts performance or access.
Application of critical patches that can't wait until the next scheduled maintenance.
For safety or security issues that require immediate action.
We will try to notify users in the advent of such event by email.

Danger
The ULHPC team reserves the right to intervene in user activity without notice when such activity may destabilize the platform and/or is at the expense of other users, and/or to monitor/verify/debug ongoing system activity.

ULHPC Usage Charging Policy

The advertised prices are for internal partners only
The price list and all other information of this page are meant for internal partners, i.e., not for external companies. If you are not an internal partner, please contact us at hpc-partnership@uni.lu. Alternatively, you can contact LuxProvide, the national HPC center which aims at serving the private sector for HPC needs.

How to estimate HPC costs for projects?

You can use the following excel document to estimate the cost of your HPC usage:

 UL HPC Cost Estimates for Project Proposals [xlsx]

Note that there are two sheets offering two ways to estimate based on your specific situation. Please read the red sections to ensure that you are using the correct estimation sheet.

Note that even if you plan for large-scale experiments on PRACE/EuroHPC supercomputers through computing credits granted by Call for Proposals for Project Access, you should plan for ULHPC costs since you will have to demonstrate the scalability of your code -- the University's facility is ideal for that. You can contact hpc-partnership@uni.lu for more details about this.

HPC price list - 2022-10-01

Note that ULHPC price list has been updated, see below.

Compute

Compute type	Description	€ (excl. VAT) / node-hour
CPU - small	28 cores, 128 GB RAM	0.25€
CPU - regular	128 cores, 256 GB RAM	1.25€
CPU - big mem	112 cores, 3 TB RAM	6.00€
GPU	4 V100, 28 cores, 768 GB RAM	5.00€
The prices above correspond to a full-node cost. However, jobs can use a fraction of a node and the price of the job will be computed based on that fraction. Please find below the core-hour / GPU-hour costs and how we compute how much to charge:

Compute type	Unit	€ (excl. VAT)
CPU - small	Core-hour	0.0089€
CPU - regular	Core-hour	0.0097€
CPU - big mem	Core-hour	0.0535€
GPU	GPU-hour	1.25€
For CPU nodes, the fraction correspond to the number of requested cores, e.g. 64 cores on a CPU - regular node corresponds to 50% of the available cores and thus will be charged 50% of 1.25€.

Regarding the RAM of a job, if you do not override the default behaviour, you will receive a percentage of the RAM corresponding to the amount of requested cores, e.g, 128G of RAM for the 64 cores example from above (50% of a CPU - regular node). If you override the default behaviour and request more RAM, we will re-compute the equivalent number of cores, e.g. if you request 256G of RAM and 64 cores, we will charge 128 cores.

For GPU nodes, the fraction considers the number of GPUs. There are 4 GPUs, 28 cores and 768G of RAM on one machine. This means that for each GPU, you can have up to 7 cores and 192G of RAM. If you request more than those default, we will re-compute the GPU equivalent, e.g. if you request 1 GPU and 8 cores, we will charge 2 GPUs.

Storage

Storage type	€ (excl. VAT) / GB / Month	Additional information
Home	Free	500 GB
Project	0.02€	1 TB free
Scratch	Free	10 TB
Note that for project storage, we charge the quota and not the used storage.

HPC Resource allocation for UL internal R&D and training

ULHPC resources are free of charge for UL staff for their internal work and training activities. Principal Investigators (PI) will nevertheless receive on a regular basis a usage report of their team activities on the UL HPC platform. The corresponding accumulated price will be provided even if this amount is purely indicative and won't be charged back.

Any other activities will be reviewed with the rectorate and are a priori subjected to be billed.

Submit project related jobs

To allow the ULHPC team to keep track of the jobs related to a project, use the -A <projectname> flag in Slurm, either in the Slurm directives preamble of your script, e.g.,


#SBATCH -A myproject
or on the command line when you submit your job, e.g., sbatch -A myproject /path/to/launcher.sh

Slurm Resource and Job Management System

ULHPC uses Slurm (Simple Linux Utility for Resource Management) for cluster/resource management and job scheduling. This middleware is responsible for allocating resources to users, providing a framework for starting, executing and monitoring work on allocated resources and scheduling work for future execution.

 Official docs  Official FAQ  ULHPC Tutorial/Getting Started



IEEE ISPDC22: ULHPC Slurm 2.0
If you want more details on the RJMS optimizations performed upon Aion acquisition, check out our IEEE ISPDC22 conference paper (21st IEEE Int. Symp. on Parallel and Distributed Computing) presented in Basel (Switzerland) on July 13, 2022.

IEEE Reference Format | ORBilu entry | slides
Sebastien Varrette, Emmanuel Kieffer, and Frederic Pinel, "Optimizing the Resource and Job Management System of an Academic HPC and Research Computing Facility". In 21st IEEE Intl. Symp. on Parallel and Distributed Computing (ISPDC’22), Basel, Switzerland, 2022.

TL;DR Slurm on ULHPC clusters

In its concise form, the Slurm configuration in place on ULHPC supercomputers features the following attributes you should be aware of when interacting with it:

Predefined Queues/Partitions depending on node type
batch (Default Dual-CPU nodes) Max: 64 nodes, 2 days walltime
gpu (GPU nodes nodes) Max: 4 nodes, 2 days walltime
bigmem (Large-Memory nodes) Max: 1 node, 2 days walltime
In addition: interactive (for quicks tests) Max: 2 nodes, 2h walltime
for code development, testing, and debugging
Queue Policy: cross-partition QOS, mainly tied to priority level (low  urgent)
long QOS with extended Max walltime (MaxWall) set to 14 days
special preemptible QOS for best-effort jobs: besteffort.
Accounts hierarchy associated to supervisors (multiple associations possible), projects or trainings
you MUST use the proper account as a detailed usage tracking is performed and reported.
Slurm Federation configuration between iris and aion
ensures global policy (coherent job ID, global scheduling, etc.) within ULHPC systems
easily submit jobs from one cluster to another using -M, --cluster aion|iris
For more details, see the appropriate pages in the left menu.

Jobs

A job is an allocation of resources such as compute nodes assigned to a user for an certain amount of time. Jobs can be interactive or passive (e.g., a batch script) scheduled for later execution.

What characterize a job?
A user jobs have the following key characteristics:

set of requested resources:
number of computing resources: nodes (including all their CPUs and cores) or CPUs (including all their cores) or cores
amount of memory: either per node or per CPU
(wall)time needed for the users tasks to complete their work
a requested node partition (job queue)
a requested quality of service (QoS) level which grants users specific accesses
a requested account for accounting purposes
Once a job is assigned a set of nodes, the user is able to initiate parallel work in the form of job steps (sets of tasks) in any configuration within the allocation.

When you login to a ULHPC system you land on a access/login node. Login nodes are only for editing and preparing jobs: They are not meant for actually running jobs. From the login node you can interact with Slurm to submit job scripts or start interactive jobs, which will be further run on the compute nodes.

Submit Jobs

There are three ways of submitting jobs with slurm, using either sbatch, srun or salloc:

sbatch (passive job)

### /!\ Adapt <partition>, <qos>, <account> and <command> accordingly
sbatch -p <partition> [--qos <qos>] [-A <account>] [...] <path/to/launcher.sh>
srun (interactive job)
salloc (request allocation/interactive job)
sbatch

sbatch is used to submit a batch launcher script for later execution, corresponding to batch/passive submission mode. The script will typically contain one or more srun commands to launch parallel tasks. Upon submission with sbatch, Slurm will:

allocate resources (nodes, tasks, partition, constraints, etc.)
runs a single copy of the batch script on the first allocated node
in particular, if you depend on other scripts, ensure you have refer to them with the complete path toward them.
When you submit the job, Slurm responds with the job's ID, which will be used to identify this job in reports from Slurm.


# /!\ ADAPT path to launcher accordingly
$ sbatch <path/to/launcher>.sh
Submitted batch job 864933
srun

srun is used to initiate parallel job steps within a job OR to start an interactive job Upon submission with srun, Slurm will:

(eventually) allocate resources (nodes, tasks, partition, constraints, etc.) when run for interactive submission
launch a job step that will execute on the allocated resources.
A job can contain multiple job steps executing sequentially or in parallel on independent or shared resources within the job's node allocation.

salloc

salloc is used to allocate resources for a job in real time. Typically this is used to allocate resources (nodes, tasks, partition, etc.) and spawn a shell. The shell is then used to execute srun commands to launch parallel tasks.

Specific Resource Allocation

Within a job, you aim at running a certain number of tasks, and Slurm allow for a fine-grain control of the resource allocation that must be satisfied for each task.

Beware of Slurm terminology in Multicore Architecture!

Slurm Node = Physical node, specified with -N <#nodes>
Advice: always explicit number of expected number of tasks per node using --ntasks-per-node <n>. This way you control the node footprint of your job.
Slurm Socket = Physical Socket/CPU/Processor
Advice: if possible, explicit also the number of expected number of tasks per socket (processor) using --ntasks-per-socket <s>.
relations between <s> and <n> must be aligned with the physical NUMA characteristics of the node.
For instance on aion nodes, <n> = 8*<s>
For instance on iris regular nodes, <n>=2*<s> when on iris bigmem nodes, <n>=4*<s>.
(the most confusing): Slurm CPU = Physical CORE
use -c <#threads> to specify the number of cores reserved per task.
Hyper-Threading (HT) Technology is disabled on all ULHPC compute nodes. In particular:
assume #cores = #threads, thus when using -c <threads>, you can safely set

OMP_NUM_THREADS=${SLURM_CPUS_PER_TASK:-1} # Default to 1 if SLURM_CPUS_PER_TASK not set
to automatically abstract from the job context
you have interest to match the physical NUMA characteristics of the compute node you're running at (Ex: target 16 threads per socket on Aion nodes (as there are 8 virtual sockets per nodes, 14 threads per socket on Iris regular nodes).
The total number of tasks defined in a given job is stored in the $SLURM_NTASKS environment variable.

The --cpus-per-task option of srun in Slurm 23.11 and later
In the latest versions of Slurm srun inherits the --cpus-per-task value requested by salloc or sbatch by reading the value of SLURM_CPUS_PER_TASK, as for any other option. This behavior may differ from some older versions where special handling was required to propagate the --cpus-per-task option to srun.

In case you would like to launch multiple programs in a single allocation/batch script, divide the resources accordingly by requesting resources with srun when launching the process, for instance:


srun --cpus-per-task <some of the SLURM_CPUS_PER_TASK> --ntasks <some of the SLURM_NTASKS> [...] <program>
We encourage you to always explicitly specify upon resource allocation the number of tasks you want per node/socket (--ntasks-per-node <n> --ntasks-per-socket <s>), to easily scale on multiple nodes with -N <N>. Adapt the number of threads and the settings to match the physical NUMA characteristics of the nodes

Aion
16 cores per socket and 8 (virtual) sockets (CPUs) per aion node.

{sbatch|srun|salloc|si} [-N <N>] --ntasks-per-node <8n> --ntasks-per-socket <n> -c <thread>
Total: <N><n> tasks, each on <thread> threads
Ensure <n><thread>= 16
Ex: -N 2 --ntasks-per-node 32 --ntasks-per-socket 4 -c 4 (Total: 64 tasks)
Iris (default Dual-CPU)
Iris (Bigmem)
Job submission options

There are several useful environment variables set be Slurm within an allocated job. The most important ones are detailed in the below table which summarizes the main job submission options offered with {sbatch | srun | salloc} [...]:

Command-line option	Description	Example
-N <N>	<N> Nodes request	-N 2
--ntasks-per-node=<n>	<n> Tasks-per-node request	--ntasks-per-node=28
--ntasks-per-socket=<s>	<s> Tasks-per-socket request	--ntasks-per-socket=14
-c <c>	<c> Cores-per-task request (multithreading)	-c 1
--mem=<m>GB	<m>GB memory per node request	--mem 0
-t [DD-]HH[:MM:SS]>	Walltime request	-t 4:00:00
-G <gpu>	<gpu> GPU(s) request	-G 4
-C <feature>	Feature request (broadwell,skylake...)	-C skylake
-p <partition>	Specify job partition/queue	
--qos <qos>	Specify job qos	
-A <account>	Specify account	
-J <name>	Job name	-J MyApp
-d <specification>	Job dependency	-d singleton
--mail-user=<email>	Specify email address	
--mail-type=<type>	Notify user by email when certain event types occur.	--mail-type=END,FAIL
At a minimum a job submission script must include number of nodes, time, type of partition and nodes (resource allocation constraint and features), and quality of service (QOS). If a script does not specify any of these options then a default may be applied. The full list of directives is documented in the man pages for the sbatch command (see. man sbatch).

#SBATCH directives vs. CLI options

Each option can be specified either as an #SBATCH [...] directive in the job submission script:


#!/bin/bash -l                # <--- DO NOT FORGET '-l'
### Request a single task using one core on one node for 5 minutes in the batch queue
#SBATCH -N 2
#SBATCH --ntasks-per-node=1
#SBATCH -c 1
#SBATCH --time=0-00:05:00
#SBATCH -p batch
# [...]
Or as a command line option when submitting the script:


$ sbatch -p batch -N 2 --ntasks-per-node=1 -c 1 --time=0-00:05:00 ./first-job.sh
The command line and directive versions of an option are equivalent and interchangeable: if the same option is present both on the command line and as a directive, the command line will be honored. If the same option or directive is specified twice, the last value supplied will be used. Also, many options have both a long form, eg --nodes=2 and a short form, eg -N 2. These are equivalent and interchangable.

Common options to sbatch and srun
HW characteristics and Slurm features of ULHPC nodes

When selecting specific resources allocations, it is crucial to match the hardware characteristics of the computing nodes. Details are provided below:

Node (type)	#Nodes	#Socket / #Cores	RAM [GB]	Features
aion-[0001-0354]	354	8 / 128	256	batch,epyc
iris-[001-108]	108	2 / 28	128	batch,broadwell
iris-[109-168]	60	2 / 28	128	batch,skylake
iris-[169-186] (GPU)	18	2 / 28	768	gpu,skylake,volta
iris-[191-196] (GPU)	6	2 / 28	768	gpu,skylake,volta32
iris-[187-190]
(Large-Memory)	4	4 / 112	3072	bigmem,skylake
As can be seen, Slurm [features] are associated to ULHPC compute nodes and permits to easily filter with the -C <feature> option the list of nodes.

To list available features, use sfeatures:


sfeatures
# sinfo  -o '%20N %.6D %.6c %15F %12P %f'
# NODELIST              NODES   CPUS NODES(A/I/O/T)  PARTITION    AVAIL_FEATURES
# [...]
Always try to align resource specifications for your jobs with physical characteristics
The typical format of your Slurm submission should thus probably be:


sbatch|srun|... [-N <N>] --ntasks-per-node <n> -c <thread> [...]
sbatch|srun|... [-N <N>] --ntasks-per-node <#sockets * s> --ntasks-per-socket <s> -c <thread> [...]
This would define a total of <N><n> TASKS (first form) or <N><s> TASKS (second form), each on <thread> threads.  You MUST ensure that either:
<n><thread> matches the number of cores avaiable on the target computing node (first form), or
<n>=<s>, and <s><thread> matches the number of cores per socket available on the target computing node (second form).
Aion (default Dual-CPU)
16 cores per socket and 8 virtual sockets (CPUs) per aion node. Depending on the selected form, you MUST ensure that either <n><thread>=128, or that <n>=8<s> and <s><thread>=16.


### Example 1 - use all cores available
{sbatch|srun|salloc} -N 2 --ntasks-per-node 32 --ntasks-per-socket 4 -c 4 [...]
# Total: 64 tasks (spread across 2 nodes), each on 4 cores/threads

### Example 2 - use all cores available
{sbatch|srun|salloc} --ntasks-per-node 128 -c 1  [...]
# Total; 128 (single-core) tasks

### Example 3 - use all cores available
{sbatch|srun|salloc} -N 1 --ntasks-per-node 8 --ntasks-per-socket 1 -c 16 [...]
# Total: 8 tasks, each on 16 cores/threads

### Example 4 - use all cores available
{sbatch|srun|salloc} -N 1 --ntasks-per-node 2 -c 64 [...]
# Total: 2 tasks, each on 64 cores/threads
Iris (default Dual-CPU)
Iris (Large-Memory)
Using Slurm Environment variables

Recall that the Slurm controller will set several SLURM_* variables in the environment of the batch script. The most important are listed in the table below - use them wisely to make your launcher script as flexible as possible to abstract and adapt from the allocation context, "independently" of the way the job script has been submitted.

Submission option	Environment variable	Typical usage
-N <N>	SLURM_JOB_NUM_NODES or
SLURM_NNODES	
--ntasks-per-node=<n>	SLURM_NTASKS_PER_NODE	
--ntasks-per-socket=<s>	SLURM_NTASKS_PER_SOCKET	
-c <c>	SLURM_CPUS_PER_TASK	OMP_NUM_THREADS=${SLURM_CPUS_PER_TASK}
SLURM_NTASKS
Total number of tasks	srun -n $SLURM_NTASKS [...]


Main Slurm Commands

Submit Jobs

There are three ways of submitting jobs with slurm, using either sbatch, srun or salloc:

sbatch (passive job)

### /!\ Adapt <partition>, <qos>, <account> and <command> accordingly
sbatch -p <partition> [--qos <qos>] [-A <account>] [...] <path/to/launcher.sh>
srun (interactive job)
salloc (request allocation/interactive job)
sbatch

sbatch is used to submit a batch launcher script for later execution, corresponding to batch/passive submission mode. The script will typically contain one or more srun commands to launch parallel tasks. Upon submission with sbatch, Slurm will:

allocate resources (nodes, tasks, partition, constraints, etc.)
runs a single copy of the batch script on the first allocated node
in particular, if you depend on other scripts, ensure you have refer to them with the complete path toward them.
When you submit the job, Slurm responds with the job's ID, which will be used to identify this job in reports from Slurm.


# /!\ ADAPT path to launcher accordingly
$ sbatch <path/to/launcher>.sh
Submitted batch job 864933
srun

srun is used to initiate parallel job steps within a job OR to start an interactive job Upon submission with srun, Slurm will:

(eventually) allocate resources (nodes, tasks, partition, constraints, etc.) when run for interactive submission
launch a job step that will execute on the allocated resources.
A job can contain multiple job steps executing sequentially or in parallel on independent or shared resources within the job's node allocation.

salloc

salloc is used to allocate resources for a job in real time. Typically this is used to allocate resources (nodes, tasks, partition, etc.) and spawn a shell. The shell is then used to execute srun commands to launch parallel tasks.

Interactive jobs: si*

You should use the helper functions si, si-gpu, si-bigmem to submit an interactive job.

For more details, see interactive jobs.

Collect Job Information

Command	Description
sacct [-X] -j <jobid> [...]	display accounting information on jobs.
scontrol show [...]	view and/or update system, nodes, job, step, partition or reservation status
seff <jobid>	get efficiency metrics of past job
smap	graphically show information on jobs, nodes, partitions
sprio	show factors that comprise a jobs scheduling priority
squeue [-u $(whoami)]	display jobs[steps] and their state
sstat	show status of running jobs.
squeue

You can view information about jobs located in the Slurm scheduling queue (partition/qos), eventually filter on specific job state (R:running /PD:pending / F:failed / PR:preempted) with squeue:


$ squeue [-u <user>] [-p <partition>] [---qos <qos>] [--reservation <name>] [-t R|PD|F|PR]
To quickly access your jobs, you can simply use sq

Live job statistics

You can use the scurrent (for current interactive job) or (more generally) scontrol show job <jobid> to collect detailed information for a running job.

scontrol show job <jobid>
Past job statistics: slist, sreport

Use the slist helper for a given job:


# /!\ ADAPT <jobid> accordingly
$ slist <jobid>
# sacct -j <JOBID> --format User,JobID,Jobname%30,partition,state,time,elapsed,\
#              MaxRss,MaxVMSize,nnodes,ncpus,nodelist,AveCPU,ConsumedEnergyRaw
# seff <jobid>
You can also use sreport o generate reports of job usage and cluster utilization for Slurm jobs. For instance, to list your usage in CPU-hours since the beginning of the year:


$ sreport -t hours cluster UserUtilizationByAccount Users=$USER  Start=$(date +%Y)-01-01
--------------------------------------------------------------------------------
Cluster/User/Account Utilization 2021-01-01T00:00:00 - 2021-02-13T23:59:59 (3801600 secs)
Usage reported in CPU Hours
----------------------------------------------------------------------------
  Cluster     Login     Proper Name                Account     Used   Energy
--------- --------- --------------- ---------------------- -------- --------
     iris   <login>          <name> <firstname>.<lastname>    [...]
     iris   <login>          <name>      project_<acronym>    [...]
Job efficiency

seff

Use seff to double check a past job CPU/Memory efficiency. Below examples should be self-speaking:

Good CPU Eff.

$ seff 2171749
Job ID: 2171749
Cluster: iris
User/Group: <login>/clusterusers
State: COMPLETED (exit code 0)
Nodes: 1
Cores per node: 28
CPU Utilized: 41-01:38:14
CPU Efficiency: 99.64% of 41-05:09:44 core-walltime
Job Wall-clock time: 1-11:19:38
Memory Utilized: 2.73 GB
Memory Efficiency: 2.43% of 112.00 GB
Good Memory Eff.
Good CPU and Memory Eff.
[Very] Bad efficiency
Note however that demonstrating a CPU good efficiency with seff may not be enough! You may still induce an abnormal load on the reserved nodes if you spawn more processes than allowed by the Slurm reservation. To avoid that, always try to prefix your executions with srun within your launchers. See also Specific Resource Allocations.

susage

Use susage to check your past jobs walltime accuracy (Timelimit vs. Elapsed)


$ susage -h
Usage: susage [-m] [-Y] [-S YYYY-MM-DD] [-E YYYT-MM-DD]
  For a specific user (if accounting rights granted):    susage [...] -u <user>
  For a specific account (if accounting rights granted): susage [...] -A <account>
Display past job usage summary
Official sacct command

Alternatively, you can use sacct (use sacct --helpformat to get the list of) for COMPLETED or TIMEOUT jobs (see Job State Codes).

using sacct -X -S <start> [...] --format [...],time,elapsed,[...]
Platform Status

sinfo

sinfo allow to view information about partition status (-p <partition>), problematic nodes (-R), reservations (-T), eventually in a summarized form (-s),


sinfo [-p <partition>] {-s | -R | -T |...}
We are providing a certain number of helper functions based on sinfo:

Command	Description
nodelist	List available nodes
allocnodes	List currently allocated nodes
idlenodes	List currently idle nodes
deadnodes	List dead nodes per partition (hopefully none ;))
sissues	List nodes with issues/problems, with reasons
sfeatures	List available node features
Cluster, partition and QOS usage stats

We have defined several custom ULHPC Slurm helpers defined in /etc/profile.d/slurm.sh to facilitate access to account/parition/qos/usage information. They are listed below.

Command	Description
acct <name>	Get information on user/account holder <name> in Slurm accounting DB
irisstat, aionstat	report cluster status (utilization, partition and QOS live stats)
listpartitionjobs <part>	List jobs (and current load) of the slurm partition <part>
pload [-a] i/b/g/m	Overview of the Slurm partition load
qload [-a] <qos>	Show current load of the slurm QOS <qos>
sbill <jobid>	Display job charging / billing summary
sjoin [-w <node>]	join a running job
sassoc <name>	Show Slurm association information for <name> (user or account)
slist <jobid> [-X]	List statistics of a past job
sqos	Show QOS information and limits
susage [-m] [-Y] [...]	Display past job usage summary
Updating jobs

Command	Description
scancel <jobid>	cancel a job or set of jobs.
scontrol update jobid=<jobid> [...]	update pending job definition
scontrol hold <jobid>	Hold job
scontrol resume <jobid>	Resume held job
The scontrol command allows certain charactistics of a job to be updated while it is still queued (i.e. not running ), with the syntax scontrol update jobid=<jobid> [...]

Important
Once the job is running, most changes requested with scontrol update jobid=[...] will NOT be applied.

Change timelimit


# /!\ ADAPT <jobid> and new time limit accordingly
scontrol update jobid=<jobid> timelimit=<[DD-]HH:MM::SS>
Change QOS or Reservation


# /!\ ADAPT <jobid>, <qos>, <resname> accordingly
scontrol update jobid=<jobid> qos=<qos>
scontrol update jobid=<jobid> reservationname=<resname>
Change account

If you forgot to specify the expected project account:


# /!\ ADAPT <jobid>, <account> accordingly
scontrol update jobid=<jobid> account=<account>
The new account must be eligible to run the job. See Account Hierarchy for more details.

Hold and Resume jobs

Prevent a pending job from being started:


# /!\ ADAPT <jobid>  accordingly
scontrol hold <jobid>
Allow a held job to accrue priority and run:


# /!\ ADAPT <jobid>  accordingly
scontrol release <jobid>
Cancel jobs

Cancel a specific job:


# /!\ ADAPT <jobid> accordingly
scancel <jobid>
Cancel all jobs owned by a user (you)
Last update: March 13, 2025

ULHPC Slurm Partitions

In Slurm multiple nodes can be grouped into partitions which are sets of nodes aggregated by shared characteristics or objectives, with associated limits for wall-clock time, job size, etc. These limits are hard limits for the jobs and can not be overruled.

To select a given partition with a Slurm command, use the -p <partition> option:


srun|sbatch|salloc|sinfo|squeue... -p <partition> [...]
You will find on ULHPC resources the following partitions (mostly matching the 3 types of computing resources)

batch is intended for running parallel scientific applications as passive jobs on "regular" nodes (Dual CPU, no accelerators, 128 to 256 GB of RAM)
gpu is intended for running GPU-accelerated scientific applications as passive jobs on "gpu" nodes (Dual CPU, 4 Nvidia accelerators, 768 GB RAM)
bigmem is dedicated for memory intensive data processing jobs on "bigmem" nodes (Quad-CPU, no accelerators, 3072 GB RAM)
interactive: a floating partition intended for quick interactive jobs, allowing for quick tests and compilation/preparation work.
this is the only partition crossing all type of nodes (thus floating).
use si, si-gpu or si-bigmem to submit an interactive job on either a regular, gpu or bigmem node
Aion

AION (type)	#Nodes (cores/node)	Default/MaxTime	MaxNodes	PriorityTier
interactive (floating)	354	30min - 2h	2	100
batch (default)	354 (128c)	2h - 48h	64	1
Iris

IRIS (type)	#Nodes (cores/n)	Default/MaxTime	MaxNodes	PriorityTier
interactive (floating)	196	30min - 2h	2	100
batch (default)	168 (28c)	2h - 48h	64	1
gpu	24 (28c)	2h - 48h	4	1
bigmem	4 (112c)	2h - 48h	1	1
Queues/Partitions State Information

For detailed information about all available partitions and their definition/limits:


scontrol show partitions [name]
Partition load status

You can of course use squeue -p <partition> to list the jobs currently scheduled on a given, partition <partition>.

As part of the custom ULHPC Slurm helpers defined in /etc/profile.d/slurm.sh, the following commands have been made to facilitate the review of the current load usage of the partitions.

Command	Description
irisstat, aionstat	report cluster status (utilization, partition and QOS live stats)
pload [-a] i/b/g/m	Overview of the Slurm partition load
listpartitionjobs <part>	List jobs (and current load) of the slurm partition <part>
Partition load with pload

$ pload -h
Usage: pload [-a] [--no-header] <partition>
 => Show current load of the slurm partition <partition>, eventually without header
    <partition> shortcuts: i=interactive b=batch g=gpu m=bigmem
 Options:
   -a: show all partition
$ pload -a
  Partition  CPU Max  CPU Used  CPU Free     Usage[%]
      batch     4704      4223       481       89.8%
        gpu      672       412       260       61.3% GPU: 61/96 (63.5%)
     bigmem      448       431        17       96.2%
Partition Limits

At partition level, only the following limits can be enforced:

DefaultTime: Default time limit
MaxNodes: Maximum number of nodes per job
MinNodes: Minimum number of nodes per job
MaxCPUsPerNode: Maximum number of CPUs job can be allocated on any node
MaxMemPerCPU/Node: Maximum memory job can be allocated on any CPU or node
MaxTime: Maximum length of time user's job can run

ULHPC Slurm QoS

Quality of Service or QoS is used to constrain or modify the characteristics that a job can have. This could come in the form of specifying a QoS to request for a longer run time or a high priority queue for a given job.

To select a given QoS with a Slurm command, use the --qos=<QoS> option (available onlt in long form):


srun|sbatch|salloc|sinfo|squeue... [--partition=<partition>] --qos=<QoS> [...]
The default QoS of your jobs depends on your account and affiliation. Normally, the --qos=<QoS> directive does not need to be set for most jobs

We favor in general cross-partition QoS, mainly tied to priority level (low  urgent). A special preemptible QoS exists for best-effort jobs and is named besteffort.

Available QoS's

QoS (partition)	Prio	GrpTRES	MaxTresPJ	MaxJobPU	MaxWall
besteffort (*)	1			300	50-00:00:00
low (*)	10			4	
normal (*)	100			50	
long (*)	100	node=24	node=2	4	14-00:00:00
debug (interactive)	150	node=50		10	
high (*)	200			50	
urgent (*)	1000			100	
wide (*)	100		node=160	10	0-02:00:00
List QoS Limits

Use the sqos utility function to list the existing QOS limits.

List current ULHPC QOS limits with sqos

$ sqos
# sacctmgr show qos  format="name%20,preempt,priority,GrpTRES,MaxTresPerJob,MaxJobsPerUser,MaxWall,flags"
                Name    Preempt   Priority       GrpTRES       MaxTRES MaxJobsPU     MaxWall                Flags
-------------------- ---------- ---------- ------------- ------------- --------- ----------- --------------------
              normal besteffort        100                                   100                      DenyOnLimit
          besteffort                     1                                   300 50-00:00:00            NoReserve
                 low besteffort         10                                     4                      DenyOnLimit
                high besteffort        200                                    50                      DenyOnLimit
              urgent besteffort       1000                                   100                      DenyOnLimit
               debug besteffort        150       node=50                      10                      DenyOnLimit
                long besteffort        100       node=24        node=2         4 14-00:00:00 DenyOnLimit,Partiti+
               admin besteffort       1000                                                            DenyOnLimit
                wide besteffort        100                    node=160        10    02:00:00          DenyOnLimit
What are the possible limits set on ULHPC QoS?
At the QoS level, the following elements are composed to define the resource limits for our QoS:

Limits on Trackable RESources TRES - a resource (nodes, cpus, gpus, etc.) tracked for usage or used to enforce limits against, in particular:
GrpTRES: The total count of TRES able to be used at any given time from all jobs running from the QoS; if this limit is reached new jobs will be queued but only allowed to run after resources have been relinquished from this group.
MaxTresPerJob: the maximum size in TRES any given job can have from the QoS.
MaxJobsPerUser: The maximum number of jobs a user can have running at a given time.
MaxWall[DurationPerJob]: The maximum wall clock time any individual job can run for in the given QoS.
As explained in the Limits section, there are basically three layers of Slurm limits, from least to most priority:

None
Partitions
Account associations: Root/Cluster -> Account (ascending the hierarchy) -> User
Job/Partition QoS

Slurm Account Hierarchy

The ULHPC resources can be reserved and allocated for the execution of jobs scheduled on the platform thanks to a Resource and Job Management Systems (RJMS) - Slurm in practice. This tool is configured to collect accounting information for every job and job step executed -- see SchedMD accounting documentation.

ULHPC account (login) vs. Slurm [meta-]account
ULHPC Account Tree Hierarchy

Every user job runs under a group account, granting access to specific QOS levels. Such an account is unique within the account hierarchy. Accounting records are organized as a hierarchical tree according to 3 layers (slurm accounts) as depicted in the below figure (click to enlarge). At the leaf hierarchy stands the End user <login> from the IPA IdM database, bringing a total of 4 levels.



Level	Account Type	Description	Example
L1	meta-account	Top-level structure / organizations	UL, CRP, Externals, Projects, Trainings
L2	meta-account	Organizational Unit (Faculty, ICs, External partner, Funding program...)	FSTM, LCSB, LIST...
L3	meta-account	Principal investigators (PIs), project, courses/lectures	<firstname>.<lastname>, <acronym>, <course>
L4	login	End-users (staff, student): your ULHPC/IPA login	yourlogin
Extracting your association tree
By default, you will be able to see only the account hierarchy you belongs too through the association(s) set with your login. You can extract it with:


$ sacctmgr show association where parent=root format="account,user%20,Share,QOS%50" withsubaccounts
   Account                 User     Share                                                QOS
---------------------- -------- ----------- --------------------------------------------------
                 <top>            <L1share>                   besteffort,debug,long,low,normal
             <orgunit>            <L2share>                   besteffort,debug,long,low,normal
<firstname>.<lastname>            <L3share>                   besteffort,debug,long,low,normal
<firstname>.<lastname>  <login>   <L4share>                   besteffort,debug,long,low,normal
(Admins) Extract the full hierarchy
Default account vs. multiple associations
A given user <login> can be associated to multiple accounts, but have a single DefaultAccount (a meta-account at L3 level reflecting your line manager (Format: <firstname>.<lastname>).

To get information about your account information in the hierarchy, use the custom acct helper function, typically as acct $USER.

Get ULHPC account information with acct <login>

# /!\ ADAPT <login> accordingly
$ acct <login>
# sacctmgr show user where name="<login>" format=user,account%20,DefaultAccount%20,share,qos%50 withassoc
     User                Account             Def Acct       Share                                     QOS
  ------- ----------------------- ----------------------  ------- ---------------------------------------
  <login>         project_<name1> <firstname>.<lastname>        1        besteffort,debug,long,low,normal
  <login>         project_<name2> <firstname>.<lastname>        1   besteffort,debug,high,long,low,normal
  <login>  <firstname>.<lastname> <firstname>.<lastname>        1        besteffort,debug,long,low,normal
# ==> <login> Default account: <firstname>.<lastname>
In the above example, the user <login> is associated to 3 meta-accounts at the L3 level of the hierarchy (his PI <firstname>.<lastname> and two projects account), each granting access to potentially different QOS. The account used upon job submission can be set with the -A <account> option. With the above example:

$ sbatch|srun|... [...]                     # Use default account: <firstname>.<lastname>
$ sbatch|srun|... -A project_<name1> [...]  # Use account project_<name1>
$ sbatch|srun|... -A project_<name2> --qos high [...] # Use account project_<name2>, granting access to high QOS
$ sbatch|srun|... -A anotheraccount [...]   # Error: non-existing association between <login> and anotheraccount
To list all associations for a given user or meta-account, use the sassoc helper function:


# /!\ ADAPT <login> accordingly
$ sassoc <login>
You may use more classically the sacctmgr show [...] command:
User information: sacctmgr show user where name=<login> [withassoc] (use the withassoc attribute to list all associations).
Default account: sacctmgr show user where name="<login>" format=DefaultAccount -P -n
Get the parent account: sacctmgr show account where name=ulhpc format=Org -n -P
To get the current association tree: add withsubaccounts to see ALL sub accounts


# L1,L2 or L3 account /!\ ADAPT <name> accordingly
sacctmgr show association tree where accounts=<name> format=account,share
# End user (L4)
sacctmgr show association where users=$USER  format=account,User,share,Partition,QOS
No association, no job!
Impact on FairSharing and Job Accounting

Every node in the above-mentioned tree hierarchy is associated with a weight defining its Raw Share in the FairSharing mechanism in place. Different rules are applied to define these weights/shares depending on the level in the hierarchy:

L1 (Organizational Unit): arbitrary shares to dedicate at least 85% of the platform to serve UL needs and projects
L2: function of the out-degree of the tree nodes, reflecting also the past year funding
L3: a function reflecting the budget contribution of the PI/project (normalized on a per-month basis) for the year in exercise.
L4 (ULHPC/IPA login): efficiency score, giving incentives for a more efficient usage of the platform.
More details are given on this page.

Default vs. Project accounts

Default account associations are defined as follows:

For UL staff or external partners: your direct Line Manager firstname.lastname within the institution (Faculty, IC, Company) you belong too.
For students: the lecture/course they are registered too
Guest student/training accounts are associated to the Students meta-account.
In addition, your user account (ULHPC login) may be associated to other meta-accounts such as projects or specific training events.

To establish job accounting against these extra specific accounts, use:


{sbatch|srun} -A project_<name> [...]
For more details, see Project accounts.

Job Status and Reason Codes

The squeue command details a variety of information on an active job’s status with state and reason codes. Job state codes describe a job’s current state in queue (e.g. pending, completed). Job reason codes describe the reason why the job is in its current state.

The following tables outline a variety of job state and reason codes you may encounter when using squeue to check on your jobs.

Job State Codes

Status	Code	Explaination
CANCELLED	CA	The job was explicitly cancelled by the user or system administrator.
COMPLETED	CD	The job has completed successfully.
COMPLETING	CG	The job is finishing but some processes are still active.
DEADLINE	DL	The job terminated on deadline
FAILED	F	The job terminated with a non-zero exit code and failed to execute.
NODE_FAIL	NF	The job terminated due to failure of one or more allocated nodes
OUT_OF_MEMORY	OOM	The Job experienced an out of memory error.
PENDING	PD	The job is waiting for resource allocation. It will eventually run.
PREEMPTED	PR	The job was terminated because of preemption by another job.
RUNNING	R	The job currently is allocated to a node and is running.
SUSPENDED	S	A running job has been stopped with its cores released to other jobs.
STOPPED	ST	A running job has been stopped with its cores retained.
TIMEOUT	TO	Job terminated upon reaching its time limit.
A full list of these Job State codes can be found in squeue documentation. or sacct documentation.

Job Reason Codes

Reason Code	Explaination
Priority	One or more higher priority jobs is in queue for running. Your job will eventually run.
Dependency	This job is waiting for a dependent job to complete and will run afterwards.
Resources	The job is waiting for resources to become available and will eventually run.
InvalidAccount	The job’s account is invalid. Cancel the job and rerun with correct account.
InvaldQoS	The job’s QoS is invalid. Cancel the job and rerun with correct account.
QOSGrpCpuLimit	All CPUs assigned to your job’s specified QoS are in use; job will run eventually.
QOSGrpMaxJobsLimit	Maximum number of jobs for your job’s QoS have been met; job will run eventually.
QOSGrpNodeLimit	All nodes assigned to your job’s specified QoS are in use; job will run eventually.
PartitionCpuLimit	All CPUs assigned to your job’s specified partition are in use; job will run eventually.
PartitionMaxJobsLimit	Maximum number of jobs for your job’s partition have been met; job will run eventually.
PartitionNodeLimit	All nodes assigned to your job’s specified partition are in use; job will run eventually.
AssociationCpuLimit	All CPUs assigned to your job’s specified association are in use; job will run eventually.
AssociationMaxJobsLimit	Maximum number of jobs for your job’s association have been met; job will run eventually.
AssociationNodeLimit	All nodes assigned to your job’s specified association are in use; job will run eventually.
A full list of these Job Reason Codes can be found in Slurm’s documentation.

Running Job Statistics Metrics

The sstat command allows users to easily pull up status information about their currently running jobs. This includes information about CPU usage, task information, node information, resident set size (RSS), and virtual memory (VM). We can invoke the sstat command as such:


# /!\ ADAPT <jobid> accordingly
$ sstat --jobs=<jobid>
By default, sstat will pull up significantly more information than what would be needed in the commands default output. To remedy this, we can use the --format flag to choose what we want in our output. A chart of some these variables are listed in the table below:

Variable	Description
avecpu	Average CPU time of all tasks in job.
averss	Average resident set size of all tasks.
avevmsize	Average virtual memory of all tasks in a job.
jobid	The id of the Job.
maxrss	Maximum number of bytes read by all tasks in the job.
maxvsize	Maximum number of bytes written by all tasks in the job.
ntasks	Number of tasks in a job.
For an example, let's print out a job's average job id, cpu time, max rss, and number of tasks. We can do this by typing out the command:


# /!\ ADAPT <jobid> accordingly
sstat --jobs=<jobid> --format=jobid,cputime,maxrss,ntasks
A full list of variables that specify data handled by sstat can be found with the --helpformat flag or by visiting the slurm page on sstat.

Past Job Statistics Metrics

You can use the custom susage function in /etc/profile.d/slurm.sh to collect statistics information.


$ susage -h
Usage: susage [-m] [-Y] [-S YYYY-MM-DD] [-E YYYT-MM-DD]
  For a specific user (if accounting rights granted):    susage [...] -u <user>
  For a specific account (if accounting rights granted): susage [...] -A <account>
Display past job usage summary
But by default, you should use the sacct command allows users to pull up status information about past jobs. This command is very similar to sstat, but is used on jobs that have been previously run on the system instead of currently running jobs.


# /!\ ADAPT <jobid> accordingly
$ sacct [-X] --jobs=<jobid> [--format=metric1,...]
# OR, for a user, eventually between a Start and End date
$ sacct [-X] -u $USER  [-S YYYY-MM-DD] [-E YYYY-MM-DD] [--format=metric1,...]
# OR, for an account - ADAPT <account> accordingly
$ sacct [-X] -A <account> [--format=metric1,...]
Use -X to aggregate the statistics relevant to the job allocation itself, not taking job steps into consideration.

The main metrics code you may be interested to review are listed below.

Variable	Description
account	Account the job ran under.
avecpu	Average CPU time of all tasks in job.
averss	Average resident set size of all tasks in the job.
cputime	Formatted (Elapsed time * CPU) count used by a job or step.
elapsed	Jobs elapsed time formated as DD-HH:MM:SS.
exitcode	The exit code returned by the job script or salloc.
jobid	The id of the Job.
jobname	The name of the Job.
maxdiskread	Maximum number of bytes read by all tasks in the job.
maxdiskwrite	Maximum number of bytes written by all tasks in the job.
maxrss	Maximum resident set size of all tasks in the job.
ncpus	Amount of allocated CPUs.
nnodes	The number of nodes used in a job.
ntasks	Number of tasks in a job.
priority	Slurm priority.
qos	Quality of service.
reqcpu	Required number of CPUs
reqmem	Required amount of memory for a job.
reqtres	Required Trackable RESources (TRES)
user	Userna
A full list of variables that specify data handled by sacct can be found with the --helpformat flag or by visiting the slurm page on sacct.

Fairsharing and Job Accounting

Resources:
Slurm Priority, Fairshare and Fair Tree (PDF)
SchedMD Slurm documentation: Multifactor Priority Plugin
Fair tree algorithm, FAS RC docs, Official sshare documentation
Fairshare allows past resource utilization information to be taken into account into job feasibility and priority decisions to ensure a fair allocation of the computational resources between the all ULHPC users. A difference with a equal scheduling is illustrated in the side picture (source).


Essentially fairshare is a way of ensuring that users get their appropriate portion of a system. Sadly this term is also used confusingly for different parts of fairshare listed below, so for the sake of clarity, the following terms will be used:

[Raw] Share: portion of the system users have been granted
[Raw] Usage: amount of the system users have actually used so far
The fairshare score is the value the system calculates based on the usage and the share (see below)
Priority: the priority that users are assigned based off of their fairshare score.
Demystifying Fairshare
While fairshare may seem complex and confusing, it is actually quite logical once you think about it. The scheduler needs some way to adjudicate who gets what resources when different groups on the cluster have been granted different resources and shares for various reasons (see Account Hierarchy).

In order to serve the great variety of groups and needs on the cluster, a method of fairly adjudicating job priority is required. This is the goal of Fairshare. Fairshare allows those users who have not fully used their resource grant to get higher priority for their jobs on the cluster, while making sure that those groups that have used more than their resource grant do not overuse the cluster.

The ULHPC supercomputers are a limited shared resource, and Fairshare ensures everyone gets a fair opportunity to use it regardless of how big or small the group is.

FairTree Algorithm

There exists several fairsharing algorithms implemented in Slurm:

Classic Fairshare
Depth-Oblivious Fair-share
Fair Tree (now implemented on ULHPC since Oct 2020)
What is Fair Tree?
The Fair Tree algorithm prioritizes users such that if accounts A and B are siblings and A has a higher fairshare factor than B, then all children of A will have higher fairshare factors than all children of B.

This is done through a rooted plane tree (PDF), also known as a rooted ordered tree, which is logically created then sorted by fairshare with the highest fairshare values on the left. The tree is then visited in a depth-first traversal way. Users are ranked in pre-order as they are found. The ranking is used to create the final fairshare factor for the user. Fair Tree Traversal Illustrated - initial post

Some of the benefits include:

All users from a higher priority account receive a higher fair share factor than all users from a lower priority account.
Users are sorted and ranked to prevent errors due to precision loss. Ties are allowed.
Account coordinators cannot accidentally harm the priority of their users relative to users in other accounts.
Users are extremely unlikely to have exactly the same fairshare factor as another user due to loss of precision in calculations.
New jobs are immediately assigned a priority.
 Overview of Fair Tree for End Users  Level Fairshare Calculation

Shares

On ULHPC facilities, each user is associated by default to a meta-account reflecting its direct Line Manager within the institution (Faculty, IC, Company) you belong too -- see ULHPC Account Hierarchy. You may have other account associations (typically toward projects accounts, granting access to different QOS for instance), and each accounts have Shares granted to them. These Shares determine how much of the cluster that group/account has been granted. Users when they run are charged back for their runs against the account used upon job submission -- you can use sbatch|srun|... -A <account> [...] to change that account.

 ULHPC Usage Charging Policy

Different rules are applied to define these weights/shares depending on the level in the hierarchy:

L1 (Organizational Unit): arbitrary shares to dedicate at least 85% of the platform to serve UL needs and projects
L2: function of the out-degree of the tree nodes, reflecting also the past year funding
L3: a function reflecting the budget contribution of the PI/project (normalized on a per-month basis) for the year in exercise.
L4 (ULHPC/IPA login): efficiency score, giving incentives for a more efficient usage of the platform.
Fair Share Factor

The Fairshare score is the value Slurm calculates based off of user's usage reflecting the difference between the portion of the computing resource that has been promised (share) and the amount of resources that has been consumed. It thus influences the order in which a user's queued jobs are scheduled to run based on the portion of the computing resources they have been allocated and the resources their jobs have already consumed.

In practice, Slurm's fair-share factor is a floating point number between 0.0 and 1.0 that reflects the shares of a computing resource that a user has been allocated and the amount of computing resources the user's jobs have consumed.

The higher the value, the higher is the placement in the queue of jobs waiting to be scheduled.
Reciprocally, the more resources the users is consuming, the lower the fair share factor will be which will result in lower priorities.
ulhpcshare helper

Listing the ULHPC shares: ulhpcshare helper
sshare can be used to view the fair share factors and corresponding promised and actual usage for all users. However, you are encouraged to use the ulhpcshare helper function:


# your current shares and fair-share factors among your associations
ulhpcshare
# as above, but for user '<login>'
ulhpcshare -u <login>
# as above, but for account '<account>'
ulhpcshare -A <account>
The column that contains the actual factor is called "FairShare".
Official sshare utility

ulhpcshare is a wrapper around the official sshare utility. You can quickly see your score with


$ sshare  [-A <account>] [-l] [--format=Account,User,RawShares,NormShares,EffectvUsage,LevelFS,FairShare]
It will show the Level Fairshare value as Level FS. The field shows the value for each association, thus allowing users to see the results of the fairshare calculation at each level.
Note: Unlike the Effective Usage, the Norm Usage is not used by Fair Tree but is still displayed in this case.

Slurm Parameter Definitions

In this part some of the set slurm parameters are explained which are used to set up the Fair Tree Fairshare Algorithm. For a more detailed explanation please consult the official documentation

PriorityCalcPeriod=HH:MM::SS: frequency in minutes that job half-life decay and Fair Tree calculations are performed.
PriorityDecayHalfLife=[number of days]-[number of hours]: the time, of which the resource consumption is taken into account for the Fairshare Algorithm, can be set by this.
PriorityMaxAge=[number of days]-[number of hours]: the maximal queueing time which counts for the priority calculation. Note that queueing times above are possible but do not contribute to the priority factor.
A quick way to check the currently running configuration is:


scontrol show config | grep -i priority
Trackable RESources (TRES) Billing Weights

Slurm saves accounting data for every job or job step that the user submits. On ULHPC facilities, Slurm Trackable RESources (TRES) is enabled to allow for the scheduler to charge back users for how much they have used of different features (i.e. not only CPU) on the cluster -- see Job Accounting and Billing. This is important as the usage of the cluster factors into the Fairshare calculation.

As explained in the ULHPC Usage Charging Policy, we set TRES for CPU, GPU, and Memory usage according to weights defined as follows:

Weight	Description
	Normalized relative performance of CPU processor core (ref.: skylake 73.6 GFlops/core)
	Inverse of the average available memory size per core
	Weight per GPU accelerator
Each partition has its own weights (combined into TRESBillingWeight) you can check with


# /!\ ADAPT <partition> accordingly
scontrol show partition <partition>
FAQ

Q: My user fairshare is low, what can I do?

We have introduced an efficiency score evaluated on a regular basis (by default, every year) to measure how efficient you use the computational resources of the University according to several measures for completed jobs:

How efficient you were to estimate the walltime of your jobs (Average Walltime Accuracy)
How CPU/Memory efficient were your completed jobs (see seff)
Without entering into the details, we combine these metrics to compute an unique score value  and you obtain a grade: A (very good), B, C, or D (very bad) which can increase your user share.

Q: My account fairshare is low, what can I do?

There are several things that can be done when your fairshare is low:

Do not run jobs: Fairshare recovers via two routes.
The first is via your group not running any jobs and letting others use the resource. That allows your fractional usage to decrease which in turn increases your fairshare score.
The second is via the half-life we apply to fairshare which ages out old usage over time. Both of these method require not action but inaction on the part of your group. Thus to recover your fairshare simply stop running jobs until your fairshare reaches the level you desire. Be warned this could take several weeks to accomplish depending on your current usage.
Be patient, as a corollary to the previous point. Even if your fairshare is low, your job gains priority by sitting the queue (see Job Priority) The longer it sits the higher priority it gains. So even if you have very low fairshare your jobs will eventually run, it just may take several days to accomplish.
Leverage Backfill: Slurm runs in two scheduling loops.
The first loop is the main loop which simply looks at the top of the priority chain for the partition and tries to schedule that job. It will schedule jobs until it hits a job it cannot schedule and then it restarts the loop.
The second loop is the backfill loop. This loop looks through jobs further down in the queue and asks can I schedule this job now and not interfere with the start time of the top priority job. Think of it as the scheduler playing giant game of three dimensional tetris, where the dimensions are number of cores, amount of memory, and amount of time. If your job will fit in the gaps that the scheduler has it will put your job in that spot even if it is low priority. This requires you to be very accurate in specifying the core, memory, and time usage (typically below ) of your job. The better constrained your job is the more likely the scheduler is to fit you in to these gaps**. The seff utility is a great way of figuring out your job performance.
Plan: Better planning and knowledge of your historic usage can help you better budget your time on the cluster. Our clusters are not infinite resources. You have been allocated a slice of the cluster, thus it is best to budget your usage so that you can run high priority jobs when you need to.
HPC Budget contribution: If your group has persistent high demand that cannot be met with your current allocation, serious consideration should be given to contributing to the ULHPC budget line.
This should be done for funded research projects - see HPC Resource Allocations for Research Project
This can be done by each individual PI, Dean or IC director In all cases, any contribution on year Y grants additional shares for the group starting year Y+1. We apply a consistent (complex) function taking into account depreciation of the investment. Contact us (by mail or by a ticket for more details.)

ULHPC Job Prioritization Factors

The ULHPC Slurm configuration rely on the Multifactor Priority Plugin and the Fair tree algorithm to preform Fairsharing among the users1

Priority Factors

There are several factors enabled on ULHPC supercomputers that influence job priority:

Age: length of time a job has been waiting (PD state) in the queue
Fairshare: difference between the portion of the computing resource that has been promised and the amount of resources that has been consumed - see Fairsharing.
Partition: factor associated with each node partition, for instance to privilege interactive over batch partitions
QOS A factor associated with each Quality Of Service (low  urgent)
The job's priority at any given time will be a weighted sum of all the factors that have been enabled. Job priority can be expressed as:


Job_priority =
    PriorityWeightAge       * age_factor +
    PriorityWeightFairshare * fair-share_factor+
    PriorityWeightPartition * partition_factor +
    PriorityWeightQOS       * QOS_factor +
    - nice_factor
All of the factors in this formula are floating point numbers that range from 0.0 to 1.0. The weights are unsigned, 32 bit integers, you can get with:


$ sprio -w
# OR, from slurm.conf
$ scontrol show config | grep -i PriorityWeight
You can use the sprio to view the factors that comprise a job's scheduling priority and were your (pending) jobs stands in the priority queue.
sprio Utility usage
Show current weights


sprio -w
List pending jobs, sorted by jobid

sprio [-n]     # OR: sp
List pending jobs, sorted by priority

sprio [-n] -S+Y
sprio [-n] | sort -k 3 -n
sprio [-n] -l | sort -k 4 -n
Getting the priority given to a job can be done either with squeue:


# /!\ ADAPT <jobid> accordingly
squeue -o %Q -j <jobid>
Backfill Scheduling

Backfill is a mechanism by which lower priority jobs can start earlier to fill the idle slots provided they are finished before the next high priority jobs is expected to start based on resource availability.

If your job is sufficiently small, it can be backfilled and scheduled in the shadow of a larger, higher-priority job

For more details, see official Slurm documentation

All users from a higher priority account receive a higher fair share factor than all users from a lower priority account ↩
Last update: March 13, 2025

Job Accounting and Billing

 Usage Charging Policy

Billing rates

Trackable RESources (TRES) Billing Weights

The above policy is in practice implemented through the Slurm Trackable RESources (TRES) and remains an important factor for the Fairsharing score calculation.

As explained in the ULHPC Usage Charging Policy, we set TRES for CPU, GPU, and Memory usage according to weights defined as follows:

Weight	Description
	Normalized relative performance of CPU processor core (ref.: skylake 73.6 GFlops/core)
	Inverse of the average available memory size per core
	Weight per GPU accelerator
Each partition has its own weights (combined into TRESBillingWeight) you can check with


# /!\ ADAPT <partition> accordingly
scontrol show partition <partition>

Interactive Jobs

The interactive (floating) partition (exclusively associated to the debug QOS) is to be used for code development, testing, and debugging.

Important
Production runs are not permitted in interactive jobs. User accounts are subject to suspension if they are determined to be using the interactive partition and the debug QOS for production computing. In particular, interactive job "chaining" is not allowed. Chaining is defined as using a batch script to submit another batch script.

You can access the different node classes available using the -C <class> flag (see also List of Slurm features on ULHPC nodes), or (better) through the custom helper functions defined for each category of nodes, i.e. si, si-gpu or si-bigmem:

Regular Dual-CPU node

### Quick interative job for the default time
$ si
# salloc -p interactive --qos debug -C batch

### Explicitly ask for a skylake node
$ si -C skylake
# salloc -p interactive --qos debug -C batch -C skylake

### Use 1 full node for 28 tasks
$ si --ntasks-per-node 28
# salloc -p interactive --qos debug -C batch --ntasks-per-node 28

### interactive job for 2 hours
$ si -t 02:00:00
# salloc -p interactive --qos debug -C batch -t 02:00:00

### interactive job on 2 nodes, 1 multithreaded tasks per node
$ si -N 2 --ntasks-per-node 1 -c 4
si -N 2 --ntasks-per-node 1 -c 4
# salloc -p interactive --qos debug -C batch -N 2 --ntasks-per-node 1 -c 4
GPU node
Large-Memory node
If you prefer to rely on the regular srun, the below table proposes the equivalent commands run by the helper scripts si*:

Node Type	Slurm command
regular
si [...]	salloc -p interactive --qos debug -C batch [...]
salloc -p interactive --qos debug -C batch,broadwell [...]
salloc -p interactive --qos debug -C batch,skylake [...]
gpu
si-gpu [...]	salloc -p interactive --qos debug -C gpu [-C volta[32]] -G 1 [...]
bigmem
si-bigmem [...]	salloc -p interactive --qos debug -C bigmem [...]
Impact of Interactive jobs implementation over a floating partition
We have recently changed the way interactive jobs are served. Since the interactive partition is no longer dedicated but floating above the other partitions, there is NO guarantee to have an interactive job running if the surrounding partition (batch, gpu or bigmem) is full.

However, the backfill scheduling in place together with the partition priority set ensure that interactive jobs will be first served upon resource release.

Regular Jobs

Node Type	Slurm command
regular	sbatch [-A <project>] -p batch [--qos {high,urgent}] [-C {broadwell,skylake}] [...]
gpu	sbatch [-A <project>] -p gpu [--qos {high,urgent}] [-C volta[32]] -G 1 [...]
bigmem	sbatch [-A <project>] -p bigmem [--qos {high,urgent}] [...]
 Main Slurm commands  Resource Allocation guide

sbatch [...] /path/to/launcher

sbatch is used to submit a batch launcher script for later execution, corresponding to batch/passive submission mode. The script will typically contain one or more srun commands to launch parallel tasks. Upon submission with sbatch, Slurm will:

allocate resources (nodes, tasks, partition, constraints, etc.)
runs a single copy of the batch script on the first allocated node
in particular, if you depend on other scripts, ensure you have refer to them with the complete path toward them.
When you submit the job, Slurm responds with the job's ID, which will be used to identify this job in reports from Slurm.


# /!\ ADAPT path to launcher accordingly
$ sbatch <path/to/launcher>.sh
Submitted batch job 864933
Job Submission Option

There are several useful environment variables set be Slurm within an allocated job. The most important ones are detailed in the below table which summarizes the main job submission options offered with {sbatch | srun | salloc} [...]:

Command-line option	Description	Example
-N <N>	<N> Nodes request	-N 2
--ntasks-per-node=<n>	<n> Tasks-per-node request	--ntasks-per-node=28
--ntasks-per-socket=<s>	<s> Tasks-per-socket request	--ntasks-per-socket=14
-c <c>	<c> Cores-per-task request (multithreading)	-c 1
--mem=<m>GB	<m>GB memory per node request	--mem 0
-t [DD-]HH[:MM:SS]>	Walltime request	-t 4:00:00
-G <gpu>	<gpu> GPU(s) request	-G 4
-C <feature>	Feature request (broadwell,skylake...)	-C skylake
-p <partition>	Specify job partition/queue	
--qos <qos>	Specify job qos	
-A <account>	Specify account	
-J <name>	Job name	-J MyApp
-d <specification>	Job dependency	-d singleton
--mail-user=<email>	Specify email address	
--mail-type=<type>	Notify user by email when certain event types occur.	--mail-type=END,FAIL
At a minimum a job submission script must include number of nodes, time, type of partition and nodes (resource allocation constraint and features), and quality of service (QOS). If a script does not specify any of these options then a default may be applied. The full list of directives is documented in the man pages for the sbatch command (see. man sbatch).

Within a job, you aim at running a certain number of tasks, and Slurm allow for a fine-grain control of the resource allocation that must be satisfied for each task.

Beware of Slurm terminology in Multicore Architecture!

Slurm Node = Physical node, specified with -N <#nodes>
Advice: always explicit number of expected number of tasks per node using --ntasks-per-node <n>. This way you control the node footprint of your job.
Slurm Socket = Physical Socket/CPU/Processor
Advice: if possible, explicit also the number of expected number of tasks per socket (processor) using --ntasks-per-socket <s>.
relations between <s> and <n> must be aligned with the physical NUMA characteristics of the node.
For instance on aion nodes, <n> = 8*<s>
For instance on iris regular nodes, <n>=2*<s> when on iris bigmem nodes, <n>=4*<s>.
(the most confusing): Slurm CPU = Physical CORE
use -c <#threads> to specify the number of cores reserved per task.
Hyper-Threading (HT) Technology is disabled on all ULHPC compute nodes. In particular:
assume #cores = #threads, thus when using -c <threads>, you can safely set

OMP_NUM_THREADS=${SLURM_CPUS_PER_TASK:-1} # Default to 1 if SLURM_CPUS_PER_TASK not set
to automatically abstract from the job context
you have interest to match the physical NUMA characteristics of the compute node you're running at (Ex: target 16 threads per socket on Aion nodes (as there are 8 virtual sockets per nodes, 14 threads per socket on Iris regular nodes).
The total number of tasks defined in a given job is stored in the $SLURM_NTASKS environment variable.

The --cpus-per-task option of srun in Slurm 23.11 and later
In the latest versions of Slurm srun inherits the --cpus-per-task value requested by salloc or sbatch by reading the value of SLURM_CPUS_PER_TASK, as for any other option. This behavior may differ from some older versions where special handling was required to propagate the --cpus-per-task option to srun.

In case you would like to launch multiple programs in a single allocation/batch script, divide the resources accordingly by requesting resources with srun when launching the process, for instance:


srun --cpus-per-task <some of the SLURM_CPUS_PER_TASK> --ntasks <some of the SLURM_NTASKS> [...] <program>
We encourage you to always explicitly specify upon resource allocation the number of tasks you want per node/socket (--ntasks-per-node <n> --ntasks-per-socket <s>), to easily scale on multiple nodes with -N <N>. Adapt the number of threads and the settings to match the physical NUMA characteristics of the nodes

Aion
16 cores per socket and 8 (virtual) sockets (CPUs) per aion node.

{sbatch|srun|salloc|si} [-N <N>] --ntasks-per-node <8n> --ntasks-per-socket <n> -c <thread>
Total: <N><n> tasks, each on <thread> threads
Ensure <n><thread>= 16
Ex: -N 2 --ntasks-per-node 32 --ntasks-per-socket 4 -c 4 (Total: 64 tasks)
Iris (default Dual-CPU)
Iris (Bigmem)
Careful Monitoring of your Jobs

Bug
DON'T LEAVE your jobs running WITHOUT monitoring them and ensure they are not abusing of the computational resources allocated for you!!!

 ULHPC Tutorial / Getting Started

You will find below several ways to monitor the effective usage of the resources allocated (for running jobs) as well as the general efficiency (Average Walltime Accuracy, CPU/Memory efficiency etc.) for past jobs.

Joining/monitoring running jobs

sjoin

At any moment of time, you can join a running job using the custom helper functions sjoin in another terminal (or another screen/tmux tab/window). The format is as follows:


sjoin <jobid> [-w <node>]    # Use <tab> to automatically complete <jobid> among your jobs
Using sjoin to htop your processes

# check your running job
(access)$> sq
# squeue -u $(whoami)
   JOBID PARTIT       QOS                 NAME       USER NODE  CPUS ST         TIME    TIME_LEFT PRIORITY NODELIST(REASON)
 2171206  [...]
# Connect to your running job, identified by its Job ID
(access)$> sjoin 2171206     # /!\ ADAPT <jobid> accordingly, use <TAB> to have it autocatically completed
# Equivalent of: srun --jobid 2171206 --gres=gpu:0 --pty bash -i
(node)$> htop # view of all processes
#               F5: tree view
#               u <name>: filter by process of <name>
#               q: quit
On the [impossibility] to monitor passive GPU jobs over sjoin
If you use sjoin to join a GPU job, you WON'T be able to see the allocated GPU activity with nvidia-smi and all the monitoring tools provided by NVidia. The reason is that currently, there is no way to perform an over-allocation of a Slurm Generic Resource (GRES) as our GPU cards, that means you can't create (e.g. with sjoin or srun --jobid [...]) job steps with access to GPUs which are bound to another step. To keep sjoin working with gres job, you MUST add "--gres=none"

You can use a direct connection with ssh <node> or clush -w @job:<jobid> for that (see below) but be aware that confined context is NOT maintained that way and that you will see the GPU processes on all 4 GPU cards.

ClusterShell

Danger
Only for VERY Advanced users!!!. You should know what you are doing when using ClusterShell as you can mistakenly generate a huge amount of remote commands across the cluster which, while they will likely fail, still induce an unexpected load that may disturb the system.

ClusterShell is a useful Python package for executing arbitrary commands across multiple hosts. On the ULHPC clusters, it provides a relatively simple way for you to run commands on nodes your jobs are running on, and collect the results.

Info
You can only ssh to, and therefore run clush on, nodes where you have active/running jobs.

nodeset

The nodeset command enables the easy manipulation of node sets, as well as node groups, at the command line level. It uses sinfo underneath but has slightly different syntax. You can use it to ask about node states and nodes your job is running on.

The nice difference is you can ask for folded (e.g. iris-[075,078,091-092]) or expanded (e.g. iris-075 iris-078 iris-091 iris-092) forms of the node lists.

Command	description
nodeset -L[LL]	List all groups available
nodeset -c [...]	show number of nodes in nodeset(s)
nodeset -e [...]	expand nodeset(s) to separate nodes
nodeset -f [...]	fold nodeset(s) (or separate nodes) into one nodeset
Nodeset expansion and folding
Exclusion / intersection of nodeset
The groups useful to you that we have configured are @user, @job and @state.

List available groups

$ nodeset -LLL
# convenient partition groups
@batch  iris-[001-168] 168
@bigmem iris-[187-190] 4
@gpu    iris-[169-186,191-196] 24
@interactive iris-[001-196] 196
# conveniente state groups
@state:allocated [...]
@state:idle      [...]
@state:mixed     [...]
@state:reserved  [...]
# your individual jobs
@job:2252046 iris-076 1
@job:2252050 iris-[191-196] 6
# all the jobs under your username
@user:svarrette iris-[076,191-196] 7
User group
Job group
State group
clush

clush can run commands on multiple nodes at once for instance to monitor you jobs. It uses the node grouping syntax from [nodeset]((https://clustershell.readthedocs.io/en/latest/tools/nodeset.html) to allow you to run commands on those nodes.

clush uses ssh to connect to each of these nodes. You can use the -b option to gather output from nodes with same output into the same lines. Leaving this out will report on each node separately.

Option	Description
-b	gathering output (as when piping to dshbak -c)
-w <nodelist>	specify remote hosts, incl. node groups with @group special syntax
-g <group>	similar to -w @<group>, restrict commands to the hosts group <group>
--diff	show differences between common outputs
Monitor CPU usage
Show %cpu, memory usage, and command for all nodes running any of your jobs.


clush -bw @user:$USER ps -u$USER -o%cpu,rss,cmd
As above, but only for the nodes reserved with your job <jobid>

clush -bw @job:<jobid> ps -u$USER -o%cpu,rss,cmd
Monitor GPU usage
pestat: CPU/Mem usage report

We have deployed the (excellent) Slurm tool pestat (Processor Element status) of Ole Holm Nielsen that you can use to quickly check the CPU/Memory usage of your jobs. Information deserving investigation (too low/high CPU or Memory usage compared to allocation) will be flagged in Red or Magenta


pestat [-p <partition>] [-G] [-f]
pestat output (official sample output)
General Guidelines

As mentionned before, always check your node activity with at least htop on the all allocated nodes to ensure you use them as expected. Several cases might apply to your job workflow:

Single Node, single core
You are dealing with an embarrasingly parallel job campaign and this approach is bad and overload the scheduler unnecessarily. You will also quickly cross the limits set in terms of maximum number of jobs. You must aggregate multiples tasks within a single job to exploit fully a complete node. In particular, you MUST consider using GNU Parallel and our generic GNU launcher launcher.parallel.sh.

 ULHPC Tutorial / HPC Management of Embarrassingly Parallel Jobs

Single Node, multi-core
Multi-node
Monitoring past jobs efficiency

Walltime estimation and Job efficiency
By default, none of the regular jobs you submit can exceed a walltime of 2 days (2-00:00:00). You have a strong interest to estimate accurately the walltime of your jobs. While it is not always possible, or quite hard to guess at the beginning of a given job campaign where you'll probably ask for the maximum walltime possible, you should look back as your historical usage for the past efficiency and elapsed time of your previously completed jobs using seff or susage utilities. Update the time constraint [#SBATCH] -t [...] of your jobs accordingly. There are two immediate benefits for you:

Short jobs are scheduled faster, and may even be elligible for backfilling
You will be more likely elligible for a raw share upgrade of your user account -- see Fairsharing
The below utilities will help you track the CPU/Memory efficiency (seff) or the Average Walltime Accuracy (susage, sacct) of your past jobs

seff

Use seff to double check a past job CPU/Memory efficiency. Below examples should be self-speaking:

Good CPU Eff.

$ seff 2171749
Job ID: 2171749
Cluster: iris
User/Group: <login>/clusterusers
State: COMPLETED (exit code 0)
Nodes: 1
Cores per node: 28
CPU Utilized: 41-01:38:14
CPU Efficiency: 99.64% of 41-05:09:44 core-walltime
Job Wall-clock time: 1-11:19:38
Memory Utilized: 2.73 GB
Memory Efficiency: 2.43% of 112.00 GB
Good Memory Eff.
Good CPU and Memory Eff.
[Very] Bad efficiency
Note however that demonstrating a CPU good efficiency with seff may not be enough! You may still induce an abnormal load on the reserved nodes if you spawn more processes than allowed by the Slurm reservation. To avoid that, always try to prefix your executions with srun within your launchers. See also Specific Resource Allocations.

susage

Use susage to check your past jobs walltime accuracy (Timelimit vs. Elapsed)


$ susage -h
Usage: susage [-m] [-Y] [-S YYYY-MM-DD] [-E YYYT-MM-DD]
  For a specific user (if accounting rights granted):    susage [...] -u <user>
  For a specific account (if accounting rights granted): susage [...] -A <account>
Display past job usage summary
In all cases, if you are confident that your jobs will last more than 2 days while efficiently using the allocated resources, you can use --qos long QOS. Be aware that special restrictions applies for this kind of jobs.

ULHPC GPU Nodes

Each GPU node provided as part of the gpu partition feature 4x Nvidia V100 SXM2 (with either 16G or 32G memory) interconnected by the NVLink 2.0 architecture

NVlink was designed as an alternative solution to PCI Express with higher bandwidth and additional features (e.g., shared memory) specifically designed to be compatible with Nvidia's own GPU ISA for multi-GPU systems -- see wikichip article.



Because of the hardware organization, you MUST follow the below recommendations:

Do not run jobs on GPU nodes if you have no use of GPU accelerators!, i.e. if you are not using any of the software compiled against the {foss,intel}cuda toolchain.
Avoid using more than 4 GPUs, ideally within the same node.
Dedicated ¼ of the available CPU cores for the management of each GPU card reserved.
Thus your typical GPU launcher would match the AI/DL launcher example:


#!/usr/bin/bash --login

#SBATCH --job-name=gpu_example
#SBATCH --output=%x-%j.out
#SBATCH --error=%x-%j.out

### Request one GPU tasks for 4 hours - dedicate 1/4 of available cores for its management
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=1
#SBATCH --cpus-per-task=7
#SBATCH --gpus-per-task=1
#SBATCH --time=0-04:00:00

### Submit to the `gpu` partition of Iris
#SBATCH --parition=gpu
#SBATCH --qos=normal

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }

module purge || print_error_and_exit "No 'module' command available"
module load numlib/cuDNN   # Example using the cuDNN module

[...]
Interactive jobs
In the UL HPC systems you can use the si-gpu, a wrapper for the salloc command, that allocates interactive job in a GPU node with sensible default options.

Long Jobs

If you are confident that your jobs will last more than 2 days while efficiently using the allocated resources, you can use --qos long QOS.


sbatch -p {batch | gpu | bigmem} --qos long [...]
Following EuroHPC/PRACE Recommendations, the long QOS allow for an extended Max walltime (MaxWall) set to 14 days.

Node Type	Slurm command
regular	sbatch [-A <project>] -p batch --qos long [-C {broadwell,skylake}] [...]
gpu	sbatch [-A <project>] -p gpu --qos long [-C volta[32]] -G 1 [...]
bigmem	sbatch [-A <project>] -p bigmem --qos long [...]
Important
Be aware however that special restrictions applies for this kind of jobs.

There is a limit to the maximum number of concurrent nodes involved in long jobs (see sqos for details).
No more than 4 long jobs per User (MaxJobsPU) are allowed, using no more than 2 nodes per jobs.

Best-effort Jobs

Node Type	Slurm command
regular	sbatch [-A <project>] -p batch --qos besteffort [-C {broadwell,skylake}] [...]
gpu	sbatch [-A <project>] -p gpu --qos besteffort [-C volta[32]] -G 1 [...]
bigmem	sbatch [-A <project>] -p bigmem --qos besteffort [...]
Best-effort (preemptible) jobs allow an efficient usage of the platform by filling available computing nodes until regular jobs are submitted.


sbatch -p {batch | gpu | bigmem} --qos besteffort [...]
What means job preemption?
The besteffort QOS have less constraints than the other QOS (for instance, you can submit more jobs etc. )

As a general rule users should ensure that they track successful completion of best-effort jobs (which may be interrupted by other jobs at any time) and use them in combination with mechanisms such as Checkpoint-Restart that allow applications to stop and resume safely.

Slurm Launcher Examples

 ULHPC Tutorial / Getting Started  ULHPC Tutorial / OpenMP/MPI

When setting your default #SBATCH directive, always keep in mind your expected default resource allocation that would permit to submit your launchers

without options sbatch <launcher> (you will be glad in a couple of month not to have to remember the options you need to pass) and
try to stick to a single node (to avoid to accidentally induce a huge submission).
Resource allocation Guidelines

General guidelines
Always try to align resource specifications for your jobs with physical characteristics. Always prefer the use of --ntasks-per-{node,socket} over -n when defining your tasks allocation request to automatically scale appropriately upon multi-nodes submission with for instance sbatch -N 2 <launcher>. Launcher template:


#!/bin/bash -l # <--- DO NOT FORGET '-l' to facilitate further access to ULHPC modules
#SBATCH -p <partition>                     #SBATCH -p <partition>
#SBATCH -N 1                               #SBATCH -N 1
#SBATCH --ntasks-per-node=<n>              #SBATCH --ntasks-per-node <#sockets * s>
#SBATCH -c <thread>                        #SBATCH --ntasks-per-socket <s>
                                           #SBATCH -c <thread>
This would define by default a total of <n> (left) or <s> (right) tasks per node, each on <thread> threads. You MUST ensure that either:
<n><thread> matches the number of cores avaiable on the target computing node (left), or
<n>=<s>, and <s><thread> matches the number of cores per socket available on the target computing node (right).
See Specific Resource Allocation

Node (type)	#Nodes	#Socket / #Cores	RAM [GB]	Features
aion-[0001-0354]	354	8 / 128	256	batch,epyc
iris-[001-108]	108	2 / 28	128	batch,broadwell
iris-[109-168]	60	2 / 28	128	batch,skylake
iris-[169-186] (GPU)	18	2 / 28	768	gpu,skylake,volta
iris-[191-196] (GPU)	6	2 / 28	768	gpu,skylake,volta32
iris-[187-190]
(Large-Memory)	4	4 / 112	3072	bigmem,skylake
Aion (default Dual-CPU)
16 cores per socket and 8 (virtual) sockets (CPUs) per aion node. Examples:


#SBATCH -p batch                 #SBATCH -p batch                #SBATCH -p batch
#SBATCH -N 1                     #SBATCH -N 1                    #SBATCH -N 1
#SBATCH --ntasks-per-node=128    #SBATCH --ntasks-per-node 16    #SBATCH --ntasks-per-node 8
#SBATCH --ntasks-per-socket 16   #SBATCH --ntasks-per-socket 2   #SBATCH --ntasks-per-socket 1
#SBATCH -c 1                     #SBATCH -c 8                    #SBATCH -c 16
Iris (default Dual-CPU)
Iris (GPU)
Iris (Large-Memory)
Basic Slurm Launcher Examples

Single core task
1 task per job (Note: prefer GNU Parallel in that case - see below)

#!/bin/bash -l                # <--- DO NOT FORGET '-l'
### Request a single task using one core on one node for 5 minutes in the batch queue
#SBATCH -N 1
#SBATCH --ntasks-per-node=1
#SBATCH -c 1
#SBATCH --time=0-00:05:00
#SBATCH -p batch

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }
# Safeguard for NOT running this launcher on access/login nodes
module purge || print_error_and_exit "No 'module' command"
# List modules required for execution of the task
module load <...>
# [...]
Multiple Single core tasks
Multithreaded parallel tasks
Embarrassingly Parallel Tasks


For many users, the reason to consider (or being encouraged) to offload their computing executions on a (remote) HPC or Cloud facility is tied to the limits reached by their computing devices (laptop or workstation). It is generally motivated by time constraints

"My computations take several hours/days to complete. On an HPC, it will last a few minutes, no?"

or search-space explorations:

"I need to check my application against a huge number of input pieces (files) - it worked on a few of them locally but takes ages for a single check. How to proceed on HPC?"

In most of the cases, your favorite Java application or R/python (custom) development scripts, iterated again over multiple input conditions, are inherently SERIAL: they are able to use only one core when executed. You thus deal with what is often call a Bag of (independent) tasks, also referred to as embarrassingly parallel tasks.

In this case, you MUST NOT overload the job scheduler with a large number of small (single-core) jobs. Instead, you should use GNU Parallel which permits the effective management of such tasks in a way that optimize both the resource allocation and the completion time.

More specifically, GNU Parallel is a tool for executing tasks in parallel, typically on a single machine. When coupled with the Slurm command srun, parallel becomes a powerful way of distributing a set of tasks amongst a number of workers. This is particularly useful when the number of tasks is significantly larger than the number of available workers (i.e. $SLURM_NTASKS), and each tasks is independent of the others.

 ULHPC Tutorial: GNU Parallel launcher for Embarrassingly Parallel Jobs

Luckily, we have prepared a generic GNU Parallel launcher that should be straight forward to adapt to your own workflow following our tutorial:

Create a dedicated script run_<task> responsible to run your java/R/Python tasks while taking as argument the parameter of each run. You can inspire from run_stressme for instance.
test it in interactive
rename the generic launcher launcher.parallel.sh to launcher_<task>.sh,
enable #SBATCH --dependency singleton
set the jobname
change TASK to point to the absolute path to run_<task> script
set TASKLISTFILE to point to a files with the parameters to pass to your script for each task
adapt eventually the #SBATCH --ntasks-per-node [...] and #SBATCH -c [...] to match your needs AND the hardware configs of a single node (28 cores on iris, 128 cores on Aion) -- see guidelines
test a batch run -- stick to a single node to take the best out of one full node.
Serial Task script Launcher

Serial Killer (Generic template)

#!/bin/bash -l     # <--- DO NOT FORGET '-l'
#SBATCH -N 1
#SBATCH --ntasks-per-node=1
#SBATCH -c 1
#SBATCH --time=0-01:00:00
#SBATCH -p batch

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }
module purge || print_error_and_exit "No 'module' command"
# C/C++: module load toolchain/intel # OR: module load toolchain/foss
# Java:  module load lang/Java/1.8
# Ruby/Perl/Rust...:  module load lang/{Ruby,Perl,Rust...}
# /!\ ADAPT TASK variable accordingly - absolute path to the (serial) task to be executed
TASK=${TASK:=${HOME}/bin/app.exe}
OPTS=$*

srun ${TASK} ${OPTS}
Serial Python
R
Matlab
Specialized BigData/GPU launchers

BigData/[Large-]memory single-core tasks

#!/bin/bash -l
### Request one sequential task requiring half the memory of a regular iris node for 1 day
#SBATCH -J MyLargeMemorySequentialJob       # Job name
#SBATCH --mail-user=Your.Email@Address.lu   # mail me ...
#SBATCH --mail-type=end,fail                # ... upon end or failure
#SBATCH -N 1
#SBATCH --ntasks-per-node=1
#SBATCH -c 1
#SBATCH --mem=64GB         # if above 112GB: consider bigmem partition (USE WITH CAUTION)
#SBATCH --time=1-00:00:00
#SBATCH -p batch           # if above 112GB: consider bigmem partition (USE WITH CAUTION)

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }
module purge || print_error_and_exit "No 'module' command"
module load <...>
# [...]
AI/DL task tasks

#!/bin/bash -l
### Request one GPU tasks for 4 hours - dedicate 1/4 of available cores for its management
#SBATCH -N 1
#SBATCH --ntasks-per-node=1
#SBATCH -c 7
#SBATCH -G 1
#SBATCH --time=04:00:00
#SBATCH -p gpu

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }
module purge || print_error_and_exit "No 'module' command"
module load <...>    # USE apps compiled against the {foss,intel}cuda toolchain !
# Ex: 
# module load numlib/cuDNN

# This should report a single GPU (over 4 available per gpu node)
nvidia-smi
# [...]
srun [...]
pthreads/OpenMP Launcher

Always set OMP_NUM_THREADS to match ${SLURM_CPUS_PER_TASK:-1}
You MUST enforce the use of -c <threads> in your launcher to ensure the variable $SLURM_CPUS_PER_TASK exists within your launcher scripts. This is the appropriate value to set for OMP_NUM_THREAD, with default to 1 as extra safely which can be obtained with the following affectation:


export OMP_NUM_THREADS=${SLURM_CPUS_PER_TASK:-1}
Aion (default Dual-CPU)
Single node, threaded (pthreads/OpenMP) application launcher

#!/bin/bash -l
# Single node, threaded (pthreads/OpenMP) application launcher, using all 128 cores of an aion cluster node
#SBATCH -N 1
#SBATCH --ntasks-per-node=1
#SBATCH -c 128
#SBATCH --time=0-01:00:00
#SBATCH -p batch

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }
module purge || print_error_and_exit "No 'module' command"
module load toolchain/foss

export OMP_NUM_THREADS=${SLURM_CPUS_PER_TASK:-1}
OPTS=$*

srun /path/to/your/threaded.app ${OPTS}
Iris (default Dual-CPU)
MPI

Intel MPI Launchers

Official Slurm guide for Intel MPI

Aion (default Dual-CPU)
Multi-node parallel application IntelMPI launcher

#!/bin/bash -l
# Multi-node parallel application IntelMPI launcher, using 256 MPI processes

#SBATCH -N 2
#SBATCH --ntasks-per-node 128    # MPI processes per node
#SBATCH -c 1
#SBATCH --time=0-01:00:00
#SBATCH -p batch

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }
module purge || print_error_and_exit "No 'module' command"
module load toolchain/intel
OPTS=$*

srun -n $SLURM_NTASKS /path/to/your/intel-toolchain-compiled-application ${OPTS}
Recall to use si-bigmem to request an interactive job when testing your script.
Iris (default Dual-CPU)
You may want to use PMIx as MPI initiator -- use srun --mpi=list to list the available implementations (default: pmi2), and srun --mpi=pmix[_v3] [...] to use PMIx.

OpenMPI Slurm Launchers

Official Slurm guide for Open MPI

Aion (default Dual-CPU)
Multi-node parallel application OpenMPI launcher

#!/bin/bash -l
# Multi-node parallel application OpenMPI launcher, using 256 MPI processes

#SBATCH -N 2
#SBATCH --ntasks-per-node 128    # MPI processes per node
#SBATCH -c 1
#SBATCH --time=0-01:00:00
#SBATCH -p batch

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }
module purge || print_error_and_exit "No 'module' command"
module load toolchain/foss
module load mpi/OpenMPI
OPTS=$*

srun -n $SLURM_NTASKS /path/to/your/foss-toolchain-openMPIcompiled-application ${OPTS}
Iris (default Dual-CPU)
Hybrid Intel MPI+OpenMP Launcher

Aion (default Dual-CPU)
Multi-node hybrid parallel application IntelMPI/OpenMP launcher

#!/bin/bash -l
# Multi-node hybrid application IntelMPI+OpenMP launcher, using 16 threads per socket(CPU) on 2 nodes (256 cores):

#SBATCH -N 2
#SBATCH --ntasks-per-node   8    # MPI processes per node
#SBATCH --ntasks-per-socket 1    # MPI processes per (virtual) processor
#SBATCH -c 16
#SBATCH --time=0-01:00:00
#SBATCH -p batch

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }
module purge || print_error_and_exit "No 'module' command"
module load toolchain/intel
export OMP_NUM_THREADS=${SLURM_CPUS_PER_TASK:-1}
OPTS=$*

srun -n $SLURM_NTASKS /path/to/your/parallel-hybrid-app ${OPTS}
Iris (default Dual-CPU)
Hybrid OpenMPI+OpenMP Launcher

Aion (default Dual-CPU)
Multi-node hybrid parallel application OpenMPI/OpenMP launcher

#!/bin/bash -l
# Multi-node hybrid application OpenMPI+OpenMP launcher, using 16 threads per socket(CPU) on 2 nodes (256 cores):

#SBATCH -N 2
#SBATCH --ntasks-per-node   8    # MPI processes per node
#SBATCH --ntasks-per-socket 1    # MPI processes per processor
#SBATCH -c 16
#SBATCH --time=0-01:00:00
#SBATCH -p batch

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }
module purge || print_error_and_exit "No 'module' command"
module load toolchain/foss
module load mpi/OpenMPI
export OMP_NUM_THREADS=${SLURM_CPUS_PER_TASK:-1}
OPTS=$*

srun -n $SLURM_NTASKS /path/to/your/parallel-hybrid-app ${OPTS}

Jupyter Notebook


JupyterLab is a flexible, popular literate-computing web application for creating notebooks containing code, equations, visualization, and text. Notebooks are documents that contain both computer code and rich text elements (paragraphs, equations, figures, widgets, links). They are human-readable documents containing analysis descriptions and results but are also executable data analytics artifacts. Notebooks are associated with kernels, processes that actually execute code. Notebooks can be shared or converted into static HTML documents. They are a powerful tool for reproducible research and teaching.

Install Jupyter

While JupyterLab runs code in Jupyter notebooks for many programming languages, Python is a requirement (Python 3.3 or greater, or Python 2.7) for installing the JupyterLab. New users may wish to install JupyterLab in a Conda environment. Hereafter, the pip package manager will be used to install JupyterLab.

We strongly recommend to use the Python module provided by the ULHPC and installing jupyter inside a Python virtual environment after upgrading pip.


$ si
$ module load lang/Python #Loading default Python
$ python -m venv ~/environments/jupyter_env
$ source ~/environments/jupyter_env/bin/activate
$ python -m pip install --upgrade pip
$ python -m pip install jupyterlab
Warning
Modules are not allowed on the access servers. To test interactively Singularity, remember to ask for an interactive job first using for instance the si tool.

Once JupyterLab is installed along with , you can start to configure your installation setting the environment variables corresponding to your needs:

JUPYTER_CONFIG_DIR: Set this environment variable to use a particular directory, other than the default, for Jupyter config files
JUPYTER_PATH: Set this environment variable to provide extra directories for the data search path. JUPYTER_PATH should contain a series of directories, separated by os.pathsep(; on Windows, : on Unix). Directories given in JUPYTER_PATH are searched before other locations. This is used in addition to other entries, rather than replacing any
JUPYTER_DATA_DIR: Set this environment variable to use a particular directory, other than the default, as the user data directory
JUPYTER_RUNTIME_DIR: Set this to override where Jupyter stores runtime files
IPYTHONDIR: If set, this environment variable should be the path to a directory, which IPython will use for user data. IPython will create it if it does not exist.
JupyterLab is now installed and ready.

Installing the classic Notebook
Providing access to kernels of other environments

JupyterLab makes sure that a default IPython kernel is available, with the environment (and the Python version) with which the lab was created. Other environments can export a kernel to a JupyterLab instance, allowing the instance to launch interactive session inside environments others from the environment where JupyterLab is installed.

You can setup kernels with different environments on the same notebook. Create the environment with the Python version and the packages you require, and then register the kernel in any environment with Jupyter (lab or classic notebook) installed. For instance, if we have installed Jupyter in ~/environments/jupyter_env:


source ~/environments/other_python_venv/bin/activate
python -m pip install ipykernel
python -m ipykernel install --prefix=${HOME}/environments/jupyter_env --name other_python_env --display-name "Other Python env"
deactivate
Then all kernels and their associated environment can be started from the same Jupyter instance in the ~/environments/jupyter_env Python venv.
You can also use the flag --user instead of --prefix to install the kernel in the default system location available to all Jupyter environments for a user.

Kernels for Conda environments

If you would like to install a kernel in a Conda environment, install the ipykernel from the conda-forge channel. For instance,


micromamba install --name conda_env conda-forge::ipykernel
micromamba run --name conda_env python -m ipykernel install --prefix=${HOME}/environments/jupyter_env --name other_python_env --display-name "Other Python env"
will make your conda environment, conda_env, available in the kernel launched from the ~/environments/jupyter_env Python venv.
Starting a Jupyter Notebook

Jupyter notebooks must be started as slurm jobs. The following script is a template for Jupyter submission scripts that will rarely need modifications. Most often you will need to modify the session duration (--time SBATCH option).

Slurm Launcher script for Jupyter Notebook

#!/usr/bin/bash --login
#SBATCH --job-name=Jupyter
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=1
#SBATCH --cpus-per-task=2   # Change accordingly, note that ~1.7GB RAM is proivisioned per core
#SBATCH --partition=batch
#SBATCH --qos=normal
#SBATCH --output=%x_%j.out  # Print messages to 'Jupyter_<job id>.out
#SBATCH --error=%x_%j.err   # Print debug messages to 'Jupyter_<job id>.err
#SBATCH --time=0-01:00:00   # Change maximum allowable jupyter server uptime here

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }
module purge || print_error_and_exit "No 'module' command"

# Load the default Python 3 module
module load lang/Python
source "${HOME}/environments/jupyter_env/bin/activate"

declare loopback_device="127.0.0.1"
declare port="8888"
declare connection_instructions="connection_instructions.log"

jupyter lab --ip=${loopback_device} --port=${port} --no-browser &
declare lab_pid=$!

# Add connection instruction
echo "# Connection instructions" > "${connection_instructions}"
echo "" >> "${connection_instructions}"
echo "To access the jupyter notebook execute on your personal machine:" >> "${connection_instructions}"
echo "ssh -J ${USER}@access-${ULHPC_CLUSTER}.uni.lu:8022 -L ${port}:${loopback_device}:${port} ${USER}@$(hostname -i)" >> "${connection_instructions}"
echo "" >> "${connection_instructions}"
echo "To access the jupyter notebook if you have setup a special key (e.g ulhpc_id_ed25519) to connect to cluster nodes execute on your personal machine:" >> "${connection_instructions}"
echo "ssh -i ~/.ssh/hpc_id_ed25519 -J ${USER}@access-${ULHPC_CLUSTER}.uni.lu:8022 -L ${port}:${loopback_device}:${port} ${USER}@$(hostname -i)" >> "${connection_instructions}"
echo "" >> "${connection_instructions}"
echo "Then navigate to:" >> "${connection_instructions}"

# Wait for the server to start
sleep 2s
# Wait and check that the landing page is available
curl \
    --connect-timeout 10 \
    --retry 5 \
    --retry-delay 1 \
    --retry-connrefused \
    --silent --show-error --fail \
    "http://${loopback_device}:${port}" > /dev/null
# Note down the URL
jupyter lab list 2>&1 \
    | grep -E '\?token=' \
    | awk 'BEGIN {FS="::"} {gsub("[ \t]*","",$1); print $1}' \
    | sed -r 's/([0-9]{1,3}\.){3}[0-9]{1,3}/127\.0\.0\.1/g' \
    >> "${connection_instructions}"

# Save some debug information
echo -e '\n===\n'

echo "AVAILABLE LABS"
echo ""
jupyter lab list

echo -e '\n===\n'

echo "CONFIGURATION PATHS"
echo ""
jupyter --paths

echo -e '\n===\n'

echo "KERNEL SPECIFICATIONS"
echo ""
jupyter kernelspec list

# Wait for the user to terminate the lab
wait ${lab_pid}
Once your job is running (see Joining/monitoring running jobs), you can combine

ssh forwarding, and
an ssh jump through the login node,
to connect to the notebook from your laptop. Open a terminal on your laptop and copy-paste the ssh command contained in the file connection_instructions.log, and then navigate to the webpage link provided.

Example content of connection_instructions.log

> cat connection_instructions.log
# Connection instructions

To access the jupyter notebook execute on your personal machine:
ssh -J gkafanas@access-aion.uni.lu:8022 -L 8888:127.0.0.1:8888 gkafanas@172.21.12.29

To access the jupyter notebook if you have setup a special key (e.g ulhpc_id_ed25519) to connect to cluster nodes execute on your personal machine:
ssh -i ~/.ssh/ulhpc_id_ed25519 -J gkafanas@access-aion.uni.lu:8022 -L 8888:127.0.0.1:8888 gkafanas@172.21.12.29

Then navigate to:
http://127.0.0.1:8888/?token=b7cf9d71d5c89627250e9a73d4f28cb649cd3d9ff662e7e2
As the instructions suggest, you access the jupyter lab server in the compute node by calling


ssh -J gkafanas@access-aion.uni.lu:8022 -L 8888:127.0.0.1:8888 gkafanas@172.21.12.29
an SSH command that
opens a connection to your allocated cluster node jumping through the login node (-J gkafanas@access-aion.uni.lu:8022 gkafanas@172.21.12.29), and
exports the port to the jupyter server in the local machine (-L 8888:127.0.0.1:8888).
Then, open the connection to the browser in your local machine by following the given link:


http://127.0.0.1:8888/?token=b7cf9d71d5c89627250e9a73d4f28cb649cd3d9ff662e7e2
The link provides the access token, so you should be able to login without a password.

Warning
Do not forget to click on the quit button when finished to stop the Jupyter server and release the resources. Note that in the last line of the submission script the job waits for your Jupyter service to finish.

If you encounter any issues, have a look in the debug output in Jupyter_<job id>.err. Generic information about the setup of your system is printed in Jupyter_<job id>.out.

Typical content of Jupyter_<job id>.err
Typical content of Jupyter_<job id>.err
Password protected access

You can also set a password when launching the jupyter lab as detailed in the Jupyter official documentation. In that case, simply direct you browser to the URL http://127.0.0.1:8888/ and provide your password. You can see bellow an example of the login page.

Typical content of a password protected login page

Supported Software Sets

You can find here the list of the supported software modules that you can use on the ULHPC facility.

Full list of software (in alphabetical order)
Software list by ULHPC software set release:
2019b (legacy)
2020b (prod)
Software list by category*:
Biology
CFD/Finite element modelling
Chemistry
Compilers
Data processing
Debugging
Development
Weather modelling
Programming Languages
Libraries
Mathematics
MPI
Numerical libraries
Performance measurements
Physics
System-level software
Toolchains (software stacks)
Utilities
Visualisation

Full List (alphabetical order)

Software	Versions	Swsets	Architectures	Clusters	Category	Description
ABAQUS	2018, 2021	2019b, 2020b	broadwell, skylake, epyc	iris, aion	CFD/Finite element modelling	Finite Element Analysis software for modeling, visualization and best-in-class implicit and explicit dynamics FEA.
ABINIT	9.4.1	2020b	epyc	aion	Chemistry	ABINIT is a package whose main program allows one to find the total energy, charge density and electronic structure of systems made of electrons and nuclei (molecules and periodic solids) within Density Functional Theory (DFT), using pseudopotentials and a planewave or wavelet basis.
ABySS	2.2.5	2020b	broadwell, epyc, skylake	aion, iris	Biology	Assembly By Short Sequences - a de novo, parallel, paired-end sequence assembler
ACTC	1.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	ACTC converts independent triangles into triangle strips or fans.
ANSYS	19.4, 21.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	ANSYS simulation software enables organizations to confidently predict how their products will operate in the real world. We believe that every product is a promise of something greater.
AOCC	3.1.0	2020b	epyc	aion	Compilers	AMD Optimized C/C++ & Fortran compilers (AOCC) based on LLVM 12.0
ASE	3.19.0, 3.20.1, 3.21.1	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Chemistry	ASE is a python package providing an open source Atomic Simulation Environment in the Python scripting language. From version 3.20.1 we also include the ase-ext package, it contains optional reimplementations in C of functions in ASE. ASE uses it automatically when installed.
ATK	2.34.1, 2.36.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	ATK provides the set of accessibility interfaces that are implemented by other toolkits and applications. Using the ATK interfaces, accessibility tools have full access to view and control running applications.
Advisor	2019_update5	2019b	broadwell, skylake	iris	Performance measurements	Vectorization Optimization and Thread Prototyping - Vectorize & thread code or performance “dies” - Easy workflow + data + tips = faster code faster - Prioritize, Prototype & Predict performance gain
Anaconda3	2020.02, 2020.11	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Programming Languages	Built to complement the rich, open source Python community, the Anaconda platform provides an enterprise-ready data analytics platform that empowers companies to adopt a modern open data science analytics architecture.
ArmForge	20.0.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	The industry standard development package for C, C++ and Fortran high performance code on Linux. Forge is designed to handle the complex software projects - including parallel, multiprocess and multithreaded code. Arm Forge combines an industry-leading debugger, Arm DDT, and an out-of-the-box-ready profiler, Arm MAP.
ArmReports	20.0.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	Arm Performance Reports - a low-overhead tool that produces one-page text and HTML reports summarizing and characterizing both scalar and MPI application performance. Arm Performance Reports runs transparently on optimized production-ready codes by adding a single command to your scripts, and provides the most effective way to characterize and understand the performance of HPC application runs.
Armadillo	10.5.3, 9.900.1	2020b, 2019b	broadwell, epyc, skylake	aion, iris	Numerical libraries	Armadillo is an open-source C++ linear algebra library (matrix maths) aiming towards a good balance between speed and ease of use. Integer, floating point and complex numbers are supported, as well as a subset of trigonometric and statistics functions.
Arrow	0.16.0	2019b	broadwell, skylake	iris	Data processing	Apache Arrow (incl. PyArrow Python bindings)), a cross-language development platform for in-memory data.
Aspera-CLI	3.9.1, 3.9.6	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	IBM Aspera Command-Line Interface (the Aspera CLI) is a collection of Aspera tools for performing high-speed, secure data transfers from the command line. The Aspera CLI is for users and organizations who want to automate their transfer workflows.
Autoconf	2.69	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	Autoconf is an extensible package of M4 macros that produce shell scripts to automatically configure software source code packages. These scripts can adapt the packages to many kinds of UNIX-like systems without manual user intervention. Autoconf creates a configuration script for a package from a template file that lists the operating system features that the package can use, in the form of M4 macro calls.
Automake	1.16.1, 1.16.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	Automake: GNU Standards-compliant Makefile generator
Autotools	20180311, 20200321	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	This bundle collect the standard GNU build tools: Autoconf, Automake and libtool
BEDTools	2.29.2, 2.30.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	BEDTools: a powerful toolset for genome arithmetic. The BEDTools utilities allow one to address common genomics tasks such as finding feature overlaps and computing coverage. The utilities are largely based on four widely-used file formats: BED, GFF/GTF, VCF, and SAM/BAM.
BLAST+	2.11.0, 2.9.0	2020b, 2019b	broadwell, epyc, skylake	aion, iris	Biology	Basic Local Alignment Search Tool, or BLAST, is an algorithm for comparing primary biological sequence information, such as the amino-acid sequences of different proteins or the nucleotides of DNA sequences.
BWA	0.7.17	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	Burrows-Wheeler Aligner (BWA) is an efficient program that aligns relatively short nucleotide sequences against a long reference sequence such as the human genome.
BamTools	2.5.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	BamTools provides both a programmer's API and an end-user's toolkit for handling BAM files.
Bazel	0.26.1, 0.29.1, 3.7.2	2019b, 2020b	gpu, broadwell, skylake, epyc	iris, aion	Development	Bazel is a build tool that builds code quickly and reliably. It is used to build the majority of Google's software.
BioPerl	1.7.2, 1.7.8	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	Bioperl is the product of a community effort to produce Perl code which is useful in biology. Examples include Sequence objects, Alignment objects and database searching objects.
Bison	3.3.2, 3.5.3, 3.7.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Bison is a general-purpose parser generator that converts an annotated context-free grammar into a deterministic LR or generalized LR (GLR) parser employing LALR(1) parser tables.
Boost.Python	1.74.0	2020b	broadwell, epyc, skylake	aion, iris	Libraries	Boost.Python is a C++ library which enables seamless interoperability between C++ and the Python programming language.
Boost	1.71.0, 1.74.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	Boost provides free peer-reviewed portable C++ source libraries.
Bowtie2	2.3.5.1, 2.4.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters, and particularly good at aligning to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an FM Index to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 GB. Bowtie 2 supports gapped, local, and paired-end alignment modes.
CGAL	4.14.1, 5.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Numerical libraries	The goal of the CGAL Open Source Project is to provide easy access to efficient and reliable geometric algorithms in the form of a C++ library.
CMake	3.15.3, 3.18.4, 3.20.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	CMake, the cross-platform, open-source build system. CMake is a family of tools designed to build, test and package software.
CPLEX	12.10	2019b	broadwell, skylake	iris	Mathematics	IBM ILOG CPLEX Optimizer's mathematical programming technology enables analytical decision support for improving efficiency, reducing costs, and increasing profitability.
CRYSTAL	17	2019b	broadwell, skylake	iris	Chemistry	The CRYSTAL package performs ab initio calculations of the ground state energy, energy gradient, electronic wave function and properties of periodic systems. Hartree-Fock or Kohn- Sham Hamiltonians (that adopt an Exchange-Correlation potential following the postulates of Density-Functional Theory) can be used.
CUDA	10.1.243, 11.1.1	2019b, 2020b	gpu	iris	System-level software	CUDA (formerly Compute Unified Device Architecture) is a parallel computing platform and programming model created by NVIDIA and implemented by the graphics processing units (GPUs) that they produce. CUDA gives developers access to the virtual instruction set and memory of the parallel computational elements in CUDA GPUs.
CUDAcore	11.1.1	2020b	gpu	iris	System-level software	CUDA (formerly Compute Unified Device Architecture) is a parallel computing platform and programming model created by NVIDIA and implemented by the graphics processing units (GPUs) that they produce. CUDA gives developers access to the virtual instruction set and memory of the parallel computational elements in CUDA GPUs.
Check	0.15.2	2020b	gpu	iris	Libraries	Check is a unit testing framework for C. It features a simple interface for defining unit tests, putting little in the way of the developer. Tests are run in a separate address space, so both assertion failures and code errors that cause segmentation faults or other signals can be caught. Test results are reportable in the following: Subunit, TAP, XML, and a generic logging format.
Clang	11.0.1, 9.0.1	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Compilers	C, C++, Objective-C compiler, based on LLVM. Does not include C++ standard library -- use libstdc++ from GCC.
CubeGUI	4.4.4	2019b	broadwell, skylake	iris	Performance measurements	Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube graphical report explorer.
CubeLib	4.4.4	2019b	broadwell, skylake	iris	Performance measurements	Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube general purpose C++ library component and command-line tools.
CubeWriter	4.4.3	2019b	broadwell, skylake	iris	Performance measurements	Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube high-performance C writer library component.
DB	18.1.32, 18.1.40	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Utilities	Berkeley DB enables the development of custom data management solutions, without the overhead traditionally associated with such custom projects.
DB_File	1.855	2020b	broadwell, epyc, skylake	aion, iris	Data processing	Perl5 access to Berkeley DB version 1.x.
DBus	1.13.12, 1.13.18	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	D-Bus is a message bus system, a simple way for applications to talk to one another. In addition to interprocess communication, D-Bus helps coordinate process lifecycle; it makes it simple and reliable to code a "single instance" application or daemon, and to launch applications and daemons on demand when their services are needed.
DMTCP	2.5.2	2019b	broadwell, skylake	iris	Utilities	DMTCP is a tool to transparently checkpoint the state of multiple simultaneous applications, including multi-threaded and distributed applications. It operates directly on the user binary executable, without any Linux kernel modules or other kernel modifications.
Dakota	6.11.0, 6.15.0	2019b, 2020b	broadwell, skylake	iris	Mathematics	The Dakota project delivers both state-of-the-art research and robust, usable software for optimization and UQ. Broadly, the Dakota software's advanced parametric analyses enable design exploration, model calibration, risk analysis, and quantification of margins and uncertainty with computational models."
Doxygen	1.8.16, 1.8.20	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	Doxygen is a documentation system for C++, C, Java, Objective-C, Python, IDL (Corba and Microsoft flavors), Fortran, VHDL, PHP, C#, and to some extent D.
ELPA	2019.11.001, 2020.11.001	2019b, 2020b	broadwell, epyc, skylake	iris, aion	Mathematics	Eigenvalue SoLvers for Petaflop-Applications .
EasyBuild	4.3.0, 4.3.3, 4.4.1, 4.4.2, 4.5.4	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	EasyBuild is a software build and installation framework written in Python that allows you to install software in a structured, repeatable and robust way.
Eigen	3.3.7, 3.3.8, 3.4.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Mathematics	Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.
Elk	6.3.2, 7.0.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Physics	An all-electron full-potential linearised augmented-plane wave (FP-LAPW) code with many advanced features. Written originally at Karl-Franzens-Universität Graz as a milestone of the EXCITING EU Research and Training Network, the code is designed to be as simple as possible so that new developments in the field of density functional theory (DFT) can be added quickly and reliably.
FDS	6.7.1, 6.7.6	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Physics	Fire Dynamics Simulator (FDS) is a large-eddy simulation (LES) code for low-speed flows, with an emphasis on smoke and heat transport from fires.
FFTW	3.3.8	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Numerical libraries	FFTW is a C subroutine library for computing the discrete Fourier transform (DFT) in one or more dimensions, of arbitrary input size, and of both real and complex data.
FFmpeg	4.2.1, 4.3.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	A complete, cross-platform solution to record, convert and stream audio and video.
FLAC	1.3.3	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	FLAC stands for Free Lossless Audio Codec, an audio format similar to MP3, but lossless, meaning that audio is compressed in FLAC without any loss in quality.
FLTK	1.3.5	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	FLTK is a cross-platform C++ GUI toolkit for UNIX/Linux (X11), Microsoft Windows, and MacOS X. FLTK provides modern GUI functionality without the bloat and supports 3D graphics via OpenGL and its built-in GLUT emulation.
FastQC	0.11.9	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	FastQC is a quality control application for high throughput sequence data. It reads in sequence data in a variety of formats and can either provide an interactive application to review the results of several different QC checks, or create an HTML based report which can be integrated into a pipeline.
Flask	1.1.2	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Flask is a lightweight WSGI web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications. This module includes the Flask extensions: Flask-Cors
Flink	1.11.2	2020b	broadwell, epyc, skylake	aion, iris	Development	Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams. Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.
FreeImage	3.18.0	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	FreeImage is an Open Source library project for developers who would like to support popular graphics image formats like PNG, BMP, JPEG, TIFF and others as needed by today's multimedia applications. FreeImage is easy to use, fast, multithreading safe.
FriBidi	1.0.10, 1.0.5	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	The Free Implementation of the Unicode Bidirectional Algorithm.
GCC	10.2.0, 8.3.0	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Compilers	The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Java, and Ada, as well as libraries for these languages (libstdc++, libgcj,...).
GCCcore	10.2.0, 8.3.0	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Compilers	The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Java, and Ada, as well as libraries for these languages (libstdc++, libgcj,...).
GDAL	3.0.2, 3.2.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Data processing	GDAL is a translator library for raster geospatial data formats that is released under an X/MIT style Open Source license by the Open Source Geospatial Foundation. As a library, it presents a single abstract data model to the calling application for all supported formats. It also comes with a variety of useful commandline utilities for data translation and processing.
GDB	10.1, 9.1	2020b, 2019b	broadwell, epyc, skylake	aion, iris	Debugging	The GNU Project Debugger
GDRCopy	2.1	2020b	gpu	iris	Libraries	A low-latency GPU memory copy library based on NVIDIA GPUDirect RDMA technology.
GEOS	3.8.0, 3.9.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Mathematics	GEOS (Geometry Engine - Open Source) is a C++ port of the Java Topology Suite (JTS)
GLPK	4.65	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Utilities	The GLPK (GNU Linear Programming Kit) package is intended for solving large-scale linear programming (LP), mixed integer programming (MIP), and other related problems. It is a set of routines written in ANSI C and organized in the form of a callable library.
GLib	2.62.0, 2.66.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	GLib is one of the base libraries of the GTK+ project
GMP	6.1.2, 6.2.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Mathematics	GMP is a free library for arbitrary precision arithmetic, operating on signed integers, rational numbers, and floating point numbers.
GObject-Introspection	1.63.1, 1.66.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	GObject introspection is a middleware layer between C libraries (using GObject) and language bindings. The C library can be scanned at compile time and generate a metadata file, in addition to the actual native C library. Then at runtime, language bindings can read this metadata and automatically provide bindings to call into the C library.
GPAW-setups	0.9.20000	2019b	broadwell, skylake	iris	Chemistry	PAW setup for the GPAW Density Functional Theory package. Users can install setups manually using 'gpaw install-data' or use setups from this package. The versions of GPAW and GPAW-setups can be intermixed.
GPAW	20.1.0	2019b	broadwell, skylake	iris	Chemistry	GPAW is a density-functional theory (DFT) Python code based on the projector-augmented wave (PAW) method and the atomic simulation environment (ASE). It uses real-space uniform grids and multigrid methods or atom-centered basis-functions.
GROMACS	2019.4, 2019.6, 2020, 2021, 2021.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Biology	GROMACS is a versatile package to perform molecular dynamics, i.e. simulate the Newtonian equations of motion for systems with hundreds to millions of particles. This is a CPU only build, containing both MPI and threadMPI builds for both single and double precision. It also contains the gmxapi extension for the single precision MPI build.
GSL	2.6	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Numerical libraries	The GNU Scientific Library (GSL) is a numerical library for C and C++ programmers. The library provides a wide range of mathematical routines such as random number generators, special functions and least-squares fitting.
GTK+	3.24.13, 3.24.23	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	GTK+ is the primary library used to construct user interfaces in GNOME. It provides all the user interface controls, or widgets, used in a common graphical application. Its object-oriented API allows you to construct user interfaces without dealing with the low-level details of drawing and device interaction.
Gdk-Pixbuf	2.38.2, 2.40.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	The Gdk Pixbuf is a toolkit for image loading and pixel buffer manipulation. It is used by GTK+ 2 and GTK+ 3 to load and manipulate images. In the past it was distributed as part of GTK+ 2 but it was split off into a separate package in preparation for the change to GTK+ 3.
Ghostscript	9.50, 9.53.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Ghostscript is a versatile processor for PostScript data with the ability to render PostScript to different targets. It used to be part of the cups printing stack, but is no longer used for that.
Go	1.14.1, 1.16.6	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Compilers	Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.
Guile	1.8.8, 2.2.4	2019b	broadwell, skylake	iris	Programming Languages	Guile is a programming language, designed to help programmers create flexible applications that can be extended by users or other programmers with plug-ins, modules, or scripts.
Gurobi	9.0.0, 9.1.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematics	The Gurobi Optimizer is a state-of-the-art solver for mathematical programming. The solvers in the Gurobi Optimizer were designed from the ground up to exploit modern architectures and multi-core processors, using the most advanced implementations of the latest algorithms.
HDF5	1.10.5, 1.10.7	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Data processing	HDF5 is a data model, library, and file format for storing and managing data. It supports an unlimited variety of datatypes, and is designed for flexible and efficient I/O and for high volume and complex data.
HDF	4.2.15	2020b	broadwell, epyc, skylake, gpu	aion, iris	Data processing	HDF (also known as HDF4) is a library and multi-object file format for storing and managing data between machines.
HTSlib	1.10.2, 1.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	A C library for reading/writing high-throughput sequencing data. This package includes the utilities bgzip and tabix
Hadoop	2.10.0	2020b	broadwell, epyc, skylake	aion, iris	Utilities	Hadoop MapReduce by Cloudera
HarfBuzz	2.6.4, 2.6.7	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	HarfBuzz is an OpenType text shaping engine.
Harminv	1.4.1	2019b	broadwell, skylake	iris	Mathematics	Harminv is a free program (and accompanying library) to solve the problem of harmonic inversion - given a discrete-time, finite-length signal that consists of a sum of finitely-many sinusoids (possibly exponentially decaying) in a given bandwidth, it determines the frequencies, decay constants, amplitudes, and phases of those sinusoids.
Horovod	0.19.1, 0.22.0	2019b, 2020b	broadwell, skylake, gpu	iris	Utilities	Horovod is a distributed training framework for TensorFlow.
Hypre	2.20.0	2020b	broadwell, epyc, skylake	aion, iris	Numerical libraries	Hypre is a library for solving large, sparse linear systems of equations on massively parallel computers. The problems of interest arise in the simulation codes being developed at LLNL and elsewhere to study physical phenomena in the defense, environmental, energy, and biological sciences.
ICU	64.2, 67.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	ICU is a mature, widely used set of C/C++ and Java libraries providing Unicode and Globalization support for software applications.
ISL	0.23	2020b	broadwell, epyc, skylake	aion, iris	Mathematics	isl is a library for manipulating sets and relations of integer points bounded by linear constraints.
ImageMagick	7.0.10-35, 7.0.9-5	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	ImageMagick is a software suite to create, edit, compose, or convert bitmap images
Inspector	2019_update5	2019b	broadwell, skylake	iris	Utilities	Intel Inspector XE is an easy to use memory error checker and thread checker for serial and parallel applications
JasPer	2.0.14, 2.0.24	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	The JasPer Project is an open-source initiative to provide a free software-based reference implementation of the codec specified in the JPEG-2000 Part-1 standard.
Java	1.8.0_241, 11.0.2, 13.0.2, 16.0.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Java Platform, Standard Edition (Java SE) lets you develop and deploy Java applications on desktops and servers.
Jellyfish	2.3.0	2019b	broadwell, skylake	iris	Biology	Jellyfish is a tool for fast, memory-efficient counting of k-mers in DNA.
JsonCpp	1.9.3, 1.9.4	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	JsonCpp is a C++ library that allows manipulating JSON values, including serialization and deserialization to and from strings. It can also preserve existing comment in unserialization/serialization steps, making it a convenient format to store user input files.
Julia	1.4.1, 1.6.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Programming Languages	Julia is a high-level, high-performance dynamic programming language for numerical computing
Keras	2.3.1, 2.4.3	2019b, 2020b	gpu, broadwell, epyc, skylake	iris, aion	Mathematics	Keras is a deep learning API written in Python, running on top of the machine learning platform TensorFlow.
LAME	3.100	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Data processing	LAME is a high quality MPEG Audio Layer III (MP3) encoder licensed under the LGPL.
LLVM	10.0.1, 11.0.0, 9.0.0, 9.0.1	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Compilers	The LLVM Core libraries provide a modern source- and target-independent optimizer, along with code generation support for many popular CPUs (as well as some less common ones!) These libraries are built around a well specified code representation known as the LLVM intermediate representation ("LLVM IR"). The LLVM Core libraries are well documented, and it is particularly easy to invent your own language (or port an existing compiler) to use LLVM as an optimizer and code generator.
LMDB	0.9.24	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	LMDB is a fast, memory-efficient database. With memory-mapped files, it has the read performance of a pure in-memory database while retaining the persistence of standard disk-based databases.
LibTIFF	4.0.10, 4.1.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	tiff: Library and tools for reading and writing TIFF data files
LittleCMS	2.11, 2.9	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Little CMS intends to be an OPEN SOURCE small-footprint color management engine, with special focus on accuracy and performance.
Lua	5.1.5, 5.4.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Programming Languages	Lua is a powerful, fast, lightweight, embeddable scripting language. Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode for a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping.
M4	1.4.18	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	GNU M4 is an implementation of the traditional Unix macro processor. It is mostly SVR4 compatible although it has some extensions (for example, handling more than 9 positional parameters to macros). GNU M4 also has built-in functions for including files, running shell commands, doing arithmetic, etc.
MATLAB	2019b, 2020a, 2021a	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematics	MATLAB is a high-level language and interactive environment that enables you to perform computationally intensive tasks faster than with traditional programming languages such as C, C++, and Fortran.
METIS	5.1.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematics	METIS is a set of serial programs for partitioning graphs, partitioning finite element meshes, and producing fill reducing orderings for sparse matrices. The algorithms implemented in METIS are based on the multilevel recursive-bisection, multilevel k-way, and multi-constraint partitioning schemes.
MPC	1.2.1	2020b	broadwell, epyc, skylake	aion, iris	Mathematics	Gnu Mpc is a C library for the arithmetic of complex numbers with arbitrarily high precision and correct rounding of the result. It extends the principles of the IEEE-754 standard for fixed precision real floating point numbers to complex numbers, providing well-defined semantics for every operation. At the same time, speed of operation at high precision is a major design goal.
MPFR	4.0.2, 4.1.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Mathematics	The MPFR library is a C library for multiple-precision floating-point computations with correct rounding.
MUMPS	5.3.5	2020b	broadwell, epyc, skylake	aion, iris	Mathematics	A parallel sparse direct solver
Mako	1.1.0, 1.1.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	A super-fast templating language that borrows the best ideas from the existing templating languages
Mathematica	12.0.0, 12.1.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematics	Mathematica is a computational software program used in many scientific, engineering, mathematical and computing fields.
Maven	3.6.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	Binary maven install, Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information.
Meep	1.4.3	2019b	broadwell, skylake	iris	Physics	Meep (or MEEP) is a free finite-difference time-domain (FDTD) simulation software package developed at MIT to model electromagnetic systems.
Mesa	19.1.7, 19.2.1, 20.2.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	Mesa is an open-source implementation of the OpenGL specification - a system for rendering interactive 3D graphics.
Meson	0.51.2, 0.55.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Meson is a cross-platform build system designed to be both as fast and as user friendly as possible.
Mesquite	2.3.0	2019b	broadwell, skylake	iris	Mathematics	Mesh-Quality Improvement Library
NAMD	2.13	2019b	broadwell, skylake	iris	Chemistry	NAMD is a parallel molecular dynamics code designed for high-performance simulation of large biomolecular systems.
NASM	2.14.02, 2.15.05	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	NASM: General-purpose x86 assembler
NCCL	2.4.8, 2.8.3	2019b, 2020b	gpu	iris	Libraries	The NVIDIA Collective Communications Library (NCCL) implements multi-GPU and multi-node collective communication primitives that are performance optimized for NVIDIA GPUs.
NLopt	2.6.1, 2.6.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Numerical libraries	NLopt is a free/open-source library for nonlinear optimization, providing a common interface for a number of different free optimization routines available online as well as original implementations of various other algorithms.
NSPR	4.21, 4.29	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	Netscape Portable Runtime (NSPR) provides a platform-neutral API for system level and libc-like functions.
NSS	3.45, 3.57	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	Network Security Services (NSS) is a set of libraries designed to support cross-platform development of security-enabled client and server applications.
Ninja	1.10.1, 1.9.0	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Ninja is a small build system with a focus on speed.
OPARI2	2.0.5	2019b	broadwell, skylake	iris	Performance measurements	OPARI2, the successor of Forschungszentrum Juelich's OPARI, is a source-to-source instrumentation tool for OpenMP and hybrid codes. It surrounds OpenMP directives and runtime library calls with calls to the POMP2 measurement interface.
OTF2	2.2	2019b	broadwell, skylake	iris	Performance measurements	The Open Trace Format 2 is a highly scalable, memory efficient event trace data format plus support library. It is the new standard trace format for Scalasca, Vampir, and TAU and is open for other tools.
OpenBLAS	0.3.12, 0.3.7	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Numerical libraries	OpenBLAS is an optimized BLAS library based on GotoBLAS2 1.13 BSD version.
OpenCV	4.2.0, 4.5.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	OpenCV (Open Source Computer Vision Library) is an open source computer vision and machine learning software library. OpenCV was built to provide a common infrastructure for computer vision applications and to accelerate the use of machine perception in the commercial products. Includes extra modules for OpenCV from the contrib repository.
OpenEXR	2.5.5	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	OpenEXR is a high dynamic-range (HDR) image file format developed by Industrial Light & Magic for use in computer imaging applications
OpenFOAM-Extend	4.1-20200408	2019b	broadwell, skylake	iris	CFD/Finite element modelling	OpenFOAM is a free, open source CFD software package. OpenFOAM has an extensive range of features to solve anything from complex fluid flows involving chemical reactions, turbulence and heat transfer, to solid dynamics and electromagnetics.
OpenFOAM	8, v1912	2020b, 2019b	epyc, broadwell, skylake	aion, iris	CFD/Finite element modelling	OpenFOAM is a free, open source CFD software package. OpenFOAM has an extensive range of features to solve anything from complex fluid flows involving chemical reactions, turbulence and heat transfer, to solid dynamics and electromagnetics.
OpenMPI	3.1.4, 4.0.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	MPI	The Open MPI Project is an open source MPI-3 implementation.
PAPI	6.0.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Performance measurements	PAPI provides the tool designer and application engineer with a consistent interface and methodology for use of the performance counter hardware found in most major microprocessors. PAPI enables software engineers to see, in near real time, the relation between software performance and processor events. In addition Component PAPI provides access to a collection of components that expose performance measurement opportunites across the hardware and software stack.
PCRE2	10.33, 10.35	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Development	The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.
PCRE	8.43, 8.44	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.
PDT	3.25	2019b	broadwell, skylake	iris	Performance measurements	Program Database Toolkit (PDT) is a framework for analyzing source code written in several programming languages and for making rich program knowledge accessible to developers of static and dynamic analysis tools. PDT implements a standard program representation, the program database (PDB), that can be accessed in a uniform way through a class library supporting common PDB operations.
PETSc	3.14.4	2020b	broadwell, epyc, skylake	aion, iris	Numerical libraries	PETSc, pronounced PET-see (the S is silent), is a suite of data structures and routines for the scalable (parallel) solution of scientific applications modeled by partial differential equations.
PGI	19.10	2019b	broadwell, skylake	iris	Compilers	C, C++ and Fortran compilers from The Portland Group - PGI
PLUMED	2.5.3, 2.7.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Chemistry	PLUMED is an open source library for free energy calculations in molecular systems which works together with some of the most popular molecular dynamics engines. Free energy calculations can be performed as a function of many order parameters with a particular focus on biological problems, using state of the art methods such as metadynamics, umbrella sampling and Jarzynski-equation based steered MD. The software, written in C++, can be easily interfaced with both fortran and C/C++ codes.
POV-Ray	3.7.0.8	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	The Persistence of Vision Raytracer, or POV-Ray, is a ray tracing program which generates images from a text-based scene description, and is available for a variety of computer platforms. POV-Ray is a high-quality, Free Software tool for creating stunning three-dimensional graphics. The source code is available for those wanting to do their own ports.
PROJ	6.2.1, 7.2.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Program proj is a standard Unix filter function which converts geographic longitude and latitude coordinates into cartesian coordinates
Pango	1.44.7, 1.47.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	Pango is a library for laying out and rendering of text, with an emphasis on internationalization. Pango can be used anywhere that text layout is needed, though most of the work on Pango so far has been done in the context of the GTK+ widget toolkit. Pango forms the core of text and font handling for GTK+-2.x.
ParMETIS	4.0.3	2019b	broadwell, skylake	iris	Mathematics	ParMETIS is an MPI-based parallel library that implements a variety of algorithms for partitioning unstructured graphs, meshes, and for computing fill-reducing orderings of sparse matrices. ParMETIS extends the functionality provided by METIS and includes routines that are especially suited for parallel AMR computations and large scale numerical simulations. The algorithms implemented in ParMETIS are based on the parallel multilevel k-way graph-partitioning, adaptive repartitioning, and parallel multi-constrained partitioning schemes.
ParMGridGen	1.0	2019b	broadwell, skylake	iris	Mathematics	ParMGridGen is an MPI-based parallel library that is based on the serial package MGridGen, that implements (serial) algorithms for obtaining a sequence of successive coarse grids that are well-suited for geometric multigrid methods.
ParaView	5.6.2, 5.8.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	ParaView is a scientific parallel visualizer.
Perl	5.30.0, 5.32.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Larry Wall's Practical Extraction and Report Language This is a minimal build without any modules. Should only be used for build dependencies.
Pillow	6.2.1, 8.0.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	Pillow is the 'friendly PIL fork' by Alex Clark and Contributors. PIL is the Python Imaging Library by Fredrik Lundh and Contributors.
PyOpenGL	3.1.5	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	PyOpenGL is the most common cross platform Python binding to OpenGL and related APIs.
PyQt5	5.15.1	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	PyQt5 is a set of Python bindings for v5 of the Qt application framework from The Qt Company. This bundle includes PyQtWebEngine, a set of Python bindings for The Qt Company’s Qt WebEngine framework.
PyQtGraph	0.11.1	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	PyQtGraph is a pure-python graphics and GUI library built on PyQt5/PySide2 and numpy.
PyTorch-Geometric	1.6.3	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	PyTorch Geometric (PyG) is a geometric deep learning extension library for PyTorch.
PyTorch	1.4.0, 1.7.1, 1.8.1, 1.9.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	Tensors and Dynamic neural networks in Python with strong GPU acceleration. PyTorch is a deep learning framework that puts Python first.
PyYAML	5.1.2, 5.3.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	PyYAML is a YAML parser and emitter for the Python programming language.
Python	2.7.16, 2.7.18, 3.7.4, 3.8.6	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Python is a programming language that lets you work more quickly and integrate your systems more effectively.
Qt5	5.13.1, 5.14.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	Qt is a comprehensive cross-platform C++ application framework.
QuantumESPRESSO	6.7	2019b, 2020b	broadwell, epyc, skylake	iris, aion	Chemistry	Quantum ESPRESSO is an integrated suite of computer codes for electronic-structure calculations and materials modeling at the nanoscale. It is based on density-functional theory, plane waves, and pseudopotentials (both norm-conserving and ultrasoft).
RDFlib	5.0.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	RDFLib is a Python library for working with RDF, a simple yet powerful language for representing information.
R	3.6.2, 4.0.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	R is a free software environment for statistical computing and graphics.
ReFrame	2.21, 3.6.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	ReFrame is a framework for writing regression tests for HPC systems.
Ruby	2.7.1, 2.7.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Programming Languages	Ruby is a dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write.
Rust	1.37.0	2019b	broadwell, skylake	iris	Programming Languages	Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.
SAMtools	1.10, 1.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	SAM Tools provide various utilities for manipulating alignments in the SAM format, including sorting, merging, indexing and generating alignments in a per-position format.
SCOTCH	6.0.9, 6.1.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematics	Software package and libraries for sequential and parallel graph partitioning, static mapping, and sparse matrix block ordering, and sequential mesh and hypergraph partitioning.
SDL2	2.0.14	2020b	broadwell, epyc, skylake	aion, iris	Libraries	SDL: Simple DirectMedia Layer, a cross-platform multimedia library
SIONlib	1.7.6	2019b	broadwell, skylake	iris	Libraries	SIONlib is a scalable I/O library for parallel access to task-local files. The library not only supports writing and reading binary data to or from several thousands of processors into a single or a small number of physical files, but also provides global open and close functions to access SIONlib files in parallel. This package provides a stripped-down installation of SIONlib for use with performance tools (e.g., Score-P), with renamed symbols to avoid conflicts when an application using SIONlib itself is linked against a tool requiring a different SIONlib version.
SLEPc	3.14.2	2020b	broadwell, epyc, skylake	aion, iris	Numerical libraries	SLEPc (Scalable Library for Eigenvalue Problem Computations) is a software library for the solution of large scale sparse eigenvalue problems on parallel computers. It is an extension of PETSc and can be used for either standard or generalized eigenproblems, with real or complex arithmetic. It can also be used for computing a partial SVD of a large, sparse, rectangular matrix, and to solve quadratic eigenvalue problems.
SQLite	3.29.0, 3.33.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	SQLite: SQL Database Engine in a C Library
SWIG	4.0.1, 4.0.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	SWIG is a software development tool that connects programs written in C and C++ with a variety of high-level programming languages.
Salmon	1.1.0	2019b	broadwell, skylake	iris	Biology	Salmon is a wicked-fast program to produce a highly-accurate, transcript-level quantification estimates from RNA-seq data.
Salome	8.5.0, 9.8.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	CFD/Finite element modelling	The SALOME platform is an open source software framework for pre- and post-processing and integration of numerical solvers from various scientific fields. CEA and EDF use SALOME to perform a large number of simulations, typically related to power plant equipment and alternative energy. To address these challenges, SALOME includes a CAD/CAE modelling tool, mesh generators, an advanced 3D visualization tool, etc.
ScaLAPACK	2.0.2, 2.1.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Numerical libraries	The ScaLAPACK (or Scalable LAPACK) library includes a subset of LAPACK routines redesigned for distributed memory MIMD parallel computers.
Scalasca	2.5	2019b	broadwell, skylake	iris	Performance measurements	Scalasca is a software tool that supports the performance optimization of parallel programs by measuring and analyzing their runtime behavior. The analysis identifies potential performance bottlenecks -- in particular those concerning communication and synchronization -- and offers guidance in exploring their causes.
SciPy-bundle	2019.10, 2020.11	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Bundle of Python packages for scientific software
Score-P	6.0	2019b	broadwell, skylake	iris	Performance measurements	The Score-P measurement infrastructure is a highly scalable and easy-to-use tool suite for profiling, event tracing, and online analysis of HPC applications.
Singularity	3.6.0, 3.8.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	SingularityCE is an open source container platform designed to be simple, fast, and secure. Singularity is optimized for EPC and HPC workloads, allowing untrusted users to run untrusted containers in a trusted way.
Spack	0.12.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	Spack is a package manager for supercomputers, Linux, and macOS. It makes installing scientific software easy. With Spack, you can build a package with multiple versions, configurations, platforms, and compilers, and all of these builds can coexist on the same machine.
Spark	2.4.3	2019b	broadwell, skylake	iris	Development	Spark is Hadoop MapReduce done in memory
Stata	17	2020b	broadwell, epyc, skylake	aion, iris	Mathematics	Stata is a complete, integrated statistical software package that provides everything you need for data analysis, data management, and graphics.
SuiteSparse	5.8.1	2020b	broadwell, epyc, skylake	aion, iris	Numerical libraries	SuiteSparse is a collection of libraries manipulate sparse matrices.
Sumo	1.3.1	2019b	broadwell, skylake	iris	Utilities	Sumo is an open source, highly portable, microscopic and continuous traffic simulation package designed to handle large road networks.
Szip	2.1.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Szip compression software, providing lossless compression of scientific data
Tcl	8.6.10, 8.6.9	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Tcl (Tool Command Language) is a very powerful but easy to learn dynamic programming language, suitable for a very wide range of uses, including web and desktop applications, networking, administration, testing and many more.
TensorFlow	1.15.5, 2.1.0, 2.4.1, 2.5.0	2019b, 2020b	gpu, broadwell, skylake, epyc	iris, aion	Libraries	An open-source software library for Machine Intelligence
Theano	1.0.4, 1.1.2	2019b, 2020b	gpu, broadwell, epyc, skylake	iris, aion	Mathematics	Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently.
Tk	8.6.10, 8.6.9	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Tk is an open source, cross-platform widget toolchain that provides a library of basic elements for building a graphical user interface (GUI) in many different programming languages.
Tkinter	3.7.4, 3.8.6	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Programming Languages	Tkinter module, built with the Python buildsystem
TopHat	2.1.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	TopHat is a fast splice junction mapper for RNA-Seq reads.
Trinity	2.10.0	2019b	broadwell, skylake	iris	Biology	Trinity represents a novel method for the efficient and robust de novo reconstruction of transcriptomes from RNA-Seq data. Trinity combines three independent software modules: Inchworm, Chrysalis, and Butterfly, applied sequentially to process large volumes of RNA-Seq reads.
UCX	1.9.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Unified Communication X An open-source production grade communication framework for data centric and high-performance applications
UDUNITS	2.2.26	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Physics	UDUNITS supports conversion of unit specifications between formatted and binary forms, arithmetic manipulation of units, and conversion of values between compatible scales of measurement.
ULHPC-bd	2020b	2020b	broadwell, epyc, skylake	aion, iris	System-level software	Generic Module bundle for BigData Analytics software in use on the UL HPC Facility
ULHPC-bio	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	System-level software	Generic Module bundle for Bioinformatics, biology and biomedical software in use on the UL HPC Facility, especially at LCSB
ULHPC-cs	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	System-level software	Generic Module bundle for Computational science software in use on the UL HPC Facility, including: - Computer Aided Engineering, incl. CFD - Chemistry, Computational Chemistry and Quantum Chemistry - Data management & processing tools - Earth Sciences - Quantum Computing - Physics and physical systems simulations
ULHPC-dl	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	System-level software	Generic Module bundle for (CPU-version) of AI / Deep Learning / Machine Learning software in use on the UL HPC Facility
ULHPC-gpu	2019b, 2020b	2019b, 2020b	gpu	iris	System-level software	Generic Module bundle for GPU accelerated User Software in use on the UL HPC Facility
ULHPC-math	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	System-level software	Generic Module bundle for High-level mathematical software and Linear Algrebra libraries in use on the UL HPC Facility
ULHPC-toolchains	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	System-level software	Generic Module bundle that contains all the dependencies required to enable toolchains and building tools/programming language in use on the UL HPC Facility
ULHPC-tools	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	System-level software	Misc tools, incl. - perf: Performance tools - tools: General purpose tools
UnZip	6.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	UnZip is an extraction utility for archives compressed in .zip format (also called "zipfiles"). Although highly compatible both with PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP's own Zip program, our primary objectives have been portability and non-MSDOS functionality.
VASP	5.4.4, 6.2.1	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Physics	The Vienna Ab initio Simulation Package (VASP) is a computer program for atomic scale materials modelling, e.g. electronic structure calculations and quantum-mechanical molecular dynamics, from first principles.
VMD	1.9.4a51	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	VMD is a molecular visualization program for displaying, animating, and analyzing large biomolecular systems using 3-D graphics and built-in scripting.
VTK	8.2.0, 9.0.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	The Visualization Toolkit (VTK) is an open-source, freely available software system for 3D computer graphics, image processing and visualization. VTK consists of a C++ class library and several interpreted interface layers including Tcl/Tk, Java, and Python. VTK supports a wide variety of visualization algorithms including: scalar, vector, tensor, texture, and volumetric methods; and advanced modeling techniques such as: implicit modeling, polygon reduction, mesh smoothing, cutting, contouring, and Delaunay triangulation.
VTune	2019_update8, 2020_update3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	Intel VTune Amplifier XE is the premier performance profiler for C, C++, C#, Fortran, Assembly and Java.
Valgrind	3.15.0, 3.16.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Debugging	Valgrind: Debugging and profiling tools
VirtualGL	2.6.2	2019b	broadwell, skylake	iris	Visualisation	VirtualGL is an open source toolkit that gives any Linux or Unix remote display software the ability to run OpenGL applications with full hardware acceleration.
Voro++	0.4.6	2019b	broadwell, skylake	iris	Mathematics	Voro++ is a software library for carrying out three-dimensional computations of the Voronoi tessellation. A distinguishing feature of the Voro++ library is that it carries out cell-based calculations, computing the Voronoi cell for each particle individually. It is particularly well-suited for applications that rely on cell-based statistics, where features of Voronoi cells (eg. volume, centroid, number of faces) can be used to analyze a system of particles.
Wannier90	3.1.0	2020b	broadwell, epyc, skylake	aion, iris	Chemistry	A tool for obtaining maximally-localised Wannier functions
X11	20190717, 20201008	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	The X Window System (X11) is a windowing system for bitmap displays
XML-LibXML	2.0201, 2.0206	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Data processing	Perl binding for libxml2
XZ	5.2.4, 5.2.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	xz: XZ utilities
Xerces-C++	3.2.2	2019b	broadwell, skylake	iris	Libraries	Xerces-C++ is a validating XML parser written in a portable subset of C++. Xerces-C++ makes it easy to give your application the ability to read and write XML data. A shared library is provided for parsing, generating, manipulating, and validating XML documents using the DOM, SAX, and SAX2 APIs.
Xvfb	1.20.9	2020b	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Xvfb is an X server that can run on machines with no display hardware and no physical input devices. It emulates a dumb framebuffer using virtual memory.
YACS	0.1.8	2020b	broadwell, epyc, skylake	aion, iris	Libraries	YACS was created as a lightweight library to define and manage system configurations, such as those commonly found in software designed for scientific experimentation. These "configurations" typically cover concepts like hyperparameters used in training a machine learning model or configurable model hyperparameters, such as the depth of a convolutional neural network.
Yasm	1.3.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Yasm: Complete rewrite of the NASM assembler with BSD license
Z3	4.8.10	2020b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Z3 is a theorem prover from Microsoft Research.
Zip	3.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Zip is a compression and file packaging/archive utility. Although highly compatible both with PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP's own UnZip, our primary objectives have been portability and other-than-MSDOS functionality
ant	1.10.6, 1.10.7, 1.10.9	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	Apache Ant is a Java library and command-line tool whose mission is to drive processes described in build files as targets and extension points dependent upon each other. The main known usage of Ant is the build of Java applications.
archspec	0.1.0	2019b	broadwell, skylake	iris	Utilities	A library for detecting, labeling, and reasoning about microarchitectures
arpack-ng	3.7.0, 3.8.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Numerical libraries	ARPACK is a collection of Fortran77 subroutines designed to solve large scale eigenvalue problems.
at-spi2-atk	2.34.1, 2.38.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	AT-SPI 2 toolkit bridge
at-spi2-core	2.34.0, 2.38.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	Assistive Technology Service Provider Interface.
binutils	2.32, 2.35	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	binutils: GNU binary utilities
bokeh	2.2.3	2020b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Statistical and novel interactive HTML plots for Python
bzip2	1.0.8	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.
cURL	7.66.0, 7.72.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more.
cairo	1.16.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	Cairo is a 2D graphics library with support for multiple output devices. Currently supported output targets include the X Window System (via both Xlib and XCB), Quartz, Win32, image buffers, PostScript, PDF, and SVG file output. Experimental backends include OpenGL, BeOS, OS/2, and DirectFB
cuDNN	7.6.4.38, 8.0.4.30, 8.0.5.39	2019b, 2020b	gpu	iris	Numerical libraries	The NVIDIA CUDA Deep Neural Network library (cuDNN) is a GPU-accelerated library of primitives for deep neural networks.
dask	2021.2.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Data processing	Dask natively scales Python. Dask provides advanced parallelism for analytics, enabling performance at scale for the tools you love.
double-conversion	3.1.4, 3.1.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Efficient binary-decimal and decimal-binary conversion routines for IEEE doubles.
elfutils	0.183	2020b	gpu	iris	Libraries	The elfutils project provides libraries and tools for ELF files and DWARF data.
expat	2.2.7, 2.2.9	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Expat is an XML parser library written in C. It is a stream-oriented parser in which an application registers handlers for things the parser might find in the XML document (like start tags)
flatbuffers-python	1.12	2020b	broadwell, epyc, skylake, gpu	aion, iris	Development	Python Flatbuffers runtime library.
flatbuffers	1.12.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	FlatBuffers: Memory Efficient Serialization Library
flex	2.6.4	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Flex (Fast Lexical Analyzer) is a tool for generating scanners. A scanner, sometimes called a tokenizer, is a program which recognizes lexical patterns in text.
fontconfig	2.13.1, 2.13.92	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	Fontconfig is a library designed to provide system-wide font configuration, customization and application access.
foss	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain, including OpenMPI for MPI support, OpenBLAS (BLAS and LAPACK support), FFTW and ScaLAPACK.
fosscuda	2019b, 2020b	2019b, 2020b	gpu	iris	Toolchains (software stacks)	GCC based compiler toolchain with CUDA support, and including OpenMPI for MPI support, OpenBLAS (BLAS and LAPACK support), FFTW and ScaLAPACK.
freetype	2.10.1, 2.10.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	FreeType 2 is a software font engine that is designed to be small, efficient, highly customizable, and portable while capable of producing high-quality output (glyph images). It can be used in graphics libraries, display servers, font conversion tools, text image generation tools, and many other products as well.
gc	7.6.12	2019b	broadwell, skylake	iris	Libraries	The Boehm-Demers-Weiser conservative garbage collector can be used as a garbage collecting replacement for C malloc or C++ new.
gcccuda	2019b, 2020b	2019b, 2020b	gpu	iris	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain, along with CUDA toolkit.
gettext	0.19.8.1, 0.20.1, 0.21	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	GNU 'gettext' is an important step for the GNU Translation Project, as it is an asset on which we may build many other steps. This package offers to programmers, translators, and even users, a well integrated set of tools and documentation
gflags	2.2.2	2019b	broadwell, skylake	iris	Development	The gflags package contains a C++ library that implements commandline flags processing. It includes built-in support for standard types such as string and the ability to define flags in the source file in which they are used.
giflib	5.2.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	giflib is a library for reading and writing gif images. It is API and ABI compatible with libungif which was in wide use while the LZW compression algorithm was patented.
git	2.23.0, 2.28.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.
glog	0.4.0	2019b	broadwell, skylake	iris	Development	A C++ implementation of the Google logging module.
gmsh	4.4.0	2019b	broadwell, skylake	iris	CFD/Finite element modelling	Salome is an open-source software that provides a generic Pre- and Post-Processing platform for numerical simulation. It is based on an open and flexible architecture made of reusable components.
gmsh	4.8.4	2020b	broadwell, epyc, skylake	aion, iris	Mathematics	Gmsh is a 3D finite element grid generator with a build-in CAD engine and post-processor.
gnuplot	5.2.8, 5.4.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	Portable interactive, function plotting utility
gocryptfs	1.7.1, 2.0.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	Encrypted overlay filesystem written in Go. gocryptfs uses file-based encryption that is implemented as a mountable FUSE filesystem. Each file in gocryptfs is stored as one corresponding encrypted file on the hard disk.
gompi	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain, including OpenMPI for MPI support.
gompic	2019b, 2020b	2019b, 2020b	gpu	iris	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain along with CUDA toolkit, including OpenMPI for MPI support with CUDA features enabled.
googletest	1.10.0	2019b	broadwell, skylake	iris	Development	Google's framework for writing C++ tests on a variety of platforms
gperf	3.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	GNU gperf is a perfect hash function generator. For a given list of strings, it produces a hash function and hash table, in form of C or C++ code, for looking up a value depending on the input string. The hash function is perfect, which means that the hash table has no collisions, and the hash table lookup needs a single string comparison only.
groff	1.22.4	2020b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Groff (GNU troff) is a typesetting system that reads plain text mixed with formatting commands and produces formatted output.
gzip	1.10	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Utilities	gzip (GNU zip) is a popular data compression program as a replacement for compress
h5py	2.10.0, 3.1.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Data processing	HDF5 for Python (h5py) is a general-purpose Python interface to the Hierarchical Data Format library, version 5. HDF5 is a versatile, mature scientific software library designed for the fast, flexible storage of enormous amounts of data.
help2man	1.47.16, 1.47.4, 1.47.8	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	help2man produces simple manual pages from the '--help' and '--version' output of other commands.
hwloc	1.11.12, 2.2.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	System-level software	The Portable Hardware Locality (hwloc) software package provides a portable abstraction (across OS, versions, architectures, ...) of the hierarchical topology of modern architectures, including NUMA memory nodes, sockets, shared caches, cores and simultaneous multithreading. It also gathers various system attributes such as cache and memory information as well as the locality of I/O devices such as network interfaces, InfiniBand HCAs or GPUs. It primarily aims at helping applications with gathering information about modern computing hardware so as to exploit it accordingly and efficiently.
hypothesis	4.44.2, 5.41.2, 5.41.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Hypothesis is an advanced testing library for Python. It lets you write tests which are parametrized by a source of examples, and then generates simple and comprehensible examples that make your tests fail. This lets you find more bugs in your code with less work.
iccifort	2019.5.281, 2020.4.304	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Compilers	Intel C, C++ & Fortran compilers
iccifortcuda	2019b, 2020b	2019b, 2020b	gpu	iris	Toolchains (software stacks)	Intel C, C++ & Fortran compilers with CUDA toolkit
iimpi	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Toolchains (software stacks)	Intel C/C++ and Fortran compilers, alongside Intel MPI.
iimpic	2019b, 2020b	2019b, 2020b	gpu	iris	Toolchains (software stacks)	Intel C/C++ and Fortran compilers, alongside Intel MPI and CUDA.
imkl	2019.5.281, 2020.4.304	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Numerical libraries	Intel Math Kernel Library is a library of highly optimized, extensively threaded math routines for science, engineering, and financial applications that require maximum performance. Core math functions include BLAS, LAPACK, ScaLAPACK, Sparse Solvers, Fast Fourier Transforms, Vector Math, and more.
impi	2018.5.288, 2019.9.304	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	MPI	Intel MPI Library, compatible with MPICH ABI
intel	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Toolchains (software stacks)	Compiler toolchain including Intel compilers, Intel MPI and Intel Math Kernel Library (MKL).
intelcuda	2019b, 2020b	2019b, 2020b	gpu	iris	Toolchains (software stacks)	Intel Cluster Toolkit Compiler Edition provides Intel C/C++ and Fortran compilers, Intel MPI & Intel MKL, with CUDA toolkit
intltool	0.51.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	intltool is a set of tools to centralize translation of many different file formats using GNU gettext-compatible PO files.
itac	2019.4.036	2019b	broadwell, skylake	iris	Utilities	The Intel Trace Collector is a low-overhead tracing library that performs event-based tracing in applications. The Intel Trace Analyzer provides a convenient way to monitor application activities gathered by the Intel Trace Collector through graphical displays.
jemalloc	5.2.1	2019b	broadwell, skylake	iris	Libraries	jemalloc is a general purpose malloc(3) implementation that emphasizes fragmentation avoidance and scalable concurrency support.
kallisto	0.46.1	2019b	broadwell, skylake	iris	Biology	kallisto is a program for quantifying abundances of transcripts from RNA-Seq data, or more generally of target sequences using high-throughput sequencing reads.
kim-api	2.1.3	2019b	broadwell, skylake	iris	Chemistry	Open Knowledgebase of Interatomic Models. KIM is an API and OpenKIM is a collection of interatomic models (potentials) for atomistic simulations. This is a library that can be used by simulation programs to get access to the models in the OpenKIM database. This EasyBuild only installs the API, the models can be installed with the package openkim-models, or the user can install them manually by running kim-api-collections-management install user MODELNAME or kim-api-collections-management install user OpenKIM to install them all.
libGLU	9.0.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	The OpenGL Utility Library (GLU) is a computer graphics library for OpenGL.
libarchive	3.4.3	2020b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Multi-format archive and compression library
libcerf	1.13, 1.14	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematics	libcerf is a self-contained numeric library that provides an efficient and accurate implementation of complex error functions, along with Dawson, Faddeeva, and Voigt functions.
libctl	4.0.0	2019b	broadwell, skylake	iris	Chemistry	libctl is a free Guile-based library implementing flexible control files for scientific simulations.
libdrm	2.4.102, 2.4.99	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Direct Rendering Manager runtime library.
libepoxy	1.5.4	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	Epoxy is a library for handling OpenGL function pointer management for you
libevent	2.1.11, 2.1.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	The libevent API provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached. Furthermore, libevent also support callbacks due to signals or regular timeouts.
libffi	3.2.1, 3.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	The libffi library provides a portable, high level programming interface to various calling conventions. This allows a programmer to call any function specified by a call interface description at run-time.
libgd	2.2.5, 2.3.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	GD is an open source code library for the dynamic creation of images by programmers.
libgeotiff	1.5.1, 1.6.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Library for reading and writing coordinate system information from/to GeoTIFF files
libglvnd	1.2.0, 1.3.2	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Libraries	libglvnd is a vendor-neutral dispatch layer for arbitrating OpenGL API calls between multiple vendors.
libgpuarray	0.7.6	2019b, 2020b	gpu	iris	Libraries	Library to manipulate tensors on the GPU.
libiconv	1.16	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Libiconv converts from one character encoding to another through Unicode conversion
libjpeg-turbo	2.0.3, 2.0.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	libjpeg-turbo is a fork of the original IJG libjpeg which uses SIMD to accelerate baseline JPEG compression and decompression. libjpeg is a library that implements JPEG image encoding, decoding and transcoding.
libmatheval	1.1.11	2019b	broadwell, skylake	iris	Libraries	GNU libmatheval is a library (callable from C and Fortran) to parse and evaluate symbolic expressions input as text.
libogg	1.3.4	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Ogg is a multimedia container format, and the native file and stream format for the Xiph.org multimedia codecs.
libpciaccess	0.14, 0.16	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	System-level software	Generic PCI access library.
libpng	1.6.37	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	libpng is the official PNG reference library
libreadline	8.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	The GNU Readline library provides a set of functions for use by applications that allow users to edit command lines as they are typed in. Both Emacs and vi editing modes are available. The Readline library includes additional functions to maintain a list of previously-entered command lines, to recall and perhaps reedit those lines, and perform csh-like history expansion on previous commands.
libsndfile	1.0.28	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Libsndfile is a C library for reading and writing files containing sampled sound (such as MS Windows WAV and the Apple/SGI AIFF format) through one standard library interface.
libtirpc	1.3.1	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Libtirpc is a port of Suns Transport-Independent RPC library to Linux.
libtool	2.4.6	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	GNU libtool is a generic library support script. Libtool hides the complexity of using shared libraries behind a consistent, portable interface.
libunistring	0.9.10	2019b	broadwell, skylake	iris	Libraries	This library provides functions for manipulating Unicode strings and for manipulating C strings according to the Unicode standard.
libunwind	1.3.1, 1.4.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	The primary goal of libunwind is to define a portable and efficient C programming interface (API) to determine the call-chain of a program. The API additionally provides the means to manipulate the preserved (callee-saved) state of each call-frame and to resume execution at any point in the call-chain (non-local goto). The API supports both local (same-process) and remote (across-process) operation. As such, the API is useful in a number of applications
libvorbis	1.3.7	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Ogg Vorbis is a fully open, non-proprietary, patent-and-royalty-free, general-purpose compressed audio format
libwebp	1.1.0	2020b	broadwell, epyc, skylake	aion, iris	Libraries	WebP is a modern image format that provides superior lossless and lossy compression for images on the web. Using WebP, webmasters and web developers can create smaller, richer images that make the web faster.
libxc	4.3.4, 5.1.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Chemistry	Libxc is a library of exchange-correlation functionals for density-functional theory. The aim is to provide a portable, well tested and reliable set of exchange and correlation functionals.
libxml2	2.9.10, 2.9.9	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Libxml2 is the XML C parser and toolchain developed for the Gnome project (but usable outside of the Gnome platform).
libxslt	1.1.34	2019b	broadwell, skylake	iris	Libraries	Libxslt is the XSLT C library developed for the GNOME project (but usable outside of the Gnome platform).
libyaml	0.2.2, 0.2.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	LibYAML is a YAML parser and emitter written in C.
lxml	4.4.2	2019b	broadwell, skylake	iris	Libraries	The lxml XML toolkit is a Pythonic binding for the C libraries libxml2 and libxslt.
lz4	1.9.2	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	LZ4 is lossless compression algorithm, providing compression speed at 400 MB/s per core. It features an extremely fast decoder, with speed in multiple GB/s per core.
magma	2.5.1, 2.5.4	2019b, 2020b	gpu	iris	Mathematics	The MAGMA project aims to develop a dense linear algebra library similar to LAPACK but for heterogeneous/hybrid architectures, starting with current Multicore+GPU systems.
makeinfo	6.7	2020b	broadwell, epyc, skylake, gpu	aion, iris	Development	makeinfo is part of the Texinfo project, the official documentation format of the GNU project.
matplotlib	3.1.1, 3.3.3	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Visualisation	matplotlib is a python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. matplotlib can be used in python scripts, the python and ipython shell, web application servers, and six graphical user interface toolkits.
molmod	1.4.5	2019b	broadwell, skylake	iris	Mathematics	MolMod is a Python library with many compoments that are useful to write molecular modeling programs.
ncurses	6.0, 6.1, 6.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	The Ncurses (new curses) library is a free software emulation of curses in System V Release 4.0, and more. It uses Terminfo format, supports pads and color and multiple highlights and forms characters and function-key mapping, and has all the other SYSV-curses enhancements over BSD Curses.
netCDF-Fortran	4.5.2, 4.5.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Data processing	NetCDF (network Common Data Form) is a set of software libraries and machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.
netCDF	4.7.1, 4.7.4	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Data processing	NetCDF (network Common Data Form) is a set of software libraries and machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.
nettle	3.5.1, 3.6	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Nettle is a cryptographic library that is designed to fit easily in more or less any context: In crypto toolkits for object-oriented languages (C++, Python, Pike, ...), in applications like LSH or GNUPG, or even in kernel space.
networkx	2.5	2020b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	NetworkX is a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.
nodejs	12.19.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Node.js is a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.
nsync	1.24.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	nsync is a C library that exports various synchronization primitives, such as mutexes
numactl	2.0.12, 2.0.13	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	The numactl program allows you to run your application program on specific cpu's and memory nodes. It does this by supplying a NUMA memory policy to the operating system before running your program. The libnuma library provides convenient ways for you to add NUMA memory policies into your own program.
numba	0.52.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Numba is an Open Source NumPy-aware optimizing compiler for Python sponsored by Continuum Analytics, Inc. It uses the remarkable LLVM compiler infrastructure to compile Python syntax to machine code.
phonopy	2.2.0	2019b	broadwell, skylake	iris	Libraries	Phonopy is an open source package of phonon calculations based on the supercell approach.
pixman	0.38.4, 0.40.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	Pixman is a low-level software library for pixel manipulation, providing features such as image compositing and trapezoid rasterization. Important users of pixman are the cairo graphics library and the X server.
pkg-config	0.29.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	pkg-config is a helper tool used when compiling applications and libraries. It helps you insert the correct compiler options on the command line so an application can use gcc -o test test.c pkg-config --libs --cflags glib-2.0 for instance, rather than hard-coding values on where to find glib (or other libraries).
pkgconfig	1.5.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	pkgconfig is a Python module to interface with the pkg-config command line tool
pocl	1.4, 1.6	2019b, 2020b	gpu	iris	Libraries	Pocl is a portable open source (MIT-licensed) implementation of the OpenCL standard
protobuf-python	3.10.0, 3.14.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	Python Protocol Buffers runtime library.
protobuf	2.5.0, 3.10.0, 3.14.0	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Development	Google Protocol Buffers
pybind11	2.4.3, 2.6.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	pybind11 is a lightweight header-only library that exposes C++ types in Python and vice versa, mainly to create Python bindings of existing C++ code.
re2c	1.2.1, 2.0.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	re2c is a free and open-source lexer generator for C and C++. Its main goal is generating fast lexers: at least as fast as their reasonably optimized hand-coded counterparts. Instead of using traditional table-driven approach, re2c encodes the generated finite state automata directly in the form of conditional jumps and comparisons.
scikit-build	0.11.1	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Scikit-Build, or skbuild, is an improved build system generator for CPython C/C++/Fortran/Cython extensions.
scikit-image	0.18.1	2020b	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	scikit-image is a collection of algorithms for image processing.
scikit-learn	0.23.2	2020b	broadwell, epyc, skylake, gpu	aion, iris	Data processing	Scikit-learn integrates machine learning algorithms in the tightly-knit scientific Python world, building upon numpy, scipy, and matplotlib. As a machine-learning module, it provides versatile tools for data mining and analysis in any field of science and engineering. It strives to be simple and efficient, accessible to everybody, and reusable in various contexts.
scipy	1.4.1	2019b	broadwell, skylake, gpu	iris	Mathematics	SciPy is a collection of mathematical algorithms and convenience functions built on the Numpy extension for Python.
setuptools	41.0.1	2019b	broadwell, skylake	iris	Development	Easily download, build, install, upgrade, and uninstall Python packages
snappy	1.1.7, 1.1.8	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Snappy is a compression/decompression library. It does not aim for maximum compression, or compatibility with any other compression library; instead, it aims for very high speeds and reasonable compression.
sparsehash	2.0.3, 2.0.4	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	An extremely memory-efficient hash_map implementation. 2 bits/entry overhead! The SparseHash library contains several hash-map implementations, including implementations that optimize for space or speed.
spglib-python	1.16.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Chemistry	Spglib for Python. Spglib is a library for finding and handling crystal symmetries written in C.
tbb	2019_U9, 2020.2, 2020.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	Intel(R) Threading Building Blocks (Intel(R) TBB) lets you easily write parallel C++ programs that take full advantage of multicore performance, that are portable, composable and have future-proof scalability.
texinfo	6.7	2019b	broadwell, skylake	iris	Development	Texinfo is the official documentation format of the GNU project.
tqdm	4.56.2	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	A fast, extensible progress bar for Python and CLI
typing-extensions	3.7.4.3	2019b, 2020b	gpu, broadwell, epyc, skylake	iris, aion	Development	Typing Extensions – Backported and Experimental Type Hints for Python
util-linux	2.34, 2.36	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Set of Linux utilities
x264	20190925, 20201026	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	x264 is a free software library and application for encoding video streams into the H.264/MPEG-4 AVC compression format, and is released under the terms of the GNU GPL.
x265	3.2, 3.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	x265 is a free software library and application for encoding video streams into the H.265 AVC compression format, and is released under the terms of the GNU GPL.
xorg-macros	1.19.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	X.org macros utilities.
xprop	1.2.4, 1.2.5	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	The xprop utility is for displaying window and font properties in an X server. One window or font is selected using the command line arguments or possibly in the case of a window, by clicking on the desired window. A list of properties is then given, possibly with formatting information.
yaff	1.6.0	2019b	broadwell, skylake	iris	Chemistry	Yaff stands for 'Yet another force field'. It is a pythonic force-field code.
zlib	1.2.11	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	zlib is designed to be a free, general-purpose, legally unencumbered -- that is, not covered by any patents -- lossless data-compression library for use on virtually any computer hardware and operating system.
zstd	1.4.5	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries

Biology

Alphabetical list of available ULHPC software belonging to the 'bio' category. To load a software of this category, use: module load bio/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
ABySS	2.2.5	2020b	broadwell, epyc, skylake	aion, iris	Assembly By Short Sequences - a de novo, parallel, paired-end sequence assembler
BEDTools	2.29.2, 2.30.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	BEDTools: a powerful toolset for genome arithmetic. The BEDTools utilities allow one to address common genomics tasks such as finding feature overlaps and computing coverage. The utilities are largely based on four widely-used file formats: BED, GFF/GTF, VCF, and SAM/BAM.
BLAST+	2.11.0, 2.9.0	2020b, 2019b	broadwell, epyc, skylake	aion, iris	Basic Local Alignment Search Tool, or BLAST, is an algorithm for comparing primary biological sequence information, such as the amino-acid sequences of different proteins or the nucleotides of DNA sequences.
BWA	0.7.17	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Burrows-Wheeler Aligner (BWA) is an efficient program that aligns relatively short nucleotide sequences against a long reference sequence such as the human genome.
BamTools	2.5.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	BamTools provides both a programmer's API and an end-user's toolkit for handling BAM files.
BioPerl	1.7.2, 1.7.8	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Bioperl is the product of a community effort to produce Perl code which is useful in biology. Examples include Sequence objects, Alignment objects and database searching objects.
Bowtie2	2.3.5.1, 2.4.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters, and particularly good at aligning to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an FM Index to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 GB. Bowtie 2 supports gapped, local, and paired-end alignment modes.
FastQC	0.11.9	2019b, 2020b	broadwell, skylake, epyc	iris, aion	FastQC is a quality control application for high throughput sequence data. It reads in sequence data in a variety of formats and can either provide an interactive application to review the results of several different QC checks, or create an HTML based report which can be integrated into a pipeline.
GROMACS	2019.4, 2019.6, 2020, 2021, 2021.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	GROMACS is a versatile package to perform molecular dynamics, i.e. simulate the Newtonian equations of motion for systems with hundreds to millions of particles. This is a CPU only build, containing both MPI and threadMPI builds for both single and double precision. It also contains the gmxapi extension for the single precision MPI build.
HTSlib	1.10.2, 1.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	A C library for reading/writing high-throughput sequencing data. This package includes the utilities bgzip and tabix
Jellyfish	2.3.0	2019b	broadwell, skylake	iris	Jellyfish is a tool for fast, memory-efficient counting of k-mers in DNA.
SAMtools	1.10, 1.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	SAM Tools provide various utilities for manipulating alignments in the SAM format, including sorting, merging, indexing and generating alignments in a per-position format.
Salmon	1.1.0	2019b	broadwell, skylake	iris	Salmon is a wicked-fast program to produce a highly-accurate, transcript-level quantification estimates from RNA-seq data.
TopHat	2.1.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	TopHat is a fast splice junction mapper for RNA-Seq reads.
Trinity	2.10.0	2019b	broadwell, skylake	iris	Trinity represents a novel method for the efficient and robust de novo reconstruction of transcriptomes from RNA-Seq data. Trinity combines three independent software modules: Inchworm, Chrysalis, and Butterfly, applied sequentially to process large volumes of RNA-Seq reads.
kallisto	0.46.1	2019b	broadwell, skylake	iris	kallisto is a program for quantifying abundances of transcripts from RNA-Seq data, or more generally of target sequences using high-throughput sequencing reads.

CFD/Finite element modelling

Alphabetical list of available ULHPC software belonging to the 'cae' category. To load a software of this category, use: module load cae/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
ABAQUS	2018, 2021	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Finite Element Analysis software for modeling, visualization and best-in-class implicit and explicit dynamics FEA.
OpenFOAM-Extend	4.1-20200408	2019b	broadwell, skylake	iris	OpenFOAM is a free, open source CFD software package. OpenFOAM has an extensive range of features to solve anything from complex fluid flows involving chemical reactions, turbulence and heat transfer, to solid dynamics and electromagnetics.
OpenFOAM	8, v1912	2020b, 2019b	epyc, broadwell, skylake	aion, iris	OpenFOAM is a free, open source CFD software package. OpenFOAM has an extensive range of features to solve anything from complex fluid flows involving chemical reactions, turbulence and heat transfer, to solid dynamics and electromagnetics.
Salome	8.5.0, 9.8.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	The SALOME platform is an open source software framework for pre- and post-processing and integration of numerical solvers from various scientific fields. CEA and EDF use SALOME to perform a large number of simulations, typically related to power plant equipment and alternative energy. To address these challenges, SALOME includes a CAD/CAE modelling tool, mesh generators, an advanced 3D visualization tool, etc.
gmsh	4.4.0	2019b	broadwell, skylake	iris	Salome is an open-source software that provides a generic Pre- and Post-Processing platform for numerical simulation. It is based on an open and flexible architecture made of reusable components.

Chemistry

Alphabetical list of available ULHPC software belonging to the 'chem' category. To load a software of this category, use: module load chem/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
ABINIT	9.4.1	2020b	epyc	aion	ABINIT is a package whose main program allows one to find the total energy, charge density and electronic structure of systems made of electrons and nuclei (molecules and periodic solids) within Density Functional Theory (DFT), using pseudopotentials and a planewave or wavelet basis.
ASE	3.19.0, 3.20.1, 3.21.1	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	ASE is a python package providing an open source Atomic Simulation Environment in the Python scripting language. From version 3.20.1 we also include the ase-ext package, it contains optional reimplementations in C of functions in ASE. ASE uses it automatically when installed.
CRYSTAL	17	2019b	broadwell, skylake	iris	The CRYSTAL package performs ab initio calculations of the ground state energy, energy gradient, electronic wave function and properties of periodic systems. Hartree-Fock or Kohn- Sham Hamiltonians (that adopt an Exchange-Correlation potential following the postulates of Density-Functional Theory) can be used.
GPAW-setups	0.9.20000	2019b	broadwell, skylake	iris	PAW setup for the GPAW Density Functional Theory package. Users can install setups manually using 'gpaw install-data' or use setups from this package. The versions of GPAW and GPAW-setups can be intermixed.
GPAW	20.1.0	2019b	broadwell, skylake	iris	GPAW is a density-functional theory (DFT) Python code based on the projector-augmented wave (PAW) method and the atomic simulation environment (ASE). It uses real-space uniform grids and multigrid methods or atom-centered basis-functions.
NAMD	2.13	2019b	broadwell, skylake	iris	NAMD is a parallel molecular dynamics code designed for high-performance simulation of large biomolecular systems.
PLUMED	2.5.3, 2.7.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	PLUMED is an open source library for free energy calculations in molecular systems which works together with some of the most popular molecular dynamics engines. Free energy calculations can be performed as a function of many order parameters with a particular focus on biological problems, using state of the art methods such as metadynamics, umbrella sampling and Jarzynski-equation based steered MD. The software, written in C++, can be easily interfaced with both fortran and C/C++ codes.
QuantumESPRESSO	6.7	2019b, 2020b	broadwell, epyc, skylake	iris, aion	Quantum ESPRESSO is an integrated suite of computer codes for electronic-structure calculations and materials modeling at the nanoscale. It is based on density-functional theory, plane waves, and pseudopotentials (both norm-conserving and ultrasoft).
Wannier90	3.1.0	2020b	broadwell, epyc, skylake	aion, iris	A tool for obtaining maximally-localised Wannier functions
kim-api	2.1.3	2019b	broadwell, skylake	iris	Open Knowledgebase of Interatomic Models. KIM is an API and OpenKIM is a collection of interatomic models (potentials) for atomistic simulations. This is a library that can be used by simulation programs to get access to the models in the OpenKIM database. This EasyBuild only installs the API, the models can be installed with the package openkim-models, or the user can install them manually by running kim-api-collections-management install user MODELNAME or kim-api-collections-management install user OpenKIM to install them all.
libctl	4.0.0	2019b	broadwell, skylake	iris	libctl is a free Guile-based library implementing flexible control files for scientific simulations.
libxc	4.3.4, 5.1.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libxc is a library of exchange-correlation functionals for density-functional theory. The aim is to provide a portable, well tested and reliable set of exchange and correlation functionals.
spglib-python	1.16.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Spglib for Python. Spglib is a library for finding and handling crystal symmetries written in C.
yaff	1.6.0	2019b	broadwell, skylake	iris	Yaff stands for 'Yet another force field'. It is a pythonic force-field code.

Compilers

Alphabetical list of available ULHPC software belonging to the 'compiler' category. To load a software of this category, use: module load compiler/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
AOCC	3.1.0	2020b	epyc	aion	AMD Optimized C/C++ & Fortran compilers (AOCC) based on LLVM 12.0
Clang	11.0.1, 9.0.1	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	C, C++, Objective-C compiler, based on LLVM. Does not include C++ standard library -- use libstdc++ from GCC.
GCC	10.2.0, 8.3.0	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Java, and Ada, as well as libraries for these languages (libstdc++, libgcj,...).
GCCcore	10.2.0, 8.3.0	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Java, and Ada, as well as libraries for these languages (libstdc++, libgcj,...).
Go	1.14.1, 1.16.6	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.
LLVM	10.0.1, 11.0.0, 9.0.0, 9.0.1	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	The LLVM Core libraries provide a modern source- and target-independent optimizer, along with code generation support for many popular CPUs (as well as some less common ones!) These libraries are built around a well specified code representation known as the LLVM intermediate representation ("LLVM IR"). The LLVM Core libraries are well documented, and it is particularly easy to invent your own language (or port an existing compiler) to use LLVM as an optimizer and code generator.
PGI	19.10	2019b	broadwell, skylake	iris	C, C++ and Fortran compilers from The Portland Group - PGI
iccifort	2019.5.281, 2020.4.304	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Intel C, C++ & Fortran compilers

Data processing

Alphabetical list of available ULHPC software belonging to the 'data' category. To load a software of this category, use: module load data/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
Arrow	0.16.0	2019b	broadwell, skylake	iris	Apache Arrow (incl. PyArrow Python bindings)), a cross-language development platform for in-memory data.
DB_File	1.855	2020b	broadwell, epyc, skylake	aion, iris	Perl5 access to Berkeley DB version 1.x.
GDAL	3.0.2, 3.2.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	GDAL is a translator library for raster geospatial data formats that is released under an X/MIT style Open Source license by the Open Source Geospatial Foundation. As a library, it presents a single abstract data model to the calling application for all supported formats. It also comes with a variety of useful commandline utilities for data translation and processing.
HDF5	1.10.5, 1.10.7	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	HDF5 is a data model, library, and file format for storing and managing data. It supports an unlimited variety of datatypes, and is designed for flexible and efficient I/O and for high volume and complex data.
HDF	4.2.15	2020b	broadwell, epyc, skylake, gpu	aion, iris	HDF (also known as HDF4) is a library and multi-object file format for storing and managing data between machines.
LAME	3.100	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	LAME is a high quality MPEG Audio Layer III (MP3) encoder licensed under the LGPL.
XML-LibXML	2.0201, 2.0206	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Perl binding for libxml2
dask	2021.2.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Dask natively scales Python. Dask provides advanced parallelism for analytics, enabling performance at scale for the tools you love.
h5py	2.10.0, 3.1.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	HDF5 for Python (h5py) is a general-purpose Python interface to the Hierarchical Data Format library, version 5. HDF5 is a versatile, mature scientific software library designed for the fast, flexible storage of enormous amounts of data.
netCDF-Fortran	4.5.2, 4.5.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	NetCDF (network Common Data Form) is a set of software libraries and machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.
netCDF	4.7.1, 4.7.4	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	NetCDF (network Common Data Form) is a set of software libraries and machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.
scikit-learn	0.23.2	2020b	broadwell, epyc, skylake, gpu	aion, iris	Scikit-learn integrates machine learning algorithms in the tightly-knit scientific Python world, building upon numpy, scipy, and matplotlib. As a machine-learning module, it provides versatile tools for data mining and analysis in any field of science and engineering. It strives to be simple and efficient, accessible to everybody, and reusable in various contexts.

Debugging

Alphabetical list of available ULHPC software belonging to the 'debugger' category. To load a software of this category, use: module load debugger/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
GDB	10.1, 9.1	2020b, 2019b	broadwell, epyc, skylake	aion, iris	The GNU Project Debugger
Valgrind	3.15.0, 3.16.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Valgrind: Debugging and profiling tools

Development

Alphabetical list of available ULHPC software belonging to the 'devel' category. To load a software of this category, use: module load devel/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
Autoconf	2.69	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Autoconf is an extensible package of M4 macros that produce shell scripts to automatically configure software source code packages. These scripts can adapt the packages to many kinds of UNIX-like systems without manual user intervention. Autoconf creates a configuration script for a package from a template file that lists the operating system features that the package can use, in the form of M4 macro calls.
Automake	1.16.1, 1.16.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Automake: GNU Standards-compliant Makefile generator
Autotools	20180311, 20200321	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	This bundle collect the standard GNU build tools: Autoconf, Automake and libtool
Bazel	0.26.1, 0.29.1, 3.7.2	2019b, 2020b	gpu, broadwell, skylake, epyc	iris, aion	Bazel is a build tool that builds code quickly and reliably. It is used to build the majority of Google's software.
Boost	1.71.0, 1.74.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Boost provides free peer-reviewed portable C++ source libraries.
CMake	3.15.3, 3.18.4, 3.20.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	CMake, the cross-platform, open-source build system. CMake is a family of tools designed to build, test and package software.
DBus	1.13.12, 1.13.18	2019b, 2020b	broadwell, skylake, epyc	iris, aion	D-Bus is a message bus system, a simple way for applications to talk to one another. In addition to interprocess communication, D-Bus helps coordinate process lifecycle; it makes it simple and reliable to code a "single instance" application or daemon, and to launch applications and daemons on demand when their services are needed.
Doxygen	1.8.16, 1.8.20	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Doxygen is a documentation system for C++, C, Java, Objective-C, Python, IDL (Corba and Microsoft flavors), Fortran, VHDL, PHP, C#, and to some extent D.
Flink	1.11.2	2020b	broadwell, epyc, skylake	aion, iris	Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams. Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.
GObject-Introspection	1.63.1, 1.66.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	GObject introspection is a middleware layer between C libraries (using GObject) and language bindings. The C library can be scanned at compile time and generate a metadata file, in addition to the actual native C library. Then at runtime, language bindings can read this metadata and automatically provide bindings to call into the C library.
M4	1.4.18	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	GNU M4 is an implementation of the traditional Unix macro processor. It is mostly SVR4 compatible although it has some extensions (for example, handling more than 9 positional parameters to macros). GNU M4 also has built-in functions for including files, running shell commands, doing arithmetic, etc.
Mako	1.1.0, 1.1.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	A super-fast templating language that borrows the best ideas from the existing templating languages
Maven	3.6.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Binary maven install, Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information.
PCRE2	10.33, 10.35	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.
PCRE	8.43, 8.44	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.
PyTorch	1.4.0, 1.7.1, 1.8.1, 1.9.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Tensors and Dynamic neural networks in Python with strong GPU acceleration. PyTorch is a deep learning framework that puts Python first.
Qt5	5.13.1, 5.14.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Qt is a comprehensive cross-platform C++ application framework.
ReFrame	2.21, 3.6.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	ReFrame is a framework for writing regression tests for HPC systems.
SQLite	3.29.0, 3.33.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	SQLite: SQL Database Engine in a C Library
SWIG	4.0.1, 4.0.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	SWIG is a software development tool that connects programs written in C and C++ with a variety of high-level programming languages.
Spack	0.12.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Spack is a package manager for supercomputers, Linux, and macOS. It makes installing scientific software easy. With Spack, you can build a package with multiple versions, configurations, platforms, and compilers, and all of these builds can coexist on the same machine.
Spark	2.4.3	2019b	broadwell, skylake	iris	Spark is Hadoop MapReduce done in memory
ant	1.10.6, 1.10.7, 1.10.9	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Apache Ant is a Java library and command-line tool whose mission is to drive processes described in build files as targets and extension points dependent upon each other. The main known usage of Ant is the build of Java applications.
flatbuffers-python	1.12	2020b	broadwell, epyc, skylake, gpu	aion, iris	Python Flatbuffers runtime library.
flatbuffers	1.12.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	FlatBuffers: Memory Efficient Serialization Library
gflags	2.2.2	2019b	broadwell, skylake	iris	The gflags package contains a C++ library that implements commandline flags processing. It includes built-in support for standard types such as string and the ability to define flags in the source file in which they are used.
glog	0.4.0	2019b	broadwell, skylake	iris	A C++ implementation of the Google logging module.
googletest	1.10.0	2019b	broadwell, skylake	iris	Google's framework for writing C++ tests on a variety of platforms
gperf	3.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	GNU gperf is a perfect hash function generator. For a given list of strings, it produces a hash function and hash table, in form of C or C++ code, for looking up a value depending on the input string. The hash function is perfect, which means that the hash table has no collisions, and the hash table lookup needs a single string comparison only.
intltool	0.51.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	intltool is a set of tools to centralize translation of many different file formats using GNU gettext-compatible PO files.
makeinfo	6.7	2020b	broadwell, epyc, skylake, gpu	aion, iris	makeinfo is part of the Texinfo project, the official documentation format of the GNU project.
ncurses	6.0, 6.1, 6.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The Ncurses (new curses) library is a free software emulation of curses in System V Release 4.0, and more. It uses Terminfo format, supports pads and color and multiple highlights and forms characters and function-key mapping, and has all the other SYSV-curses enhancements over BSD Curses.
nsync	1.24.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	nsync is a C library that exports various synchronization primitives, such as mutexes
pkg-config	0.29.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	pkg-config is a helper tool used when compiling applications and libraries. It helps you insert the correct compiler options on the command line so an application can use gcc -o test test.c pkg-config --libs --cflags glib-2.0 for instance, rather than hard-coding values on where to find glib (or other libraries).
pkgconfig	1.5.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	pkgconfig is a Python module to interface with the pkg-config command line tool
protobuf-python	3.10.0, 3.14.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Python Protocol Buffers runtime library.
protobuf	2.5.0, 3.10.0, 3.14.0	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Google Protocol Buffers
setuptools	41.0.1	2019b	broadwell, skylake	iris	Easily download, build, install, upgrade, and uninstall Python packages
sparsehash	2.0.3, 2.0.4	2019b, 2020b	broadwell, skylake, epyc	iris, aion	An extremely memory-efficient hash_map implementation. 2 bits/entry overhead! The SparseHash library contains several hash-map implementations, including implementations that optimize for space or speed.
texinfo	6.7	2019b	broadwell, skylake	iris	Texinfo is the official documentation format of the GNU project.
typing-extensions	3.7.4.3	2019b, 2020b	gpu, broadwell, epyc, skylake	iris, aion	Typing Extensions – Backported and Experimental Type Hints for Python
xorg-macros	1.19.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	X.org macros utilities.

Programming Languages

Alphabetical list of available ULHPC software belonging to the 'lang' category. To load a software of this category, use: module load lang/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
Anaconda3	2020.02, 2020.11	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Built to complement the rich, open source Python community, the Anaconda platform provides an enterprise-ready data analytics platform that empowers companies to adopt a modern open data science analytics architecture.
Bison	3.3.2, 3.5.3, 3.7.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Bison is a general-purpose parser generator that converts an annotated context-free grammar into a deterministic LR or generalized LR (GLR) parser employing LALR(1) parser tables.
FriBidi	1.0.10, 1.0.5	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	The Free Implementation of the Unicode Bidirectional Algorithm.
Guile	1.8.8, 2.2.4	2019b	broadwell, skylake	iris	Guile is a programming language, designed to help programmers create flexible applications that can be extended by users or other programmers with plug-ins, modules, or scripts.
Java	1.8.0_241, 11.0.2, 13.0.2, 16.0.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Java Platform, Standard Edition (Java SE) lets you develop and deploy Java applications on desktops and servers.
Julia	1.4.1, 1.6.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Julia is a high-level, high-performance dynamic programming language for numerical computing
Lua	5.1.5, 5.4.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Lua is a powerful, fast, lightweight, embeddable scripting language. Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode for a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping.
NASM	2.14.02, 2.15.05	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	NASM: General-purpose x86 assembler
Perl	5.30.0, 5.32.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Larry Wall's Practical Extraction and Report Language This is a minimal build without any modules. Should only be used for build dependencies.
Python	2.7.16, 2.7.18, 3.7.4, 3.8.6	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Python is a programming language that lets you work more quickly and integrate your systems more effectively.
R	3.6.2, 4.0.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	R is a free software environment for statistical computing and graphics.
Ruby	2.7.1, 2.7.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Ruby is a dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write.
Rust	1.37.0	2019b	broadwell, skylake	iris	Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.
SciPy-bundle	2019.10, 2020.11	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Bundle of Python packages for scientific software
Tcl	8.6.10, 8.6.9	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Tcl (Tool Command Language) is a very powerful but easy to learn dynamic programming language, suitable for a very wide range of uses, including web and desktop applications, networking, administration, testing and many more.
Tkinter	3.7.4, 3.8.6	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Tkinter module, built with the Python buildsystem
Yasm	1.3.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Yasm: Complete rewrite of the NASM assembler with BSD license
flex	2.6.4	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Flex (Fast Lexical Analyzer) is a tool for generating scanners. A scanner, sometimes called a tokenizer, is a program which recognizes lexical patterns in text.
nodejs	12.19.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Node.js is a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.
numba	0.52.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Numba is an Open Source NumPy-aware optimizing compiler for Python sponsored by Continuum Analytics, Inc. It uses the remarkable LLVM compiler infrastructure to compile Python syntax to machine code.

Libraries

Alphabetical list of available ULHPC software belonging to the 'lib' category. To load a software of this category, use: module load lib/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
ACTC	1.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	ACTC converts independent triangles into triangle strips or fans.
Boost.Python	1.74.0	2020b	broadwell, epyc, skylake	aion, iris	Boost.Python is a C++ library which enables seamless interoperability between C++ and the Python programming language.
Check	0.15.2	2020b	gpu	iris	Check is a unit testing framework for C. It features a simple interface for defining unit tests, putting little in the way of the developer. Tests are run in a separate address space, so both assertion failures and code errors that cause segmentation faults or other signals can be caught. Test results are reportable in the following: Subunit, TAP, XML, and a generic logging format.
FLAC	1.3.3	2020b	broadwell, epyc, skylake, gpu	aion, iris	FLAC stands for Free Lossless Audio Codec, an audio format similar to MP3, but lossless, meaning that audio is compressed in FLAC without any loss in quality.
Flask	1.1.2	2020b	broadwell, epyc, skylake, gpu	aion, iris	Flask is a lightweight WSGI web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications. This module includes the Flask extensions: Flask-Cors
GDRCopy	2.1	2020b	gpu	iris	A low-latency GPU memory copy library based on NVIDIA GPUDirect RDMA technology.
ICU	64.2, 67.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	ICU is a mature, widely used set of C/C++ and Java libraries providing Unicode and Globalization support for software applications.
JsonCpp	1.9.3, 1.9.4	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	JsonCpp is a C++ library that allows manipulating JSON values, including serialization and deserialization to and from strings. It can also preserve existing comment in unserialization/serialization steps, making it a convenient format to store user input files.
LMDB	0.9.24	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	LMDB is a fast, memory-efficient database. With memory-mapped files, it has the read performance of a pure in-memory database while retaining the persistence of standard disk-based databases.
LibTIFF	4.0.10, 4.1.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	tiff: Library and tools for reading and writing TIFF data files
NCCL	2.4.8, 2.8.3	2019b, 2020b	gpu	iris	The NVIDIA Collective Communications Library (NCCL) implements multi-GPU and multi-node collective communication primitives that are performance optimized for NVIDIA GPUs.
NSPR	4.21, 4.29	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Netscape Portable Runtime (NSPR) provides a platform-neutral API for system level and libc-like functions.
NSS	3.45, 3.57	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Network Security Services (NSS) is a set of libraries designed to support cross-platform development of security-enabled client and server applications.
PROJ	6.2.1, 7.2.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Program proj is a standard Unix filter function which converts geographic longitude and latitude coordinates into cartesian coordinates
PyTorch-Geometric	1.6.3	2020b	broadwell, epyc, skylake, gpu	aion, iris	PyTorch Geometric (PyG) is a geometric deep learning extension library for PyTorch.
PyYAML	5.1.2, 5.3.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	PyYAML is a YAML parser and emitter for the Python programming language.
RDFlib	5.0.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	RDFLib is a Python library for working with RDF, a simple yet powerful language for representing information.
SDL2	2.0.14	2020b	broadwell, epyc, skylake	aion, iris	SDL: Simple DirectMedia Layer, a cross-platform multimedia library
SIONlib	1.7.6	2019b	broadwell, skylake	iris	SIONlib is a scalable I/O library for parallel access to task-local files. The library not only supports writing and reading binary data to or from several thousands of processors into a single or a small number of physical files, but also provides global open and close functions to access SIONlib files in parallel. This package provides a stripped-down installation of SIONlib for use with performance tools (e.g., Score-P), with renamed symbols to avoid conflicts when an application using SIONlib itself is linked against a tool requiring a different SIONlib version.
TensorFlow	1.15.5, 2.1.0, 2.4.1, 2.5.0	2019b, 2020b	gpu, broadwell, skylake, epyc	iris, aion	An open-source software library for Machine Intelligence
UCX	1.9.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Unified Communication X An open-source production grade communication framework for data centric and high-performance applications
Xerces-C++	3.2.2	2019b	broadwell, skylake	iris	Xerces-C++ is a validating XML parser written in a portable subset of C++. Xerces-C++ makes it easy to give your application the ability to read and write XML data. A shared library is provided for parsing, generating, manipulating, and validating XML documents using the DOM, SAX, and SAX2 APIs.
YACS	0.1.8	2020b	broadwell, epyc, skylake	aion, iris	YACS was created as a lightweight library to define and manage system configurations, such as those commonly found in software designed for scientific experimentation. These "configurations" typically cover concepts like hyperparameters used in training a machine learning model or configurable model hyperparameters, such as the depth of a convolutional neural network.
double-conversion	3.1.4, 3.1.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Efficient binary-decimal and decimal-binary conversion routines for IEEE doubles.
elfutils	0.183	2020b	gpu	iris	The elfutils project provides libraries and tools for ELF files and DWARF data.
gc	7.6.12	2019b	broadwell, skylake	iris	The Boehm-Demers-Weiser conservative garbage collector can be used as a garbage collecting replacement for C malloc or C++ new.
giflib	5.2.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	giflib is a library for reading and writing gif images. It is API and ABI compatible with libungif which was in wide use while the LZW compression algorithm was patented.
jemalloc	5.2.1	2019b	broadwell, skylake	iris	jemalloc is a general purpose malloc(3) implementation that emphasizes fragmentation avoidance and scalable concurrency support.
libdrm	2.4.102, 2.4.99	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Direct Rendering Manager runtime library.
libepoxy	1.5.4	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Epoxy is a library for handling OpenGL function pointer management for you
libevent	2.1.11, 2.1.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	The libevent API provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached. Furthermore, libevent also support callbacks due to signals or regular timeouts.
libffi	3.2.1, 3.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The libffi library provides a portable, high level programming interface to various calling conventions. This allows a programmer to call any function specified by a call interface description at run-time.
libgd	2.2.5, 2.3.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	GD is an open source code library for the dynamic creation of images by programmers.
libgeotiff	1.5.1, 1.6.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Library for reading and writing coordinate system information from/to GeoTIFF files
libglvnd	1.2.0, 1.3.2	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	libglvnd is a vendor-neutral dispatch layer for arbitrating OpenGL API calls between multiple vendors.
libgpuarray	0.7.6	2019b, 2020b	gpu	iris	Library to manipulate tensors on the GPU.
libiconv	1.16	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libiconv converts from one character encoding to another through Unicode conversion
libjpeg-turbo	2.0.3, 2.0.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	libjpeg-turbo is a fork of the original IJG libjpeg which uses SIMD to accelerate baseline JPEG compression and decompression. libjpeg is a library that implements JPEG image encoding, decoding and transcoding.
libmatheval	1.1.11	2019b	broadwell, skylake	iris	GNU libmatheval is a library (callable from C and Fortran) to parse and evaluate symbolic expressions input as text.
libogg	1.3.4	2020b	broadwell, epyc, skylake, gpu	aion, iris	Ogg is a multimedia container format, and the native file and stream format for the Xiph.org multimedia codecs.
libpng	1.6.37	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	libpng is the official PNG reference library
libreadline	8.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The GNU Readline library provides a set of functions for use by applications that allow users to edit command lines as they are typed in. Both Emacs and vi editing modes are available. The Readline library includes additional functions to maintain a list of previously-entered command lines, to recall and perhaps reedit those lines, and perform csh-like history expansion on previous commands.
libsndfile	1.0.28	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libsndfile is a C library for reading and writing files containing sampled sound (such as MS Windows WAV and the Apple/SGI AIFF format) through one standard library interface.
libtirpc	1.3.1	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libtirpc is a port of Suns Transport-Independent RPC library to Linux.
libtool	2.4.6	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	GNU libtool is a generic library support script. Libtool hides the complexity of using shared libraries behind a consistent, portable interface.
libunistring	0.9.10	2019b	broadwell, skylake	iris	This library provides functions for manipulating Unicode strings and for manipulating C strings according to the Unicode standard.
libunwind	1.3.1, 1.4.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The primary goal of libunwind is to define a portable and efficient C programming interface (API) to determine the call-chain of a program. The API additionally provides the means to manipulate the preserved (callee-saved) state of each call-frame and to resume execution at any point in the call-chain (non-local goto). The API supports both local (same-process) and remote (across-process) operation. As such, the API is useful in a number of applications
libvorbis	1.3.7	2020b	broadwell, epyc, skylake, gpu	aion, iris	Ogg Vorbis is a fully open, non-proprietary, patent-and-royalty-free, general-purpose compressed audio format
libwebp	1.1.0	2020b	broadwell, epyc, skylake	aion, iris	WebP is a modern image format that provides superior lossless and lossy compression for images on the web. Using WebP, webmasters and web developers can create smaller, richer images that make the web faster.
libxml2	2.9.10, 2.9.9	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Libxml2 is the XML C parser and toolchain developed for the Gnome project (but usable outside of the Gnome platform).
libxslt	1.1.34	2019b	broadwell, skylake	iris	Libxslt is the XSLT C library developed for the GNOME project (but usable outside of the Gnome platform).
libyaml	0.2.2, 0.2.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	LibYAML is a YAML parser and emitter written in C.
lxml	4.4.2	2019b	broadwell, skylake	iris	The lxml XML toolkit is a Pythonic binding for the C libraries libxml2 and libxslt.
lz4	1.9.2	2020b	broadwell, epyc, skylake, gpu	aion, iris	LZ4 is lossless compression algorithm, providing compression speed at 400 MB/s per core. It features an extremely fast decoder, with speed in multiple GB/s per core.
nettle	3.5.1, 3.6	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Nettle is a cryptographic library that is designed to fit easily in more or less any context: In crypto toolkits for object-oriented languages (C++, Python, Pike, ...), in applications like LSH or GNUPG, or even in kernel space.
phonopy	2.2.0	2019b	broadwell, skylake	iris	Phonopy is an open source package of phonon calculations based on the supercell approach.
pocl	1.4, 1.6	2019b, 2020b	gpu	iris	Pocl is a portable open source (MIT-licensed) implementation of the OpenCL standard
pybind11	2.4.3, 2.6.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	pybind11 is a lightweight header-only library that exposes C++ types in Python and vice versa, mainly to create Python bindings of existing C++ code.
scikit-build	0.11.1	2020b	broadwell, epyc, skylake, gpu	aion, iris	Scikit-Build, or skbuild, is an improved build system generator for CPython C/C++/Fortran/Cython extensions.
snappy	1.1.7, 1.1.8	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Snappy is a compression/decompression library. It does not aim for maximum compression, or compatibility with any other compression library; instead, it aims for very high speeds and reasonable compression.
tbb	2019_U9, 2020.2, 2020.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Intel(R) Threading Building Blocks (Intel(R) TBB) lets you easily write parallel C++ programs that take full advantage of multicore performance, that are portable, composable and have future-proof scalability.
tqdm	4.56.2	2020b	broadwell, epyc, skylake, gpu	aion, iris	A fast, extensible progress bar for Python and CLI
zlib	1.2.11	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	zlib is designed to be a free, general-purpose, legally unencumbered -- that is, not covered by any patents -- lossless data-compression library for use on virtually any computer hardware and operating system.
zstd	1.4.5	2020b	broadwell, epyc, skylake, gpu	aion, iris	Zstandard is a real-time compression algorithm, providing high compression ratios. It offers a very wide range of compression/speed trade-off, while being backed by a very fast decoder. It also offers a special mode for small data, called dictionary compression, and can create dictionaries from any sample set.


Mathematics

Alphabetical list of available ULHPC software belonging to the 'math' category. To load a software of this category, use: module load math/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
CPLEX	12.10	2019b	broadwell, skylake	iris	IBM ILOG CPLEX Optimizer's mathematical programming technology enables analytical decision support for improving efficiency, reducing costs, and increasing profitability.
Dakota	6.11.0, 6.15.0	2019b, 2020b	broadwell, skylake	iris	The Dakota project delivers both state-of-the-art research and robust, usable software for optimization and UQ. Broadly, the Dakota software's advanced parametric analyses enable design exploration, model calibration, risk analysis, and quantification of margins and uncertainty with computational models."
ELPA	2019.11.001, 2020.11.001	2019b, 2020b	broadwell, epyc, skylake	iris, aion	Eigenvalue SoLvers for Petaflop-Applications .
Eigen	3.3.7, 3.3.8, 3.4.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.
GEOS	3.8.0, 3.9.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	GEOS (Geometry Engine - Open Source) is a C++ port of the Java Topology Suite (JTS)
GMP	6.1.2, 6.2.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	GMP is a free library for arbitrary precision arithmetic, operating on signed integers, rational numbers, and floating point numbers.
Gurobi	9.0.0, 9.1.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	The Gurobi Optimizer is a state-of-the-art solver for mathematical programming. The solvers in the Gurobi Optimizer were designed from the ground up to exploit modern architectures and multi-core processors, using the most advanced implementations of the latest algorithms.
Harminv	1.4.1	2019b	broadwell, skylake	iris	Harminv is a free program (and accompanying library) to solve the problem of harmonic inversion - given a discrete-time, finite-length signal that consists of a sum of finitely-many sinusoids (possibly exponentially decaying) in a given bandwidth, it determines the frequencies, decay constants, amplitudes, and phases of those sinusoids.
ISL	0.23	2020b	broadwell, epyc, skylake	aion, iris	isl is a library for manipulating sets and relations of integer points bounded by linear constraints.
Keras	2.3.1, 2.4.3	2019b, 2020b	gpu, broadwell, epyc, skylake	iris, aion	Keras is a deep learning API written in Python, running on top of the machine learning platform TensorFlow.
MATLAB	2019b, 2020a, 2021a	2019b, 2020b	broadwell, skylake, epyc	iris, aion	MATLAB is a high-level language and interactive environment that enables you to perform computationally intensive tasks faster than with traditional programming languages such as C, C++, and Fortran.
METIS	5.1.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	METIS is a set of serial programs for partitioning graphs, partitioning finite element meshes, and producing fill reducing orderings for sparse matrices. The algorithms implemented in METIS are based on the multilevel recursive-bisection, multilevel k-way, and multi-constraint partitioning schemes.
MPC	1.2.1	2020b	broadwell, epyc, skylake	aion, iris	Gnu Mpc is a C library for the arithmetic of complex numbers with arbitrarily high precision and correct rounding of the result. It extends the principles of the IEEE-754 standard for fixed precision real floating point numbers to complex numbers, providing well-defined semantics for every operation. At the same time, speed of operation at high precision is a major design goal.
MPFR	4.0.2, 4.1.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The MPFR library is a C library for multiple-precision floating-point computations with correct rounding.
MUMPS	5.3.5	2020b	broadwell, epyc, skylake	aion, iris	A parallel sparse direct solver
Mathematica	12.0.0, 12.1.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematica is a computational software program used in many scientific, engineering, mathematical and computing fields.
Mesquite	2.3.0	2019b	broadwell, skylake	iris	Mesh-Quality Improvement Library
ParMETIS	4.0.3	2019b	broadwell, skylake	iris	ParMETIS is an MPI-based parallel library that implements a variety of algorithms for partitioning unstructured graphs, meshes, and for computing fill-reducing orderings of sparse matrices. ParMETIS extends the functionality provided by METIS and includes routines that are especially suited for parallel AMR computations and large scale numerical simulations. The algorithms implemented in ParMETIS are based on the parallel multilevel k-way graph-partitioning, adaptive repartitioning, and parallel multi-constrained partitioning schemes.
ParMGridGen	1.0	2019b	broadwell, skylake	iris	ParMGridGen is an MPI-based parallel library that is based on the serial package MGridGen, that implements (serial) algorithms for obtaining a sequence of successive coarse grids that are well-suited for geometric multigrid methods.
SCOTCH	6.0.9, 6.1.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Software package and libraries for sequential and parallel graph partitioning, static mapping, and sparse matrix block ordering, and sequential mesh and hypergraph partitioning.
Stata	17	2020b	broadwell, epyc, skylake	aion, iris	Stata is a complete, integrated statistical software package that provides everything you need for data analysis, data management, and graphics.
Theano	1.0.4, 1.1.2	2019b, 2020b	gpu, broadwell, epyc, skylake	iris, aion	Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently.
Voro++	0.4.6	2019b	broadwell, skylake	iris	Voro++ is a software library for carrying out three-dimensional computations of the Voronoi tessellation. A distinguishing feature of the Voro++ library is that it carries out cell-based calculations, computing the Voronoi cell for each particle individually. It is particularly well-suited for applications that rely on cell-based statistics, where features of Voronoi cells (eg. volume, centroid, number of faces) can be used to analyze a system of particles.
gmsh	4.8.4	2020b	broadwell, epyc, skylake	aion, iris	Gmsh is a 3D finite element grid generator with a build-in CAD engine and post-processor.
libcerf	1.13, 1.14	2019b, 2020b	broadwell, skylake, epyc	iris, aion	libcerf is a self-contained numeric library that provides an efficient and accurate implementation of complex error functions, along with Dawson, Faddeeva, and Voigt functions.
magma	2.5.1, 2.5.4	2019b, 2020b	gpu	iris	The MAGMA project aims to develop a dense linear algebra library similar to LAPACK but for heterogeneous/hybrid architectures, starting with current Multicore+GPU systems.
molmod	1.4.5	2019b	broadwell, skylake	iris	MolMod is a Python library with many compoments that are useful to write molecular modeling programs.
scipy	1.4.1	2019b	broadwell, skylake, gpu	iris	SciPy is a collection of mathematical algorithms and convenience functions built on the Numpy extension for Python.


MPI

Alphabetical list of available ULHPC software belonging to the 'mpi' category. To load a software of this category, use: module load mpi/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
OpenMPI	3.1.4, 4.0.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The Open MPI Project is an open source MPI-3 implementation.
impi	2018.5.288, 2019.9.304	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Intel MPI Library, compatible with MPICH ABI

Full List (alphabetical order)

Software	Versions	Swsets	Architectures	Clusters	Category	Description
ABAQUS	2018, 2021	2019b, 2020b	broadwell, skylake, epyc	iris, aion	CFD/Finite element modelling	Finite Element Analysis software for modeling, visualization and best-in-class implicit and explicit dynamics FEA.
ABINIT	9.4.1	2020b	epyc	aion	Chemistry	ABINIT is a package whose main program allows one to find the total energy, charge density and electronic structure of systems made of electrons and nuclei (molecules and periodic solids) within Density Functional Theory (DFT), using pseudopotentials and a planewave or wavelet basis.
ABySS	2.2.5	2020b	broadwell, epyc, skylake	aion, iris	Biology	Assembly By Short Sequences - a de novo, parallel, paired-end sequence assembler
ACTC	1.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	ACTC converts independent triangles into triangle strips or fans.
ANSYS	19.4, 21.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	ANSYS simulation software enables organizations to confidently predict how their products will operate in the real world. We believe that every product is a promise of something greater.
AOCC	3.1.0	2020b	epyc	aion	Compilers	AMD Optimized C/C++ & Fortran compilers (AOCC) based on LLVM 12.0
ASE	3.19.0, 3.20.1, 3.21.1	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Chemistry	ASE is a python package providing an open source Atomic Simulation Environment in the Python scripting language. From version 3.20.1 we also include the ase-ext package, it contains optional reimplementations in C of functions in ASE. ASE uses it automatically when installed.
ATK	2.34.1, 2.36.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	ATK provides the set of accessibility interfaces that are implemented by other toolkits and applications. Using the ATK interfaces, accessibility tools have full access to view and control running applications.
Advisor	2019_update5	2019b	broadwell, skylake	iris	Performance measurements	Vectorization Optimization and Thread Prototyping - Vectorize & thread code or performance “dies” - Easy workflow + data + tips = faster code faster - Prioritize, Prototype & Predict performance gain
Anaconda3	2020.02, 2020.11	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Programming Languages	Built to complement the rich, open source Python community, the Anaconda platform provides an enterprise-ready data analytics platform that empowers companies to adopt a modern open data science analytics architecture.
ArmForge	20.0.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	The industry standard development package for C, C++ and Fortran high performance code on Linux. Forge is designed to handle the complex software projects - including parallel, multiprocess and multithreaded code. Arm Forge combines an industry-leading debugger, Arm DDT, and an out-of-the-box-ready profiler, Arm MAP.
ArmReports	20.0.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	Arm Performance Reports - a low-overhead tool that produces one-page text and HTML reports summarizing and characterizing both scalar and MPI application performance. Arm Performance Reports runs transparently on optimized production-ready codes by adding a single command to your scripts, and provides the most effective way to characterize and understand the performance of HPC application runs.
Armadillo	10.5.3, 9.900.1	2020b, 2019b	broadwell, epyc, skylake	aion, iris	Numerical libraries	Armadillo is an open-source C++ linear algebra library (matrix maths) aiming towards a good balance between speed and ease of use. Integer, floating point and complex numbers are supported, as well as a subset of trigonometric and statistics functions.
Arrow	0.16.0	2019b	broadwell, skylake	iris	Data processing	Apache Arrow (incl. PyArrow Python bindings)), a cross-language development platform for in-memory data.
Aspera-CLI	3.9.1, 3.9.6	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	IBM Aspera Command-Line Interface (the Aspera CLI) is a collection of Aspera tools for performing high-speed, secure data transfers from the command line. The Aspera CLI is for users and organizations who want to automate their transfer workflows.
Autoconf	2.69	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	Autoconf is an extensible package of M4 macros that produce shell scripts to automatically configure software source code packages. These scripts can adapt the packages to many kinds of UNIX-like systems without manual user intervention. Autoconf creates a configuration script for a package from a template file that lists the operating system features that the package can use, in the form of M4 macro calls.
Automake	1.16.1, 1.16.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	Automake: GNU Standards-compliant Makefile generator
Autotools	20180311, 20200321	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	This bundle collect the standard GNU build tools: Autoconf, Automake and libtool
BEDTools	2.29.2, 2.30.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	BEDTools: a powerful toolset for genome arithmetic. The BEDTools utilities allow one to address common genomics tasks such as finding feature overlaps and computing coverage. The utilities are largely based on four widely-used file formats: BED, GFF/GTF, VCF, and SAM/BAM.
BLAST+	2.11.0, 2.9.0	2020b, 2019b	broadwell, epyc, skylake	aion, iris	Biology	Basic Local Alignment Search Tool, or BLAST, is an algorithm for comparing primary biological sequence information, such as the amino-acid sequences of different proteins or the nucleotides of DNA sequences.
BWA	0.7.17	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	Burrows-Wheeler Aligner (BWA) is an efficient program that aligns relatively short nucleotide sequences against a long reference sequence such as the human genome.
BamTools	2.5.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	BamTools provides both a programmer's API and an end-user's toolkit for handling BAM files.
Bazel	0.26.1, 0.29.1, 3.7.2	2019b, 2020b	gpu, broadwell, skylake, epyc	iris, aion	Development	Bazel is a build tool that builds code quickly and reliably. It is used to build the majority of Google's software.
BioPerl	1.7.2, 1.7.8	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	Bioperl is the product of a community effort to produce Perl code which is useful in biology. Examples include Sequence objects, Alignment objects and database searching objects.
Bison	3.3.2, 3.5.3, 3.7.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Bison is a general-purpose parser generator that converts an annotated context-free grammar into a deterministic LR or generalized LR (GLR) parser employing LALR(1) parser tables.
Boost.Python	1.74.0	2020b	broadwell, epyc, skylake	aion, iris	Libraries	Boost.Python is a C++ library which enables seamless interoperability between C++ and the Python programming language.
Boost	1.71.0, 1.74.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	Boost provides free peer-reviewed portable C++ source libraries.
Bowtie2	2.3.5.1, 2.4.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters, and particularly good at aligning to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an FM Index to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 GB. Bowtie 2 supports gapped, local, and paired-end alignment modes.
CGAL	4.14.1, 5.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Numerical libraries	The goal of the CGAL Open Source Project is to provide easy access to efficient and reliable geometric algorithms in the form of a C++ library.
CMake	3.15.3, 3.18.4, 3.20.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	CMake, the cross-platform, open-source build system. CMake is a family of tools designed to build, test and package software.
CPLEX	12.10	2019b	broadwell, skylake	iris	Mathematics	IBM ILOG CPLEX Optimizer's mathematical programming technology enables analytical decision support for improving efficiency, reducing costs, and increasing profitability.
CRYSTAL	17	2019b	broadwell, skylake	iris	Chemistry	The CRYSTAL package performs ab initio calculations of the ground state energy, energy gradient, electronic wave function and properties of periodic systems. Hartree-Fock or Kohn- Sham Hamiltonians (that adopt an Exchange-Correlation potential following the postulates of Density-Functional Theory) can be used.
CUDA	10.1.243, 11.1.1	2019b, 2020b	gpu	iris	System-level software	CUDA (formerly Compute Unified Device Architecture) is a parallel computing platform and programming model created by NVIDIA and implemented by the graphics processing units (GPUs) that they produce. CUDA gives developers access to the virtual instruction set and memory of the parallel computational elements in CUDA GPUs.
CUDAcore	11.1.1	2020b	gpu	iris	System-level software	CUDA (formerly Compute Unified Device Architecture) is a parallel computing platform and programming model created by NVIDIA and implemented by the graphics processing units (GPUs) that they produce. CUDA gives developers access to the virtual instruction set and memory of the parallel computational elements in CUDA GPUs.
Check	0.15.2	2020b	gpu	iris	Libraries	Check is a unit testing framework for C. It features a simple interface for defining unit tests, putting little in the way of the developer. Tests are run in a separate address space, so both assertion failures and code errors that cause segmentation faults or other signals can be caught. Test results are reportable in the following: Subunit, TAP, XML, and a generic logging format.
Clang	11.0.1, 9.0.1	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Compilers	C, C++, Objective-C compiler, based on LLVM. Does not include C++ standard library -- use libstdc++ from GCC.
CubeGUI	4.4.4	2019b	broadwell, skylake	iris	Performance measurements	Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube graphical report explorer.
CubeLib	4.4.4	2019b	broadwell, skylake	iris	Performance measurements	Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube general purpose C++ library component and command-line tools.
CubeWriter	4.4.3	2019b	broadwell, skylake	iris	Performance measurements	Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube high-performance C writer library component.
DB	18.1.32, 18.1.40	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Utilities	Berkeley DB enables the development of custom data management solutions, without the overhead traditionally associated with such custom projects.
DB_File	1.855	2020b	broadwell, epyc, skylake	aion, iris	Data processing	Perl5 access to Berkeley DB version 1.x.
DBus	1.13.12, 1.13.18	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	D-Bus is a message bus system, a simple way for applications to talk to one another. In addition to interprocess communication, D-Bus helps coordinate process lifecycle; it makes it simple and reliable to code a "single instance" application or daemon, and to launch applications and daemons on demand when their services are needed.
DMTCP	2.5.2	2019b	broadwell, skylake	iris	Utilities	DMTCP is a tool to transparently checkpoint the state of multiple simultaneous applications, including multi-threaded and distributed applications. It operates directly on the user binary executable, without any Linux kernel modules or other kernel modifications.
Dakota	6.11.0, 6.15.0	2019b, 2020b	broadwell, skylake	iris	Mathematics	The Dakota project delivers both state-of-the-art research and robust, usable software for optimization and UQ. Broadly, the Dakota software's advanced parametric analyses enable design exploration, model calibration, risk analysis, and quantification of margins and uncertainty with computational models."
Doxygen	1.8.16, 1.8.20	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	Doxygen is a documentation system for C++, C, Java, Objective-C, Python, IDL (Corba and Microsoft flavors), Fortran, VHDL, PHP, C#, and to some extent D.
ELPA	2019.11.001, 2020.11.001	2019b, 2020b	broadwell, epyc, skylake	iris, aion	Mathematics	Eigenvalue SoLvers for Petaflop-Applications .
EasyBuild	4.3.0, 4.3.3, 4.4.1, 4.4.2, 4.5.4	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	EasyBuild is a software build and installation framework written in Python that allows you to install software in a structured, repeatable and robust way.
Eigen	3.3.7, 3.3.8, 3.4.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Mathematics	Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.
Elk	6.3.2, 7.0.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Physics	An all-electron full-potential linearised augmented-plane wave (FP-LAPW) code with many advanced features. Written originally at Karl-Franzens-Universität Graz as a milestone of the EXCITING EU Research and Training Network, the code is designed to be as simple as possible so that new developments in the field of density functional theory (DFT) can be added quickly and reliably.
FDS	6.7.1, 6.7.6	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Physics	Fire Dynamics Simulator (FDS) is a large-eddy simulation (LES) code for low-speed flows, with an emphasis on smoke and heat transport from fires.
FFTW	3.3.8	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Numerical libraries	FFTW is a C subroutine library for computing the discrete Fourier transform (DFT) in one or more dimensions, of arbitrary input size, and of both real and complex data.
FFmpeg	4.2.1, 4.3.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	A complete, cross-platform solution to record, convert and stream audio and video.
FLAC	1.3.3	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	FLAC stands for Free Lossless Audio Codec, an audio format similar to MP3, but lossless, meaning that audio is compressed in FLAC without any loss in quality.
FLTK	1.3.5	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	FLTK is a cross-platform C++ GUI toolkit for UNIX/Linux (X11), Microsoft Windows, and MacOS X. FLTK provides modern GUI functionality without the bloat and supports 3D graphics via OpenGL and its built-in GLUT emulation.
FastQC	0.11.9	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	FastQC is a quality control application for high throughput sequence data. It reads in sequence data in a variety of formats and can either provide an interactive application to review the results of several different QC checks, or create an HTML based report which can be integrated into a pipeline.
Flask	1.1.2	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Flask is a lightweight WSGI web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications. This module includes the Flask extensions: Flask-Cors
Flink	1.11.2	2020b	broadwell, epyc, skylake	aion, iris	Development	Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams. Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.
FreeImage	3.18.0	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	FreeImage is an Open Source library project for developers who would like to support popular graphics image formats like PNG, BMP, JPEG, TIFF and others as needed by today's multimedia applications. FreeImage is easy to use, fast, multithreading safe.
FriBidi	1.0.10, 1.0.5	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	The Free Implementation of the Unicode Bidirectional Algorithm.
GCC	10.2.0, 8.3.0	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Compilers	The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Java, and Ada, as well as libraries for these languages (libstdc++, libgcj,...).
GCCcore	10.2.0, 8.3.0	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Compilers	The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Java, and Ada, as well as libraries for these languages (libstdc++, libgcj,...).
GDAL	3.0.2, 3.2.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Data processing	GDAL is a translator library for raster geospatial data formats that is released under an X/MIT style Open Source license by the Open Source Geospatial Foundation. As a library, it presents a single abstract data model to the calling application for all supported formats. It also comes with a variety of useful commandline utilities for data translation and processing.
GDB	10.1, 9.1	2020b, 2019b	broadwell, epyc, skylake	aion, iris	Debugging	The GNU Project Debugger
GDRCopy	2.1	2020b	gpu	iris	Libraries	A low-latency GPU memory copy library based on NVIDIA GPUDirect RDMA technology.
GEOS	3.8.0, 3.9.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Mathematics	GEOS (Geometry Engine - Open Source) is a C++ port of the Java Topology Suite (JTS)
GLPK	4.65	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Utilities	The GLPK (GNU Linear Programming Kit) package is intended for solving large-scale linear programming (LP), mixed integer programming (MIP), and other related problems. It is a set of routines written in ANSI C and organized in the form of a callable library.
GLib	2.62.0, 2.66.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	GLib is one of the base libraries of the GTK+ project
GMP	6.1.2, 6.2.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Mathematics	GMP is a free library for arbitrary precision arithmetic, operating on signed integers, rational numbers, and floating point numbers.
GObject-Introspection	1.63.1, 1.66.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	GObject introspection is a middleware layer between C libraries (using GObject) and language bindings. The C library can be scanned at compile time and generate a metadata file, in addition to the actual native C library. Then at runtime, language bindings can read this metadata and automatically provide bindings to call into the C library.
GPAW-setups	0.9.20000	2019b	broadwell, skylake	iris	Chemistry	PAW setup for the GPAW Density Functional Theory package. Users can install setups manually using 'gpaw install-data' or use setups from this package. The versions of GPAW and GPAW-setups can be intermixed.
GPAW	20.1.0	2019b	broadwell, skylake	iris	Chemistry	GPAW is a density-functional theory (DFT) Python code based on the projector-augmented wave (PAW) method and the atomic simulation environment (ASE). It uses real-space uniform grids and multigrid methods or atom-centered basis-functions.
GROMACS	2019.4, 2019.6, 2020, 2021, 2021.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Biology	GROMACS is a versatile package to perform molecular dynamics, i.e. simulate the Newtonian equations of motion for systems with hundreds to millions of particles. This is a CPU only build, containing both MPI and threadMPI builds for both single and double precision. It also contains the gmxapi extension for the single precision MPI build.
GSL	2.6	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Numerical libraries	The GNU Scientific Library (GSL) is a numerical library for C and C++ programmers. The library provides a wide range of mathematical routines such as random number generators, special functions and least-squares fitting.
GTK+	3.24.13, 3.24.23	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	GTK+ is the primary library used to construct user interfaces in GNOME. It provides all the user interface controls, or widgets, used in a common graphical application. Its object-oriented API allows you to construct user interfaces without dealing with the low-level details of drawing and device interaction.
Gdk-Pixbuf	2.38.2, 2.40.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	The Gdk Pixbuf is a toolkit for image loading and pixel buffer manipulation. It is used by GTK+ 2 and GTK+ 3 to load and manipulate images. In the past it was distributed as part of GTK+ 2 but it was split off into a separate package in preparation for the change to GTK+ 3.
Ghostscript	9.50, 9.53.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Ghostscript is a versatile processor for PostScript data with the ability to render PostScript to different targets. It used to be part of the cups printing stack, but is no longer used for that.
Go	1.14.1, 1.16.6	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Compilers	Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.
Guile	1.8.8, 2.2.4	2019b	broadwell, skylake	iris	Programming Languages	Guile is a programming language, designed to help programmers create flexible applications that can be extended by users or other programmers with plug-ins, modules, or scripts.
Gurobi	9.0.0, 9.1.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematics	The Gurobi Optimizer is a state-of-the-art solver for mathematical programming. The solvers in the Gurobi Optimizer were designed from the ground up to exploit modern architectures and multi-core processors, using the most advanced implementations of the latest algorithms.
HDF5	1.10.5, 1.10.7	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Data processing	HDF5 is a data model, library, and file format for storing and managing data. It supports an unlimited variety of datatypes, and is designed for flexible and efficient I/O and for high volume and complex data.
HDF	4.2.15	2020b	broadwell, epyc, skylake, gpu	aion, iris	Data processing	HDF (also known as HDF4) is a library and multi-object file format for storing and managing data between machines.
HTSlib	1.10.2, 1.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	A C library for reading/writing high-throughput sequencing data. This package includes the utilities bgzip and tabix
Hadoop	2.10.0	2020b	broadwell, epyc, skylake	aion, iris	Utilities	Hadoop MapReduce by Cloudera
HarfBuzz	2.6.4, 2.6.7	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	HarfBuzz is an OpenType text shaping engine.
Harminv	1.4.1	2019b	broadwell, skylake	iris	Mathematics	Harminv is a free program (and accompanying library) to solve the problem of harmonic inversion - given a discrete-time, finite-length signal that consists of a sum of finitely-many sinusoids (possibly exponentially decaying) in a given bandwidth, it determines the frequencies, decay constants, amplitudes, and phases of those sinusoids.
Horovod	0.19.1, 0.22.0	2019b, 2020b	broadwell, skylake, gpu	iris	Utilities	Horovod is a distributed training framework for TensorFlow.
Hypre	2.20.0	2020b	broadwell, epyc, skylake	aion, iris	Numerical libraries	Hypre is a library for solving large, sparse linear systems of equations on massively parallel computers. The problems of interest arise in the simulation codes being developed at LLNL and elsewhere to study physical phenomena in the defense, environmental, energy, and biological sciences.
ICU	64.2, 67.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	ICU is a mature, widely used set of C/C++ and Java libraries providing Unicode and Globalization support for software applications.
ISL	0.23	2020b	broadwell, epyc, skylake	aion, iris	Mathematics	isl is a library for manipulating sets and relations of integer points bounded by linear constraints.
ImageMagick	7.0.10-35, 7.0.9-5	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	ImageMagick is a software suite to create, edit, compose, or convert bitmap images
Inspector	2019_update5	2019b	broadwell, skylake	iris	Utilities	Intel Inspector XE is an easy to use memory error checker and thread checker for serial and parallel applications
JasPer	2.0.14, 2.0.24	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	The JasPer Project is an open-source initiative to provide a free software-based reference implementation of the codec specified in the JPEG-2000 Part-1 standard.
Java	1.8.0_241, 11.0.2, 13.0.2, 16.0.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Java Platform, Standard Edition (Java SE) lets you develop and deploy Java applications on desktops and servers.
Jellyfish	2.3.0	2019b	broadwell, skylake	iris	Biology	Jellyfish is a tool for fast, memory-efficient counting of k-mers in DNA.
JsonCpp	1.9.3, 1.9.4	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	JsonCpp is a C++ library that allows manipulating JSON values, including serialization and deserialization to and from strings. It can also preserve existing comment in unserialization/serialization steps, making it a convenient format to store user input files.
Julia	1.4.1, 1.6.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Programming Languages	Julia is a high-level, high-performance dynamic programming language for numerical computing
Keras	2.3.1, 2.4.3	2019b, 2020b	gpu, broadwell, epyc, skylake	iris, aion	Mathematics	Keras is a deep learning API written in Python, running on top of the machine learning platform TensorFlow.
LAME	3.100	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Data processing	LAME is a high quality MPEG Audio Layer III (MP3) encoder licensed under the LGPL.
LLVM	10.0.1, 11.0.0, 9.0.0, 9.0.1	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Compilers	The LLVM Core libraries provide a modern source- and target-independent optimizer, along with code generation support for many popular CPUs (as well as some less common ones!) These libraries are built around a well specified code representation known as the LLVM intermediate representation ("LLVM IR"). The LLVM Core libraries are well documented, and it is particularly easy to invent your own language (or port an existing compiler) to use LLVM as an optimizer and code generator.
LMDB	0.9.24	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	LMDB is a fast, memory-efficient database. With memory-mapped files, it has the read performance of a pure in-memory database while retaining the persistence of standard disk-based databases.
LibTIFF	4.0.10, 4.1.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	tiff: Library and tools for reading and writing TIFF data files
LittleCMS	2.11, 2.9	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Little CMS intends to be an OPEN SOURCE small-footprint color management engine, with special focus on accuracy and performance.
Lua	5.1.5, 5.4.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Programming Languages	Lua is a powerful, fast, lightweight, embeddable scripting language. Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode for a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping.
M4	1.4.18	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	GNU M4 is an implementation of the traditional Unix macro processor. It is mostly SVR4 compatible although it has some extensions (for example, handling more than 9 positional parameters to macros). GNU M4 also has built-in functions for including files, running shell commands, doing arithmetic, etc.
MATLAB	2019b, 2020a, 2021a	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematics	MATLAB is a high-level language and interactive environment that enables you to perform computationally intensive tasks faster than with traditional programming languages such as C, C++, and Fortran.
METIS	5.1.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematics	METIS is a set of serial programs for partitioning graphs, partitioning finite element meshes, and producing fill reducing orderings for sparse matrices. The algorithms implemented in METIS are based on the multilevel recursive-bisection, multilevel k-way, and multi-constraint partitioning schemes.
MPC	1.2.1	2020b	broadwell, epyc, skylake	aion, iris	Mathematics	Gnu Mpc is a C library for the arithmetic of complex numbers with arbitrarily high precision and correct rounding of the result. It extends the principles of the IEEE-754 standard for fixed precision real floating point numbers to complex numbers, providing well-defined semantics for every operation. At the same time, speed of operation at high precision is a major design goal.
MPFR	4.0.2, 4.1.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Mathematics	The MPFR library is a C library for multiple-precision floating-point computations with correct rounding.
MUMPS	5.3.5	2020b	broadwell, epyc, skylake	aion, iris	Mathematics	A parallel sparse direct solver
Mako	1.1.0, 1.1.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	A super-fast templating language that borrows the best ideas from the existing templating languages
Mathematica	12.0.0, 12.1.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematics	Mathematica is a computational software program used in many scientific, engineering, mathematical and computing fields.
Maven	3.6.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	Binary maven install, Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information.
Meep	1.4.3	2019b	broadwell, skylake	iris	Physics	Meep (or MEEP) is a free finite-difference time-domain (FDTD) simulation software package developed at MIT to model electromagnetic systems.
Mesa	19.1.7, 19.2.1, 20.2.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	Mesa is an open-source implementation of the OpenGL specification - a system for rendering interactive 3D graphics.
Meson	0.51.2, 0.55.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Meson is a cross-platform build system designed to be both as fast and as user friendly as possible.
Mesquite	2.3.0	2019b	broadwell, skylake	iris	Mathematics	Mesh-Quality Improvement Library
NAMD	2.13	2019b	broadwell, skylake	iris	Chemistry	NAMD is a parallel molecular dynamics code designed for high-performance simulation of large biomolecular systems.
NASM	2.14.02, 2.15.05	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	NASM: General-purpose x86 assembler
NCCL	2.4.8, 2.8.3	2019b, 2020b	gpu	iris	Libraries	The NVIDIA Collective Communications Library (NCCL) implements multi-GPU and multi-node collective communication primitives that are performance optimized for NVIDIA GPUs.
NLopt	2.6.1, 2.6.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Numerical libraries	NLopt is a free/open-source library for nonlinear optimization, providing a common interface for a number of different free optimization routines available online as well as original implementations of various other algorithms.
NSPR	4.21, 4.29	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	Netscape Portable Runtime (NSPR) provides a platform-neutral API for system level and libc-like functions.
NSS	3.45, 3.57	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	Network Security Services (NSS) is a set of libraries designed to support cross-platform development of security-enabled client and server applications.
Ninja	1.10.1, 1.9.0	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Ninja is a small build system with a focus on speed.
OPARI2	2.0.5	2019b	broadwell, skylake	iris	Performance measurements	OPARI2, the successor of Forschungszentrum Juelich's OPARI, is a source-to-source instrumentation tool for OpenMP and hybrid codes. It surrounds OpenMP directives and runtime library calls with calls to the POMP2 measurement interface.
OTF2	2.2	2019b	broadwell, skylake	iris	Performance measurements	The Open Trace Format 2 is a highly scalable, memory efficient event trace data format plus support library. It is the new standard trace format for Scalasca, Vampir, and TAU and is open for other tools.
OpenBLAS	0.3.12, 0.3.7	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Numerical libraries	OpenBLAS is an optimized BLAS library based on GotoBLAS2 1.13 BSD version.
OpenCV	4.2.0, 4.5.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	OpenCV (Open Source Computer Vision Library) is an open source computer vision and machine learning software library. OpenCV was built to provide a common infrastructure for computer vision applications and to accelerate the use of machine perception in the commercial products. Includes extra modules for OpenCV from the contrib repository.
OpenEXR	2.5.5	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	OpenEXR is a high dynamic-range (HDR) image file format developed by Industrial Light & Magic for use in computer imaging applications
OpenFOAM-Extend	4.1-20200408	2019b	broadwell, skylake	iris	CFD/Finite element modelling	OpenFOAM is a free, open source CFD software package. OpenFOAM has an extensive range of features to solve anything from complex fluid flows involving chemical reactions, turbulence and heat transfer, to solid dynamics and electromagnetics.
OpenFOAM	8, v1912	2020b, 2019b	epyc, broadwell, skylake	aion, iris	CFD/Finite element modelling	OpenFOAM is a free, open source CFD software package. OpenFOAM has an extensive range of features to solve anything from complex fluid flows involving chemical reactions, turbulence and heat transfer, to solid dynamics and electromagnetics.
OpenMPI	3.1.4, 4.0.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	MPI	The Open MPI Project is an open source MPI-3 implementation.
PAPI	6.0.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Performance measurements	PAPI provides the tool designer and application engineer with a consistent interface and methodology for use of the performance counter hardware found in most major microprocessors. PAPI enables software engineers to see, in near real time, the relation between software performance and processor events. In addition Component PAPI provides access to a collection of components that expose performance measurement opportunites across the hardware and software stack.
PCRE2	10.33, 10.35	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Development	The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.
PCRE	8.43, 8.44	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.
PDT	3.25	2019b	broadwell, skylake	iris	Performance measurements	Program Database Toolkit (PDT) is a framework for analyzing source code written in several programming languages and for making rich program knowledge accessible to developers of static and dynamic analysis tools. PDT implements a standard program representation, the program database (PDB), that can be accessed in a uniform way through a class library supporting common PDB operations.
PETSc	3.14.4	2020b	broadwell, epyc, skylake	aion, iris	Numerical libraries	PETSc, pronounced PET-see (the S is silent), is a suite of data structures and routines for the scalable (parallel) solution of scientific applications modeled by partial differential equations.
PGI	19.10	2019b	broadwell, skylake	iris	Compilers	C, C++ and Fortran compilers from The Portland Group - PGI
PLUMED	2.5.3, 2.7.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Chemistry	PLUMED is an open source library for free energy calculations in molecular systems which works together with some of the most popular molecular dynamics engines. Free energy calculations can be performed as a function of many order parameters with a particular focus on biological problems, using state of the art methods such as metadynamics, umbrella sampling and Jarzynski-equation based steered MD. The software, written in C++, can be easily interfaced with both fortran and C/C++ codes.
POV-Ray	3.7.0.8	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	The Persistence of Vision Raytracer, or POV-Ray, is a ray tracing program which generates images from a text-based scene description, and is available for a variety of computer platforms. POV-Ray is a high-quality, Free Software tool for creating stunning three-dimensional graphics. The source code is available for those wanting to do their own ports.
PROJ	6.2.1, 7.2.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Program proj is a standard Unix filter function which converts geographic longitude and latitude coordinates into cartesian coordinates
Pango	1.44.7, 1.47.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	Pango is a library for laying out and rendering of text, with an emphasis on internationalization. Pango can be used anywhere that text layout is needed, though most of the work on Pango so far has been done in the context of the GTK+ widget toolkit. Pango forms the core of text and font handling for GTK+-2.x.
ParMETIS	4.0.3	2019b	broadwell, skylake	iris	Mathematics	ParMETIS is an MPI-based parallel library that implements a variety of algorithms for partitioning unstructured graphs, meshes, and for computing fill-reducing orderings of sparse matrices. ParMETIS extends the functionality provided by METIS and includes routines that are especially suited for parallel AMR computations and large scale numerical simulations. The algorithms implemented in ParMETIS are based on the parallel multilevel k-way graph-partitioning, adaptive repartitioning, and parallel multi-constrained partitioning schemes.
ParMGridGen	1.0	2019b	broadwell, skylake	iris	Mathematics	ParMGridGen is an MPI-based parallel library that is based on the serial package MGridGen, that implements (serial) algorithms for obtaining a sequence of successive coarse grids that are well-suited for geometric multigrid methods.
ParaView	5.6.2, 5.8.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	ParaView is a scientific parallel visualizer.
Perl	5.30.0, 5.32.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Larry Wall's Practical Extraction and Report Language This is a minimal build without any modules. Should only be used for build dependencies.
Pillow	6.2.1, 8.0.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	Pillow is the 'friendly PIL fork' by Alex Clark and Contributors. PIL is the Python Imaging Library by Fredrik Lundh and Contributors.
PyOpenGL	3.1.5	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	PyOpenGL is the most common cross platform Python binding to OpenGL and related APIs.
PyQt5	5.15.1	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	PyQt5 is a set of Python bindings for v5 of the Qt application framework from The Qt Company. This bundle includes PyQtWebEngine, a set of Python bindings for The Qt Company’s Qt WebEngine framework.
PyQtGraph	0.11.1	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	PyQtGraph is a pure-python graphics and GUI library built on PyQt5/PySide2 and numpy.
PyTorch-Geometric	1.6.3	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	PyTorch Geometric (PyG) is a geometric deep learning extension library for PyTorch.
PyTorch	1.4.0, 1.7.1, 1.8.1, 1.9.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	Tensors and Dynamic neural networks in Python with strong GPU acceleration. PyTorch is a deep learning framework that puts Python first.
PyYAML	5.1.2, 5.3.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	PyYAML is a YAML parser and emitter for the Python programming language.
Python	2.7.16, 2.7.18, 3.7.4, 3.8.6	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Python is a programming language that lets you work more quickly and integrate your systems more effectively.
Qt5	5.13.1, 5.14.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	Qt is a comprehensive cross-platform C++ application framework.
QuantumESPRESSO	6.7	2019b, 2020b	broadwell, epyc, skylake	iris, aion	Chemistry	Quantum ESPRESSO is an integrated suite of computer codes for electronic-structure calculations and materials modeling at the nanoscale. It is based on density-functional theory, plane waves, and pseudopotentials (both norm-conserving and ultrasoft).
RDFlib	5.0.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	RDFLib is a Python library for working with RDF, a simple yet powerful language for representing information.
R	3.6.2, 4.0.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	R is a free software environment for statistical computing and graphics.
ReFrame	2.21, 3.6.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	ReFrame is a framework for writing regression tests for HPC systems.
Ruby	2.7.1, 2.7.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Programming Languages	Ruby is a dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write.
Rust	1.37.0	2019b	broadwell, skylake	iris	Programming Languages	Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.
SAMtools	1.10, 1.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	SAM Tools provide various utilities for manipulating alignments in the SAM format, including sorting, merging, indexing and generating alignments in a per-position format.
SCOTCH	6.0.9, 6.1.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematics	Software package and libraries for sequential and parallel graph partitioning, static mapping, and sparse matrix block ordering, and sequential mesh and hypergraph partitioning.
SDL2	2.0.14	2020b	broadwell, epyc, skylake	aion, iris	Libraries	SDL: Simple DirectMedia Layer, a cross-platform multimedia library
SIONlib	1.7.6	2019b	broadwell, skylake	iris	Libraries	SIONlib is a scalable I/O library for parallel access to task-local files. The library not only supports writing and reading binary data to or from several thousands of processors into a single or a small number of physical files, but also provides global open and close functions to access SIONlib files in parallel. This package provides a stripped-down installation of SIONlib for use with performance tools (e.g., Score-P), with renamed symbols to avoid conflicts when an application using SIONlib itself is linked against a tool requiring a different SIONlib version.
SLEPc	3.14.2	2020b	broadwell, epyc, skylake	aion, iris	Numerical libraries	SLEPc (Scalable Library for Eigenvalue Problem Computations) is a software library for the solution of large scale sparse eigenvalue problems on parallel computers. It is an extension of PETSc and can be used for either standard or generalized eigenproblems, with real or complex arithmetic. It can also be used for computing a partial SVD of a large, sparse, rectangular matrix, and to solve quadratic eigenvalue problems.
SQLite	3.29.0, 3.33.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	SQLite: SQL Database Engine in a C Library
SWIG	4.0.1, 4.0.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	SWIG is a software development tool that connects programs written in C and C++ with a variety of high-level programming languages.
Salmon	1.1.0	2019b	broadwell, skylake	iris	Biology	Salmon is a wicked-fast program to produce a highly-accurate, transcript-level quantification estimates from RNA-seq data.
Salome	8.5.0, 9.8.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	CFD/Finite element modelling	The SALOME platform is an open source software framework for pre- and post-processing and integration of numerical solvers from various scientific fields. CEA and EDF use SALOME to perform a large number of simulations, typically related to power plant equipment and alternative energy. To address these challenges, SALOME includes a CAD/CAE modelling tool, mesh generators, an advanced 3D visualization tool, etc.
ScaLAPACK	2.0.2, 2.1.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Numerical libraries	The ScaLAPACK (or Scalable LAPACK) library includes a subset of LAPACK routines redesigned for distributed memory MIMD parallel computers.
Scalasca	2.5	2019b	broadwell, skylake	iris	Performance measurements	Scalasca is a software tool that supports the performance optimization of parallel programs by measuring and analyzing their runtime behavior. The analysis identifies potential performance bottlenecks -- in particular those concerning communication and synchronization -- and offers guidance in exploring their causes.
SciPy-bundle	2019.10, 2020.11	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Bundle of Python packages for scientific software
Score-P	6.0	2019b	broadwell, skylake	iris	Performance measurements	The Score-P measurement infrastructure is a highly scalable and easy-to-use tool suite for profiling, event tracing, and online analysis of HPC applications.
Singularity	3.6.0, 3.8.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	SingularityCE is an open source container platform designed to be simple, fast, and secure. Singularity is optimized for EPC and HPC workloads, allowing untrusted users to run untrusted containers in a trusted way.
Spack	0.12.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	Spack is a package manager for supercomputers, Linux, and macOS. It makes installing scientific software easy. With Spack, you can build a package with multiple versions, configurations, platforms, and compilers, and all of these builds can coexist on the same machine.
Spark	2.4.3	2019b	broadwell, skylake	iris	Development	Spark is Hadoop MapReduce done in memory
Stata	17	2020b	broadwell, epyc, skylake	aion, iris	Mathematics	Stata is a complete, integrated statistical software package that provides everything you need for data analysis, data management, and graphics.
SuiteSparse	5.8.1	2020b	broadwell, epyc, skylake	aion, iris	Numerical libraries	SuiteSparse is a collection of libraries manipulate sparse matrices.
Sumo	1.3.1	2019b	broadwell, skylake	iris	Utilities	Sumo is an open source, highly portable, microscopic and continuous traffic simulation package designed to handle large road networks.
Szip	2.1.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Szip compression software, providing lossless compression of scientific data
Tcl	8.6.10, 8.6.9	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Tcl (Tool Command Language) is a very powerful but easy to learn dynamic programming language, suitable for a very wide range of uses, including web and desktop applications, networking, administration, testing and many more.
TensorFlow	1.15.5, 2.1.0, 2.4.1, 2.5.0	2019b, 2020b	gpu, broadwell, skylake, epyc	iris, aion	Libraries	An open-source software library for Machine Intelligence
Theano	1.0.4, 1.1.2	2019b, 2020b	gpu, broadwell, epyc, skylake	iris, aion	Mathematics	Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently.
Tk	8.6.10, 8.6.9	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Tk is an open source, cross-platform widget toolchain that provides a library of basic elements for building a graphical user interface (GUI) in many different programming languages.
Tkinter	3.7.4, 3.8.6	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Programming Languages	Tkinter module, built with the Python buildsystem
TopHat	2.1.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Biology	TopHat is a fast splice junction mapper for RNA-Seq reads.
Trinity	2.10.0	2019b	broadwell, skylake	iris	Biology	Trinity represents a novel method for the efficient and robust de novo reconstruction of transcriptomes from RNA-Seq data. Trinity combines three independent software modules: Inchworm, Chrysalis, and Butterfly, applied sequentially to process large volumes of RNA-Seq reads.
UCX	1.9.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Unified Communication X An open-source production grade communication framework for data centric and high-performance applications
UDUNITS	2.2.26	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Physics	UDUNITS supports conversion of unit specifications between formatted and binary forms, arithmetic manipulation of units, and conversion of values between compatible scales of measurement.
ULHPC-bd	2020b	2020b	broadwell, epyc, skylake	aion, iris	System-level software	Generic Module bundle for BigData Analytics software in use on the UL HPC Facility
ULHPC-bio	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	System-level software	Generic Module bundle for Bioinformatics, biology and biomedical software in use on the UL HPC Facility, especially at LCSB
ULHPC-cs	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	System-level software	Generic Module bundle for Computational science software in use on the UL HPC Facility, including: - Computer Aided Engineering, incl. CFD - Chemistry, Computational Chemistry and Quantum Chemistry - Data management & processing tools - Earth Sciences - Quantum Computing - Physics and physical systems simulations
ULHPC-dl	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	System-level software	Generic Module bundle for (CPU-version) of AI / Deep Learning / Machine Learning software in use on the UL HPC Facility
ULHPC-gpu	2019b, 2020b	2019b, 2020b	gpu	iris	System-level software	Generic Module bundle for GPU accelerated User Software in use on the UL HPC Facility
ULHPC-math	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	System-level software	Generic Module bundle for High-level mathematical software and Linear Algrebra libraries in use on the UL HPC Facility
ULHPC-toolchains	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	System-level software	Generic Module bundle that contains all the dependencies required to enable toolchains and building tools/programming language in use on the UL HPC Facility
ULHPC-tools	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	System-level software	Misc tools, incl. - perf: Performance tools - tools: General purpose tools
UnZip	6.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	UnZip is an extraction utility for archives compressed in .zip format (also called "zipfiles"). Although highly compatible both with PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP's own Zip program, our primary objectives have been portability and non-MSDOS functionality.
VASP	5.4.4, 6.2.1	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Physics	The Vienna Ab initio Simulation Package (VASP) is a computer program for atomic scale materials modelling, e.g. electronic structure calculations and quantum-mechanical molecular dynamics, from first principles.
VMD	1.9.4a51	2020b	broadwell, epyc, skylake	aion, iris	Visualisation	VMD is a molecular visualization program for displaying, animating, and analyzing large biomolecular systems using 3-D graphics and built-in scripting.
VTK	8.2.0, 9.0.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	The Visualization Toolkit (VTK) is an open-source, freely available software system for 3D computer graphics, image processing and visualization. VTK consists of a C++ class library and several interpreted interface layers including Tcl/Tk, Java, and Python. VTK supports a wide variety of visualization algorithms including: scalar, vector, tensor, texture, and volumetric methods; and advanced modeling techniques such as: implicit modeling, polygon reduction, mesh smoothing, cutting, contouring, and Delaunay triangulation.
VTune	2019_update8, 2020_update3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	Intel VTune Amplifier XE is the premier performance profiler for C, C++, C#, Fortran, Assembly and Java.
Valgrind	3.15.0, 3.16.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Debugging	Valgrind: Debugging and profiling tools
VirtualGL	2.6.2	2019b	broadwell, skylake	iris	Visualisation	VirtualGL is an open source toolkit that gives any Linux or Unix remote display software the ability to run OpenGL applications with full hardware acceleration.
Voro++	0.4.6	2019b	broadwell, skylake	iris	Mathematics	Voro++ is a software library for carrying out three-dimensional computations of the Voronoi tessellation. A distinguishing feature of the Voro++ library is that it carries out cell-based calculations, computing the Voronoi cell for each particle individually. It is particularly well-suited for applications that rely on cell-based statistics, where features of Voronoi cells (eg. volume, centroid, number of faces) can be used to analyze a system of particles.
Wannier90	3.1.0	2020b	broadwell, epyc, skylake	aion, iris	Chemistry	A tool for obtaining maximally-localised Wannier functions
X11	20190717, 20201008	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	The X Window System (X11) is a windowing system for bitmap displays
XML-LibXML	2.0201, 2.0206	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Data processing	Perl binding for libxml2
XZ	5.2.4, 5.2.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	xz: XZ utilities
Xerces-C++	3.2.2	2019b	broadwell, skylake	iris	Libraries	Xerces-C++ is a validating XML parser written in a portable subset of C++. Xerces-C++ makes it easy to give your application the ability to read and write XML data. A shared library is provided for parsing, generating, manipulating, and validating XML documents using the DOM, SAX, and SAX2 APIs.
Xvfb	1.20.9	2020b	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Xvfb is an X server that can run on machines with no display hardware and no physical input devices. It emulates a dumb framebuffer using virtual memory.
YACS	0.1.8	2020b	broadwell, epyc, skylake	aion, iris	Libraries	YACS was created as a lightweight library to define and manage system configurations, such as those commonly found in software designed for scientific experimentation. These "configurations" typically cover concepts like hyperparameters used in training a machine learning model or configurable model hyperparameters, such as the depth of a convolutional neural network.
Yasm	1.3.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Yasm: Complete rewrite of the NASM assembler with BSD license
Z3	4.8.10	2020b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Z3 is a theorem prover from Microsoft Research.
Zip	3.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Zip is a compression and file packaging/archive utility. Although highly compatible both with PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP's own UnZip, our primary objectives have been portability and other-than-MSDOS functionality
ant	1.10.6, 1.10.7, 1.10.9	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	Apache Ant is a Java library and command-line tool whose mission is to drive processes described in build files as targets and extension points dependent upon each other. The main known usage of Ant is the build of Java applications.
archspec	0.1.0	2019b	broadwell, skylake	iris	Utilities	A library for detecting, labeling, and reasoning about microarchitectures
arpack-ng	3.7.0, 3.8.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Numerical libraries	ARPACK is a collection of Fortran77 subroutines designed to solve large scale eigenvalue problems.
at-spi2-atk	2.34.1, 2.38.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	AT-SPI 2 toolkit bridge
at-spi2-core	2.34.0, 2.38.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	Assistive Technology Service Provider Interface.
binutils	2.32, 2.35	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	binutils: GNU binary utilities
bokeh	2.2.3	2020b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Statistical and novel interactive HTML plots for Python
bzip2	1.0.8	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.
cURL	7.66.0, 7.72.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more.
cairo	1.16.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	Cairo is a 2D graphics library with support for multiple output devices. Currently supported output targets include the X Window System (via both Xlib and XCB), Quartz, Win32, image buffers, PostScript, PDF, and SVG file output. Experimental backends include OpenGL, BeOS, OS/2, and DirectFB
cuDNN	7.6.4.38, 8.0.4.30, 8.0.5.39	2019b, 2020b	gpu	iris	Numerical libraries	The NVIDIA CUDA Deep Neural Network library (cuDNN) is a GPU-accelerated library of primitives for deep neural networks.
dask	2021.2.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Data processing	Dask natively scales Python. Dask provides advanced parallelism for analytics, enabling performance at scale for the tools you love.
double-conversion	3.1.4, 3.1.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Efficient binary-decimal and decimal-binary conversion routines for IEEE doubles.
elfutils	0.183	2020b	gpu	iris	Libraries	The elfutils project provides libraries and tools for ELF files and DWARF data.
expat	2.2.7, 2.2.9	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Expat is an XML parser library written in C. It is a stream-oriented parser in which an application registers handlers for things the parser might find in the XML document (like start tags)
flatbuffers-python	1.12	2020b	broadwell, epyc, skylake, gpu	aion, iris	Development	Python Flatbuffers runtime library.
flatbuffers	1.12.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	FlatBuffers: Memory Efficient Serialization Library
flex	2.6.4	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Programming Languages	Flex (Fast Lexical Analyzer) is a tool for generating scanners. A scanner, sometimes called a tokenizer, is a program which recognizes lexical patterns in text.
fontconfig	2.13.1, 2.13.92	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	Fontconfig is a library designed to provide system-wide font configuration, customization and application access.
foss	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain, including OpenMPI for MPI support, OpenBLAS (BLAS and LAPACK support), FFTW and ScaLAPACK.
fosscuda	2019b, 2020b	2019b, 2020b	gpu	iris	Toolchains (software stacks)	GCC based compiler toolchain with CUDA support, and including OpenMPI for MPI support, OpenBLAS (BLAS and LAPACK support), FFTW and ScaLAPACK.
freetype	2.10.1, 2.10.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	FreeType 2 is a software font engine that is designed to be small, efficient, highly customizable, and portable while capable of producing high-quality output (glyph images). It can be used in graphics libraries, display servers, font conversion tools, text image generation tools, and many other products as well.
gc	7.6.12	2019b	broadwell, skylake	iris	Libraries	The Boehm-Demers-Weiser conservative garbage collector can be used as a garbage collecting replacement for C malloc or C++ new.
gcccuda	2019b, 2020b	2019b, 2020b	gpu	iris	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain, along with CUDA toolkit.
gettext	0.19.8.1, 0.20.1, 0.21	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	GNU 'gettext' is an important step for the GNU Translation Project, as it is an asset on which we may build many other steps. This package offers to programmers, translators, and even users, a well integrated set of tools and documentation
gflags	2.2.2	2019b	broadwell, skylake	iris	Development	The gflags package contains a C++ library that implements commandline flags processing. It includes built-in support for standard types such as string and the ability to define flags in the source file in which they are used.
giflib	5.2.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	giflib is a library for reading and writing gif images. It is API and ABI compatible with libungif which was in wide use while the LZW compression algorithm was patented.
git	2.23.0, 2.28.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.
glog	0.4.0	2019b	broadwell, skylake	iris	Development	A C++ implementation of the Google logging module.
gmsh	4.4.0	2019b	broadwell, skylake	iris	CFD/Finite element modelling	Salome is an open-source software that provides a generic Pre- and Post-Processing platform for numerical simulation. It is based on an open and flexible architecture made of reusable components.
gmsh	4.8.4	2020b	broadwell, epyc, skylake	aion, iris	Mathematics	Gmsh is a 3D finite element grid generator with a build-in CAD engine and post-processor.
gnuplot	5.2.8, 5.4.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	Portable interactive, function plotting utility
gocryptfs	1.7.1, 2.0.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	Encrypted overlay filesystem written in Go. gocryptfs uses file-based encryption that is implemented as a mountable FUSE filesystem. Each file in gocryptfs is stored as one corresponding encrypted file on the hard disk.
gompi	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain, including OpenMPI for MPI support.
gompic	2019b, 2020b	2019b, 2020b	gpu	iris	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain along with CUDA toolkit, including OpenMPI for MPI support with CUDA features enabled.
googletest	1.10.0	2019b	broadwell, skylake	iris	Development	Google's framework for writing C++ tests on a variety of platforms
gperf	3.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	GNU gperf is a perfect hash function generator. For a given list of strings, it produces a hash function and hash table, in form of C or C++ code, for looking up a value depending on the input string. The hash function is perfect, which means that the hash table has no collisions, and the hash table lookup needs a single string comparison only.
groff	1.22.4	2020b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Groff (GNU troff) is a typesetting system that reads plain text mixed with formatting commands and produces formatted output.
gzip	1.10	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Utilities	gzip (GNU zip) is a popular data compression program as a replacement for compress
h5py	2.10.0, 3.1.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Data processing	HDF5 for Python (h5py) is a general-purpose Python interface to the Hierarchical Data Format library, version 5. HDF5 is a versatile, mature scientific software library designed for the fast, flexible storage of enormous amounts of data.
help2man	1.47.16, 1.47.4, 1.47.8	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	help2man produces simple manual pages from the '--help' and '--version' output of other commands.
hwloc	1.11.12, 2.2.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	System-level software	The Portable Hardware Locality (hwloc) software package provides a portable abstraction (across OS, versions, architectures, ...) of the hierarchical topology of modern architectures, including NUMA memory nodes, sockets, shared caches, cores and simultaneous multithreading. It also gathers various system attributes such as cache and memory information as well as the locality of I/O devices such as network interfaces, InfiniBand HCAs or GPUs. It primarily aims at helping applications with gathering information about modern computing hardware so as to exploit it accordingly and efficiently.
hypothesis	4.44.2, 5.41.2, 5.41.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Hypothesis is an advanced testing library for Python. It lets you write tests which are parametrized by a source of examples, and then generates simple and comprehensible examples that make your tests fail. This lets you find more bugs in your code with less work.
iccifort	2019.5.281, 2020.4.304	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Compilers	Intel C, C++ & Fortran compilers
iccifortcuda	2019b, 2020b	2019b, 2020b	gpu	iris	Toolchains (software stacks)	Intel C, C++ & Fortran compilers with CUDA toolkit
iimpi	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Toolchains (software stacks)	Intel C/C++ and Fortran compilers, alongside Intel MPI.
iimpic	2019b, 2020b	2019b, 2020b	gpu	iris	Toolchains (software stacks)	Intel C/C++ and Fortran compilers, alongside Intel MPI and CUDA.
imkl	2019.5.281, 2020.4.304	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Numerical libraries	Intel Math Kernel Library is a library of highly optimized, extensively threaded math routines for science, engineering, and financial applications that require maximum performance. Core math functions include BLAS, LAPACK, ScaLAPACK, Sparse Solvers, Fast Fourier Transforms, Vector Math, and more.
impi	2018.5.288, 2019.9.304	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	MPI	Intel MPI Library, compatible with MPICH ABI
intel	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Toolchains (software stacks)	Compiler toolchain including Intel compilers, Intel MPI and Intel Math Kernel Library (MKL).
intelcuda	2019b, 2020b	2019b, 2020b	gpu	iris	Toolchains (software stacks)	Intel Cluster Toolkit Compiler Edition provides Intel C/C++ and Fortran compilers, Intel MPI & Intel MKL, with CUDA toolkit
intltool	0.51.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	intltool is a set of tools to centralize translation of many different file formats using GNU gettext-compatible PO files.
itac	2019.4.036	2019b	broadwell, skylake	iris	Utilities	The Intel Trace Collector is a low-overhead tracing library that performs event-based tracing in applications. The Intel Trace Analyzer provides a convenient way to monitor application activities gathered by the Intel Trace Collector through graphical displays.
jemalloc	5.2.1	2019b	broadwell, skylake	iris	Libraries	jemalloc is a general purpose malloc(3) implementation that emphasizes fragmentation avoidance and scalable concurrency support.
kallisto	0.46.1	2019b	broadwell, skylake	iris	Biology	kallisto is a program for quantifying abundances of transcripts from RNA-Seq data, or more generally of target sequences using high-throughput sequencing reads.
kim-api	2.1.3	2019b	broadwell, skylake	iris	Chemistry	Open Knowledgebase of Interatomic Models. KIM is an API and OpenKIM is a collection of interatomic models (potentials) for atomistic simulations. This is a library that can be used by simulation programs to get access to the models in the OpenKIM database. This EasyBuild only installs the API, the models can be installed with the package openkim-models, or the user can install them manually by running kim-api-collections-management install user MODELNAME or kim-api-collections-management install user OpenKIM to install them all.
libGLU	9.0.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	The OpenGL Utility Library (GLU) is a computer graphics library for OpenGL.
libarchive	3.4.3	2020b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Multi-format archive and compression library
libcerf	1.13, 1.14	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Mathematics	libcerf is a self-contained numeric library that provides an efficient and accurate implementation of complex error functions, along with Dawson, Faddeeva, and Voigt functions.
libctl	4.0.0	2019b	broadwell, skylake	iris	Chemistry	libctl is a free Guile-based library implementing flexible control files for scientific simulations.
libdrm	2.4.102, 2.4.99	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Direct Rendering Manager runtime library.
libepoxy	1.5.4	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	Epoxy is a library for handling OpenGL function pointer management for you
libevent	2.1.11, 2.1.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	The libevent API provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached. Furthermore, libevent also support callbacks due to signals or regular timeouts.
libffi	3.2.1, 3.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	The libffi library provides a portable, high level programming interface to various calling conventions. This allows a programmer to call any function specified by a call interface description at run-time.
libgd	2.2.5, 2.3.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	GD is an open source code library for the dynamic creation of images by programmers.
libgeotiff	1.5.1, 1.6.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Library for reading and writing coordinate system information from/to GeoTIFF files
libglvnd	1.2.0, 1.3.2	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Libraries	libglvnd is a vendor-neutral dispatch layer for arbitrating OpenGL API calls between multiple vendors.
libgpuarray	0.7.6	2019b, 2020b	gpu	iris	Libraries	Library to manipulate tensors on the GPU.
libiconv	1.16	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Libiconv converts from one character encoding to another through Unicode conversion
libjpeg-turbo	2.0.3, 2.0.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	libjpeg-turbo is a fork of the original IJG libjpeg which uses SIMD to accelerate baseline JPEG compression and decompression. libjpeg is a library that implements JPEG image encoding, decoding and transcoding.
libmatheval	1.1.11	2019b	broadwell, skylake	iris	Libraries	GNU libmatheval is a library (callable from C and Fortran) to parse and evaluate symbolic expressions input as text.
libogg	1.3.4	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Ogg is a multimedia container format, and the native file and stream format for the Xiph.org multimedia codecs.
libpciaccess	0.14, 0.16	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	System-level software	Generic PCI access library.
libpng	1.6.37	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	libpng is the official PNG reference library
libreadline	8.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	The GNU Readline library provides a set of functions for use by applications that allow users to edit command lines as they are typed in. Both Emacs and vi editing modes are available. The Readline library includes additional functions to maintain a list of previously-entered command lines, to recall and perhaps reedit those lines, and perform csh-like history expansion on previous commands.
libsndfile	1.0.28	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Libsndfile is a C library for reading and writing files containing sampled sound (such as MS Windows WAV and the Apple/SGI AIFF format) through one standard library interface.
libtirpc	1.3.1	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Libtirpc is a port of Suns Transport-Independent RPC library to Linux.
libtool	2.4.6	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	GNU libtool is a generic library support script. Libtool hides the complexity of using shared libraries behind a consistent, portable interface.
libunistring	0.9.10	2019b	broadwell, skylake	iris	Libraries	This library provides functions for manipulating Unicode strings and for manipulating C strings according to the Unicode standard.
libunwind	1.3.1, 1.4.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	The primary goal of libunwind is to define a portable and efficient C programming interface (API) to determine the call-chain of a program. The API additionally provides the means to manipulate the preserved (callee-saved) state of each call-frame and to resume execution at any point in the call-chain (non-local goto). The API supports both local (same-process) and remote (across-process) operation. As such, the API is useful in a number of applications
libvorbis	1.3.7	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Ogg Vorbis is a fully open, non-proprietary, patent-and-royalty-free, general-purpose compressed audio format
libwebp	1.1.0	2020b	broadwell, epyc, skylake	aion, iris	Libraries	WebP is a modern image format that provides superior lossless and lossy compression for images on the web. Using WebP, webmasters and web developers can create smaller, richer images that make the web faster.
libxc	4.3.4, 5.1.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Chemistry	Libxc is a library of exchange-correlation functionals for density-functional theory. The aim is to provide a portable, well tested and reliable set of exchange and correlation functionals.
libxml2	2.9.10, 2.9.9	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Libxml2 is the XML C parser and toolchain developed for the Gnome project (but usable outside of the Gnome platform).
libxslt	1.1.34	2019b	broadwell, skylake	iris	Libraries	Libxslt is the XSLT C library developed for the GNOME project (but usable outside of the Gnome platform).
libyaml	0.2.2, 0.2.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	LibYAML is a YAML parser and emitter written in C.
lxml	4.4.2	2019b	broadwell, skylake	iris	Libraries	The lxml XML toolkit is a Pythonic binding for the C libraries libxml2 and libxslt.
lz4	1.9.2	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	LZ4 is lossless compression algorithm, providing compression speed at 400 MB/s per core. It features an extremely fast decoder, with speed in multiple GB/s per core.
magma	2.5.1, 2.5.4	2019b, 2020b	gpu	iris	Mathematics	The MAGMA project aims to develop a dense linear algebra library similar to LAPACK but for heterogeneous/hybrid architectures, starting with current Multicore+GPU systems.
makeinfo	6.7	2020b	broadwell, epyc, skylake, gpu	aion, iris	Development	makeinfo is part of the Texinfo project, the official documentation format of the GNU project.
matplotlib	3.1.1, 3.3.3	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Visualisation	matplotlib is a python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. matplotlib can be used in python scripts, the python and ipython shell, web application servers, and six graphical user interface toolkits.
molmod	1.4.5	2019b	broadwell, skylake	iris	Mathematics	MolMod is a Python library with many compoments that are useful to write molecular modeling programs.
ncurses	6.0, 6.1, 6.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	The Ncurses (new curses) library is a free software emulation of curses in System V Release 4.0, and more. It uses Terminfo format, supports pads and color and multiple highlights and forms characters and function-key mapping, and has all the other SYSV-curses enhancements over BSD Curses.
netCDF-Fortran	4.5.2, 4.5.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Data processing	NetCDF (network Common Data Form) is a set of software libraries and machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.
netCDF	4.7.1, 4.7.4	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Data processing	NetCDF (network Common Data Form) is a set of software libraries and machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.
nettle	3.5.1, 3.6	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Nettle is a cryptographic library that is designed to fit easily in more or less any context: In crypto toolkits for object-oriented languages (C++, Python, Pike, ...), in applications like LSH or GNUPG, or even in kernel space.
networkx	2.5	2020b	broadwell, epyc, skylake, gpu	aion, iris	Utilities	NetworkX is a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.
nodejs	12.19.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Node.js is a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.
nsync	1.24.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	nsync is a C library that exports various synchronization primitives, such as mutexes
numactl	2.0.12, 2.0.13	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	The numactl program allows you to run your application program on specific cpu's and memory nodes. It does this by supplying a NUMA memory policy to the operating system before running your program. The libnuma library provides convenient ways for you to add NUMA memory policies into your own program.
numba	0.52.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Numba is an Open Source NumPy-aware optimizing compiler for Python sponsored by Continuum Analytics, Inc. It uses the remarkable LLVM compiler infrastructure to compile Python syntax to machine code.
phonopy	2.2.0	2019b	broadwell, skylake	iris	Libraries	Phonopy is an open source package of phonon calculations based on the supercell approach.
pixman	0.38.4, 0.40.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	Pixman is a low-level software library for pixel manipulation, providing features such as image compositing and trapezoid rasterization. Important users of pixman are the cairo graphics library and the X server.
pkg-config	0.29.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	pkg-config is a helper tool used when compiling applications and libraries. It helps you insert the correct compiler options on the command line so an application can use gcc -o test test.c pkg-config --libs --cflags glib-2.0 for instance, rather than hard-coding values on where to find glib (or other libraries).
pkgconfig	1.5.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	pkgconfig is a Python module to interface with the pkg-config command line tool
pocl	1.4, 1.6	2019b, 2020b	gpu	iris	Libraries	Pocl is a portable open source (MIT-licensed) implementation of the OpenCL standard
protobuf-python	3.10.0, 3.14.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	Python Protocol Buffers runtime library.
protobuf	2.5.0, 3.10.0, 3.14.0	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Development	Google Protocol Buffers
pybind11	2.4.3, 2.6.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	pybind11 is a lightweight header-only library that exposes C++ types in Python and vice versa, mainly to create Python bindings of existing C++ code.
re2c	1.2.1, 2.0.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Utilities	re2c is a free and open-source lexer generator for C and C++. Its main goal is generating fast lexers: at least as fast as their reasonably optimized hand-coded counterparts. Instead of using traditional table-driven approach, re2c encodes the generated finite state automata directly in the form of conditional jumps and comparisons.
scikit-build	0.11.1	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Scikit-Build, or skbuild, is an improved build system generator for CPython C/C++/Fortran/Cython extensions.
scikit-image	0.18.1	2020b	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	scikit-image is a collection of algorithms for image processing.
scikit-learn	0.23.2	2020b	broadwell, epyc, skylake, gpu	aion, iris	Data processing	Scikit-learn integrates machine learning algorithms in the tightly-knit scientific Python world, building upon numpy, scipy, and matplotlib. As a machine-learning module, it provides versatile tools for data mining and analysis in any field of science and engineering. It strives to be simple and efficient, accessible to everybody, and reusable in various contexts.
scipy	1.4.1	2019b	broadwell, skylake, gpu	iris	Mathematics	SciPy is a collection of mathematical algorithms and convenience functions built on the Numpy extension for Python.
setuptools	41.0.1	2019b	broadwell, skylake	iris	Development	Easily download, build, install, upgrade, and uninstall Python packages
snappy	1.1.7, 1.1.8	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	Snappy is a compression/decompression library. It does not aim for maximum compression, or compatibility with any other compression library; instead, it aims for very high speeds and reasonable compression.
sparsehash	2.0.3, 2.0.4	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Development	An extremely memory-efficient hash_map implementation. 2 bits/entry overhead! The SparseHash library contains several hash-map implementations, including implementations that optimize for space or speed.
spglib-python	1.16.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	Chemistry	Spglib for Python. Spglib is a library for finding and handling crystal symmetries written in C.
tbb	2019_U9, 2020.2, 2020.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Libraries	Intel(R) Threading Building Blocks (Intel(R) TBB) lets you easily write parallel C++ programs that take full advantage of multicore performance, that are portable, composable and have future-proof scalability.
texinfo	6.7	2019b	broadwell, skylake	iris	Development	Texinfo is the official documentation format of the GNU project.
tqdm	4.56.2	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries	A fast, extensible progress bar for Python and CLI
typing-extensions	3.7.4.3	2019b, 2020b	gpu, broadwell, epyc, skylake	iris, aion	Development	Typing Extensions – Backported and Experimental Type Hints for Python
util-linux	2.34, 2.36	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Utilities	Set of Linux utilities
x264	20190925, 20201026	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	x264 is a free software library and application for encoding video streams into the H.264/MPEG-4 AVC compression format, and is released under the terms of the GNU GPL.
x265	3.2, 3.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Visualisation	x265 is a free software library and application for encoding video streams into the H.265 AVC compression format, and is released under the terms of the GNU GPL.
xorg-macros	1.19.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Development	X.org macros utilities.
xprop	1.2.4, 1.2.5	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Visualisation	The xprop utility is for displaying window and font properties in an X server. One window or font is selected using the command line arguments or possibly in the case of a window, by clicking on the desired window. A list of properties is then given, possibly with formatting information.
yaff	1.6.0	2019b	broadwell, skylake	iris	Chemistry	Yaff stands for 'Yet another force field'. It is a pythonic force-field code.
zlib	1.2.11	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Libraries	zlib is designed to be a free, general-purpose, legally unencumbered -- that is, not covered by any patents -- lossless data-compression library for use on virtually any computer hardware and operating system.
zstd	1.4.5	2020b	broadwell, epyc, skylake, gpu	aion, iris	Libraries

Biology

Alphabetical list of available ULHPC software belonging to the 'bio' category. To load a software of this category, use: module load bio/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
ABySS	2.2.5	2020b	broadwell, epyc, skylake	aion, iris	Assembly By Short Sequences - a de novo, parallel, paired-end sequence assembler
BEDTools	2.29.2, 2.30.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	BEDTools: a powerful toolset for genome arithmetic. The BEDTools utilities allow one to address common genomics tasks such as finding feature overlaps and computing coverage. The utilities are largely based on four widely-used file formats: BED, GFF/GTF, VCF, and SAM/BAM.
BLAST+	2.11.0, 2.9.0	2020b, 2019b	broadwell, epyc, skylake	aion, iris	Basic Local Alignment Search Tool, or BLAST, is an algorithm for comparing primary biological sequence information, such as the amino-acid sequences of different proteins or the nucleotides of DNA sequences.
BWA	0.7.17	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Burrows-Wheeler Aligner (BWA) is an efficient program that aligns relatively short nucleotide sequences against a long reference sequence such as the human genome.
BamTools	2.5.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	BamTools provides both a programmer's API and an end-user's toolkit for handling BAM files.
BioPerl	1.7.2, 1.7.8	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Bioperl is the product of a community effort to produce Perl code which is useful in biology. Examples include Sequence objects, Alignment objects and database searching objects.
Bowtie2	2.3.5.1, 2.4.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters, and particularly good at aligning to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an FM Index to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 GB. Bowtie 2 supports gapped, local, and paired-end alignment modes.
FastQC	0.11.9	2019b, 2020b	broadwell, skylake, epyc	iris, aion	FastQC is a quality control application for high throughput sequence data. It reads in sequence data in a variety of formats and can either provide an interactive application to review the results of several different QC checks, or create an HTML based report which can be integrated into a pipeline.
GROMACS	2019.4, 2019.6, 2020, 2021, 2021.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	GROMACS is a versatile package to perform molecular dynamics, i.e. simulate the Newtonian equations of motion for systems with hundreds to millions of particles. This is a CPU only build, containing both MPI and threadMPI builds for both single and double precision. It also contains the gmxapi extension for the single precision MPI build.
HTSlib	1.10.2, 1.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	A C library for reading/writing high-throughput sequencing data. This package includes the utilities bgzip and tabix
Jellyfish	2.3.0	2019b	broadwell, skylake	iris	Jellyfish is a tool for fast, memory-efficient counting of k-mers in DNA.
SAMtools	1.10, 1.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	SAM Tools provide various utilities for manipulating alignments in the SAM format, including sorting, merging, indexing and generating alignments in a per-position format.
Salmon	1.1.0	2019b	broadwell, skylake	iris	Salmon is a wicked-fast program to produce a highly-accurate, transcript-level quantification estimates from RNA-seq data.
TopHat	2.1.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	TopHat is a fast splice junction mapper for RNA-Seq reads.
Trinity	2.10.0	2019b	broadwell, skylake	iris	Trinity represents a novel method for the efficient and robust de novo reconstruction of transcriptomes from RNA-Seq data. Trinity combines three independent software modules: Inchworm, Chrysalis, and Butterfly, applied sequentially to process large volumes of RNA-Seq reads.
kallisto	0.46.1	2019b	broadwell, skylake	iris	kallisto is a program for quantifying abundances of transcripts from RNA-Seq data, or more generally of target sequences using high-throughput sequencing reads.

Numerical libraries

Alphabetical list of available ULHPC software belonging to the 'numlib' category. To load a software of this category, use: module load numlib/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
Armadillo	10.5.3, 9.900.1	2020b, 2019b	broadwell, epyc, skylake	aion, iris	Armadillo is an open-source C++ linear algebra library (matrix maths) aiming towards a good balance between speed and ease of use. Integer, floating point and complex numbers are supported, as well as a subset of trigonometric and statistics functions.
CGAL	4.14.1, 5.2	2019b, 2020b	broadwell, skylake, epyc	iris, aion	The goal of the CGAL Open Source Project is to provide easy access to efficient and reliable geometric algorithms in the form of a C++ library.
FFTW	3.3.8	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	FFTW is a C subroutine library for computing the discrete Fourier transform (DFT) in one or more dimensions, of arbitrary input size, and of both real and complex data.
GSL	2.6	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The GNU Scientific Library (GSL) is a numerical library for C and C++ programmers. The library provides a wide range of mathematical routines such as random number generators, special functions and least-squares fitting.
Hypre	2.20.0	2020b	broadwell, epyc, skylake	aion, iris	Hypre is a library for solving large, sparse linear systems of equations on massively parallel computers. The problems of interest arise in the simulation codes being developed at LLNL and elsewhere to study physical phenomena in the defense, environmental, energy, and biological sciences.
NLopt	2.6.1, 2.6.2	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	NLopt is a free/open-source library for nonlinear optimization, providing a common interface for a number of different free optimization routines available online as well as original implementations of various other algorithms.
OpenBLAS	0.3.12, 0.3.7	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	OpenBLAS is an optimized BLAS library based on GotoBLAS2 1.13 BSD version.
PETSc	3.14.4	2020b	broadwell, epyc, skylake	aion, iris	PETSc, pronounced PET-see (the S is silent), is a suite of data structures and routines for the scalable (parallel) solution of scientific applications modeled by partial differential equations.
SLEPc	3.14.2	2020b	broadwell, epyc, skylake	aion, iris	SLEPc (Scalable Library for Eigenvalue Problem Computations) is a software library for the solution of large scale sparse eigenvalue problems on parallel computers. It is an extension of PETSc and can be used for either standard or generalized eigenproblems, with real or complex arithmetic. It can also be used for computing a partial SVD of a large, sparse, rectangular matrix, and to solve quadratic eigenvalue problems.
ScaLAPACK	2.0.2, 2.1.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The ScaLAPACK (or Scalable LAPACK) library includes a subset of LAPACK routines redesigned for distributed memory MIMD parallel computers.
SuiteSparse	5.8.1	2020b	broadwell, epyc, skylake	aion, iris	SuiteSparse is a collection of libraries manipulate sparse matrices.
arpack-ng	3.7.0, 3.8.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	ARPACK is a collection of Fortran77 subroutines designed to solve large scale eigenvalue problems.
cuDNN	7.6.4.38, 8.0.4.30, 8.0.5.39	2019b, 2020b	gpu	iris	The NVIDIA CUDA Deep Neural Network library (cuDNN) is a GPU-accelerated library of primitives for deep neural networks.
imkl	2019.5.281, 2020.4.304	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Intel Math Kernel Library is a library of highly optimized, extensively threaded math routines for science, engineering, and financial applications that require maximum performance. Core math functions include BLAS, LAPACK, ScaLAPACK, Sparse Solvers, Fast Fourier Transforms, Vector Math, and more.

Performance measurements

Alphabetical list of available ULHPC software belonging to the 'perf' category. To load a software of this category, use: module load perf/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
Advisor	2019_update5	2019b	broadwell, skylake	iris	Vectorization Optimization and Thread Prototyping - Vectorize & thread code or performance “dies” - Easy workflow + data + tips = faster code faster - Prioritize, Prototype & Predict performance gain
CubeGUI	4.4.4	2019b	broadwell, skylake	iris	Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube graphical report explorer.
CubeLib	4.4.4	2019b	broadwell, skylake	iris	Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube general purpose C++ library component and command-line tools.
CubeWriter	4.4.3	2019b	broadwell, skylake	iris	Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube high-performance C writer library component.
OPARI2	2.0.5	2019b	broadwell, skylake	iris	OPARI2, the successor of Forschungszentrum Juelich's OPARI, is a source-to-source instrumentation tool for OpenMP and hybrid codes. It surrounds OpenMP directives and runtime library calls with calls to the POMP2 measurement interface.
OTF2	2.2	2019b	broadwell, skylake	iris	The Open Trace Format 2 is a highly scalable, memory efficient event trace data format plus support library. It is the new standard trace format for Scalasca, Vampir, and TAU and is open for other tools.
PAPI	6.0.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	PAPI provides the tool designer and application engineer with a consistent interface and methodology for use of the performance counter hardware found in most major microprocessors. PAPI enables software engineers to see, in near real time, the relation between software performance and processor events. In addition Component PAPI provides access to a collection of components that expose performance measurement opportunites across the hardware and software stack.
PDT	3.25	2019b	broadwell, skylake	iris	Program Database Toolkit (PDT) is a framework for analyzing source code written in several programming languages and for making rich program knowledge accessible to developers of static and dynamic analysis tools. PDT implements a standard program representation, the program database (PDB), that can be accessed in a uniform way through a class library supporting common PDB operations.
Scalasca	2.5	2019b	broadwell, skylake	iris	Scalasca is a software tool that supports the performance optimization of parallel programs by measuring and analyzing their runtime behavior. The analysis identifies potential performance bottlenecks -- in particular those concerning communication and synchronization -- and offers guidance in exploring their causes.
Score-P	6.0	2019b	broadwell, skylake	iris	The Score-P measurement infrastructure is a highly scalable and easy-to-use tool suite for profiling, event tracing, and online analysis of HPC applications.

Physics

Alphabetical list of available ULHPC software belonging to the 'phys' category. To load a software of this category, use: module load phys/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
Elk	6.3.2, 7.0.12	2019b, 2020b	broadwell, skylake, epyc	iris, aion	An all-electron full-potential linearised augmented-plane wave (FP-LAPW) code with many advanced features. Written originally at Karl-Franzens-Universität Graz as a milestone of the EXCITING EU Research and Training Network, the code is designed to be as simple as possible so that new developments in the field of density functional theory (DFT) can be added quickly and reliably.
FDS	6.7.1, 6.7.6	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Fire Dynamics Simulator (FDS) is a large-eddy simulation (LES) code for low-speed flows, with an emphasis on smoke and heat transport from fires.
Meep	1.4.3	2019b	broadwell, skylake	iris	Meep (or MEEP) is a free finite-difference time-domain (FDTD) simulation software package developed at MIT to model electromagnetic systems.
UDUNITS	2.2.26	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	UDUNITS supports conversion of unit specifications between formatted and binary forms, arithmetic manipulation of units, and conversion of values between compatible scales of measurement.
VASP	5.4.4, 6.2.1	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	The Vienna Ab initio Simulation Package (VASP) is a computer program for atomic scale materials modelling, e.g. electronic structure calculations and quantum-mechanical molecular dynamics, from first principles.

System-level software

Alphabetical list of available ULHPC software belonging to the 'system' category. To load a software of this category, use: module load system/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
CUDA	10.1.243, 11.1.1	2019b, 2020b	gpu	iris	CUDA (formerly Compute Unified Device Architecture) is a parallel computing platform and programming model created by NVIDIA and implemented by the graphics processing units (GPUs) that they produce. CUDA gives developers access to the virtual instruction set and memory of the parallel computational elements in CUDA GPUs.
CUDAcore	11.1.1	2020b	gpu	iris	CUDA (formerly Compute Unified Device Architecture) is a parallel computing platform and programming model created by NVIDIA and implemented by the graphics processing units (GPUs) that they produce. CUDA gives developers access to the virtual instruction set and memory of the parallel computational elements in CUDA GPUs.
ULHPC-bd	2020b	2020b	broadwell, epyc, skylake	aion, iris	Generic Module bundle for BigData Analytics software in use on the UL HPC Facility
ULHPC-bio	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Generic Module bundle for Bioinformatics, biology and biomedical software in use on the UL HPC Facility, especially at LCSB
ULHPC-cs	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Generic Module bundle for Computational science software in use on the UL HPC Facility, including: - Computer Aided Engineering, incl. CFD - Chemistry, Computational Chemistry and Quantum Chemistry - Data management & processing tools - Earth Sciences - Quantum Computing - Physics and physical systems simulations
ULHPC-dl	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Generic Module bundle for (CPU-version) of AI / Deep Learning / Machine Learning software in use on the UL HPC Facility
ULHPC-gpu	2019b, 2020b	2019b, 2020b	gpu	iris	Generic Module bundle for GPU accelerated User Software in use on the UL HPC Facility
ULHPC-math	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Generic Module bundle for High-level mathematical software and Linear Algrebra libraries in use on the UL HPC Facility
ULHPC-toolchains	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Generic Module bundle that contains all the dependencies required to enable toolchains and building tools/programming language in use on the UL HPC Facility
ULHPC-tools	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Misc tools, incl. - perf: Performance tools - tools: General purpose tools
hwloc	1.11.12, 2.2.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The Portable Hardware Locality (hwloc) software package provides a portable abstraction (across OS, versions, architectures, ...) of the hierarchical topology of modern architectures, including NUMA memory nodes, sockets, shared caches, cores and simultaneous multithreading. It also gathers various system attributes such as cache and memory information as well as the locality of I/O devices such as network interfaces, InfiniBand HCAs or GPUs. It primarily aims at helping applications with gathering information about modern computing hardware so as to exploit it accordingly and efficiently.
libpciaccess	0.14, 0.16	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Generic PCI access library.

Toolchains (software stacks)

Alphabetical list of available ULHPC software belonging to the 'toolchain' category. To load a software of this category, use: module load toolchain/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
foss	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	GNU Compiler Collection (GCC) based compiler toolchain, including OpenMPI for MPI support, OpenBLAS (BLAS and LAPACK support), FFTW and ScaLAPACK.
fosscuda	2019b, 2020b	2019b, 2020b	gpu	iris	GCC based compiler toolchain with CUDA support, and including OpenMPI for MPI support, OpenBLAS (BLAS and LAPACK support), FFTW and ScaLAPACK.
gcccuda	2019b, 2020b	2019b, 2020b	gpu	iris	GNU Compiler Collection (GCC) based compiler toolchain, along with CUDA toolkit.
gompi	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc	iris, aion	GNU Compiler Collection (GCC) based compiler toolchain, including OpenMPI for MPI support.
gompic	2019b, 2020b	2019b, 2020b	gpu	iris	GNU Compiler Collection (GCC) based compiler toolchain along with CUDA toolkit, including OpenMPI for MPI support with CUDA features enabled.
iccifortcuda	2019b, 2020b	2019b, 2020b	gpu	iris	Intel C, C++ & Fortran compilers with CUDA toolkit
iimpi	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Intel C/C++ and Fortran compilers, alongside Intel MPI.
iimpic	2019b, 2020b	2019b, 2020b	gpu	iris	Intel C/C++ and Fortran compilers, alongside Intel MPI and CUDA.
intel	2019b, 2020b	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Compiler toolchain including Intel compilers, Intel MPI and Intel Math Kernel Library (MKL).
intelcuda	2019b, 2020b	2019b, 2020b	gpu	iris	Intel Cluster Toolkit Compiler Edition provides Intel C/C++ and Fortran compilers, Intel MPI & Intel MKL, with CUDA toolkit

Utilities

Alphabetical list of available ULHPC software belonging to the 'tools' category. To load a software of this category, use: module load tools/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
ANSYS	19.4, 21.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	ANSYS simulation software enables organizations to confidently predict how their products will operate in the real world. We believe that every product is a promise of something greater.
ArmForge	20.0.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	The industry standard development package for C, C++ and Fortran high performance code on Linux. Forge is designed to handle the complex software projects - including parallel, multiprocess and multithreaded code. Arm Forge combines an industry-leading debugger, Arm DDT, and an out-of-the-box-ready profiler, Arm MAP.
ArmReports	20.0.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Arm Performance Reports - a low-overhead tool that produces one-page text and HTML reports summarizing and characterizing both scalar and MPI application performance. Arm Performance Reports runs transparently on optimized production-ready codes by adding a single command to your scripts, and provides the most effective way to characterize and understand the performance of HPC application runs.
Aspera-CLI	3.9.1, 3.9.6	2019b, 2020b	broadwell, skylake, epyc	iris, aion	IBM Aspera Command-Line Interface (the Aspera CLI) is a collection of Aspera tools for performing high-speed, secure data transfers from the command line. The Aspera CLI is for users and organizations who want to automate their transfer workflows.
DB	18.1.32, 18.1.40	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	Berkeley DB enables the development of custom data management solutions, without the overhead traditionally associated with such custom projects.
DMTCP	2.5.2	2019b	broadwell, skylake	iris	DMTCP is a tool to transparently checkpoint the state of multiple simultaneous applications, including multi-threaded and distributed applications. It operates directly on the user binary executable, without any Linux kernel modules or other kernel modifications.
EasyBuild	4.3.0, 4.3.3, 4.4.1, 4.4.2, 4.5.4	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	EasyBuild is a software build and installation framework written in Python that allows you to install software in a structured, repeatable and robust way.
GLPK	4.65	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	The GLPK (GNU Linear Programming Kit) package is intended for solving large-scale linear programming (LP), mixed integer programming (MIP), and other related problems. It is a set of routines written in ANSI C and organized in the form of a callable library.
Ghostscript	9.50, 9.53.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Ghostscript is a versatile processor for PostScript data with the ability to render PostScript to different targets. It used to be part of the cups printing stack, but is no longer used for that.
Hadoop	2.10.0	2020b	broadwell, epyc, skylake	aion, iris	Hadoop MapReduce by Cloudera
Horovod	0.19.1, 0.22.0	2019b, 2020b	broadwell, skylake, gpu	iris	Horovod is a distributed training framework for TensorFlow.
Inspector	2019_update5	2019b	broadwell, skylake	iris	Intel Inspector XE is an easy to use memory error checker and thread checker for serial and parallel applications
Meson	0.51.2, 0.55.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Meson is a cross-platform build system designed to be both as fast and as user friendly as possible.
Ninja	1.10.1, 1.9.0	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Ninja is a small build system with a focus on speed.
Singularity	3.6.0, 3.8.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	SingularityCE is an open source container platform designed to be simple, fast, and secure. Singularity is optimized for EPC and HPC workloads, allowing untrusted users to run untrusted containers in a trusted way.
Sumo	1.3.1	2019b	broadwell, skylake	iris	Sumo is an open source, highly portable, microscopic and continuous traffic simulation package designed to handle large road networks.
Szip	2.1.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Szip compression software, providing lossless compression of scientific data
UnZip	6.0	2020b	broadwell, epyc, skylake, gpu	aion, iris	UnZip is an extraction utility for archives compressed in .zip format (also called "zipfiles"). Although highly compatible both with PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP's own Zip program, our primary objectives have been portability and non-MSDOS functionality.
VTune	2019_update8, 2020_update3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Intel VTune Amplifier XE is the premier performance profiler for C, C++, C#, Fortran, Assembly and Java.
XZ	5.2.4, 5.2.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	xz: XZ utilities
Z3	4.8.10	2020b	broadwell, epyc, skylake, gpu	aion, iris	Z3 is a theorem prover from Microsoft Research.
Zip	3.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Zip is a compression and file packaging/archive utility. Although highly compatible both with PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP's own UnZip, our primary objectives have been portability and other-than-MSDOS functionality
archspec	0.1.0	2019b	broadwell, skylake	iris	A library for detecting, labeling, and reasoning about microarchitectures
binutils	2.32, 2.35	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	binutils: GNU binary utilities
bokeh	2.2.3	2020b	broadwell, epyc, skylake, gpu	aion, iris	Statistical and novel interactive HTML plots for Python
bzip2	1.0.8	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.
cURL	7.66.0, 7.72.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more.
expat	2.2.7, 2.2.9	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Expat is an XML parser library written in C. It is a stream-oriented parser in which an application registers handlers for things the parser might find in the XML document (like start tags)
gettext	0.19.8.1, 0.20.1, 0.21	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	GNU 'gettext' is an important step for the GNU Translation Project, as it is an asset on which we may build many other steps. This package offers to programmers, translators, and even users, a well integrated set of tools and documentation
git	2.23.0, 2.28.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.
gocryptfs	1.7.1, 2.0.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Encrypted overlay filesystem written in Go. gocryptfs uses file-based encryption that is implemented as a mountable FUSE filesystem. Each file in gocryptfs is stored as one corresponding encrypted file on the hard disk.
groff	1.22.4	2020b	broadwell, epyc, skylake, gpu	aion, iris	Groff (GNU troff) is a typesetting system that reads plain text mixed with formatting commands and produces formatted output.
gzip	1.10	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	gzip (GNU zip) is a popular data compression program as a replacement for compress
help2man	1.47.16, 1.47.4, 1.47.8	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	help2man produces simple manual pages from the '--help' and '--version' output of other commands.
hypothesis	4.44.2, 5.41.2, 5.41.5	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Hypothesis is an advanced testing library for Python. It lets you write tests which are parametrized by a source of examples, and then generates simple and comprehensible examples that make your tests fail. This lets you find more bugs in your code with less work.
itac	2019.4.036	2019b	broadwell, skylake	iris	The Intel Trace Collector is a low-overhead tracing library that performs event-based tracing in applications. The Intel Trace Analyzer provides a convenient way to monitor application activities gathered by the Intel Trace Collector through graphical displays.
libarchive	3.4.3	2020b	broadwell, epyc, skylake, gpu	aion, iris	Multi-format archive and compression library
networkx	2.5	2020b	broadwell, epyc, skylake, gpu	aion, iris	NetworkX is a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.
numactl	2.0.12, 2.0.13	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The numactl program allows you to run your application program on specific cpu's and memory nodes. It does this by supplying a NUMA memory policy to the operating system before running your program. The libnuma library provides convenient ways for you to add NUMA memory policies into your own program.
re2c	1.2.1, 2.0.3	2019b, 2020b	broadwell, skylake, epyc	iris, aion	re2c is a free and open-source lexer generator for C and C++. Its main goal is generating fast lexers: at least as fast as their reasonably optimized hand-coded counterparts. Instead of using traditional table-driven approach, re2c encodes the generated finite state automata directly in the form of conditional jumps and comparisons.
util-linux	2.34, 2.36	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Set of Linux utilities

Visualisation

Alphabetical list of available ULHPC software belonging to the 'vis' category. To load a software of this category, use: module load vis/<software>[/<version>]

Software	Versions	Swsets	Architectures	Clusters	Description
ATK	2.34.1, 2.36.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	ATK provides the set of accessibility interfaces that are implemented by other toolkits and applications. Using the ATK interfaces, accessibility tools have full access to view and control running applications.
FFmpeg	4.2.1, 4.3.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	A complete, cross-platform solution to record, convert and stream audio and video.
FLTK	1.3.5	2019b, 2020b	broadwell, skylake, epyc	iris, aion	FLTK is a cross-platform C++ GUI toolkit for UNIX/Linux (X11), Microsoft Windows, and MacOS X. FLTK provides modern GUI functionality without the bloat and supports 3D graphics via OpenGL and its built-in GLUT emulation.
FreeImage	3.18.0	2020b	broadwell, epyc, skylake	aion, iris	FreeImage is an Open Source library project for developers who would like to support popular graphics image formats like PNG, BMP, JPEG, TIFF and others as needed by today's multimedia applications. FreeImage is easy to use, fast, multithreading safe.
GLib	2.62.0, 2.66.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	GLib is one of the base libraries of the GTK+ project
GTK+	3.24.13, 3.24.23	2019b, 2020b	broadwell, skylake, epyc	iris, aion	GTK+ is the primary library used to construct user interfaces in GNOME. It provides all the user interface controls, or widgets, used in a common graphical application. Its object-oriented API allows you to construct user interfaces without dealing with the low-level details of drawing and device interaction.
Gdk-Pixbuf	2.38.2, 2.40.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	The Gdk Pixbuf is a toolkit for image loading and pixel buffer manipulation. It is used by GTK+ 2 and GTK+ 3 to load and manipulate images. In the past it was distributed as part of GTK+ 2 but it was split off into a separate package in preparation for the change to GTK+ 3.
HarfBuzz	2.6.4, 2.6.7	2019b, 2020b	broadwell, skylake, epyc	iris, aion	HarfBuzz is an OpenType text shaping engine.
ImageMagick	7.0.10-35, 7.0.9-5	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	ImageMagick is a software suite to create, edit, compose, or convert bitmap images
JasPer	2.0.14, 2.0.24	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The JasPer Project is an open-source initiative to provide a free software-based reference implementation of the codec specified in the JPEG-2000 Part-1 standard.
LittleCMS	2.11, 2.9	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Little CMS intends to be an OPEN SOURCE small-footprint color management engine, with special focus on accuracy and performance.
Mesa	19.1.7, 19.2.1, 20.2.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Mesa is an open-source implementation of the OpenGL specification - a system for rendering interactive 3D graphics.
OpenCV	4.2.0, 4.5.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	OpenCV (Open Source Computer Vision Library) is an open source computer vision and machine learning software library. OpenCV was built to provide a common infrastructure for computer vision applications and to accelerate the use of machine perception in the commercial products. Includes extra modules for OpenCV from the contrib repository.
OpenEXR	2.5.5	2020b	broadwell, epyc, skylake	aion, iris	OpenEXR is a high dynamic-range (HDR) image file format developed by Industrial Light & Magic for use in computer imaging applications
POV-Ray	3.7.0.8	2020b	broadwell, epyc, skylake	aion, iris	The Persistence of Vision Raytracer, or POV-Ray, is a ray tracing program which generates images from a text-based scene description, and is available for a variety of computer platforms. POV-Ray is a high-quality, Free Software tool for creating stunning three-dimensional graphics. The source code is available for those wanting to do their own ports.
Pango	1.44.7, 1.47.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Pango is a library for laying out and rendering of text, with an emphasis on internationalization. Pango can be used anywhere that text layout is needed, though most of the work on Pango so far has been done in the context of the GTK+ widget toolkit. Pango forms the core of text and font handling for GTK+-2.x.
ParaView	5.6.2, 5.8.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	ParaView is a scientific parallel visualizer.
Pillow	6.2.1, 8.0.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Pillow is the 'friendly PIL fork' by Alex Clark and Contributors. PIL is the Python Imaging Library by Fredrik Lundh and Contributors.
PyOpenGL	3.1.5	2020b	broadwell, epyc, skylake	aion, iris	PyOpenGL is the most common cross platform Python binding to OpenGL and related APIs.
PyQt5	5.15.1	2020b	broadwell, epyc, skylake	aion, iris	PyQt5 is a set of Python bindings for v5 of the Qt application framework from The Qt Company. This bundle includes PyQtWebEngine, a set of Python bindings for The Qt Company’s Qt WebEngine framework.
PyQtGraph	0.11.1	2020b	broadwell, epyc, skylake	aion, iris	PyQtGraph is a pure-python graphics and GUI library built on PyQt5/PySide2 and numpy.
Tk	8.6.10, 8.6.9	2020b, 2019b	broadwell, epyc, skylake, gpu	aion, iris	Tk is an open source, cross-platform widget toolchain that provides a library of basic elements for building a graphical user interface (GUI) in many different programming languages.
VMD	1.9.4a51	2020b	broadwell, epyc, skylake	aion, iris	VMD is a molecular visualization program for displaying, animating, and analyzing large biomolecular systems using 3-D graphics and built-in scripting.
VTK	8.2.0, 9.0.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	The Visualization Toolkit (VTK) is an open-source, freely available software system for 3D computer graphics, image processing and visualization. VTK consists of a C++ class library and several interpreted interface layers including Tcl/Tk, Java, and Python. VTK supports a wide variety of visualization algorithms including: scalar, vector, tensor, texture, and volumetric methods; and advanced modeling techniques such as: implicit modeling, polygon reduction, mesh smoothing, cutting, contouring, and Delaunay triangulation.
VirtualGL	2.6.2	2019b	broadwell, skylake	iris	VirtualGL is an open source toolkit that gives any Linux or Unix remote display software the ability to run OpenGL applications with full hardware acceleration.
X11	20190717, 20201008	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The X Window System (X11) is a windowing system for bitmap displays
Xvfb	1.20.9	2020b	broadwell, epyc, skylake, gpu	aion, iris	Xvfb is an X server that can run on machines with no display hardware and no physical input devices. It emulates a dumb framebuffer using virtual memory.
at-spi2-atk	2.34.1, 2.38.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	AT-SPI 2 toolkit bridge
at-spi2-core	2.34.0, 2.38.0	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Assistive Technology Service Provider Interface.
cairo	1.16.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Cairo is a 2D graphics library with support for multiple output devices. Currently supported output targets include the X Window System (via both Xlib and XCB), Quartz, Win32, image buffers, PostScript, PDF, and SVG file output. Experimental backends include OpenGL, BeOS, OS/2, and DirectFB
fontconfig	2.13.1, 2.13.92	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Fontconfig is a library designed to provide system-wide font configuration, customization and application access.
freetype	2.10.1, 2.10.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	FreeType 2 is a software font engine that is designed to be small, efficient, highly customizable, and portable while capable of producing high-quality output (glyph images). It can be used in graphics libraries, display servers, font conversion tools, text image generation tools, and many other products as well.
gnuplot	5.2.8, 5.4.1	2019b, 2020b	broadwell, skylake, epyc	iris, aion	Portable interactive, function plotting utility
libGLU	9.0.1	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	The OpenGL Utility Library (GLU) is a computer graphics library for OpenGL.
matplotlib	3.1.1, 3.3.3	2019b, 2020b	broadwell, skylake, epyc, gpu	iris, aion	matplotlib is a python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. matplotlib can be used in python scripts, the python and ipython shell, web application servers, and six graphical user interface toolkits.
pixman	0.38.4, 0.40.0	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	Pixman is a low-level software library for pixel manipulation, providing features such as image compositing and trapezoid rasterization. Important users of pixman are the cairo graphics library and the X server.
scikit-image	0.18.1	2020b	broadwell, epyc, skylake, gpu	aion, iris	scikit-image is a collection of algorithms for image processing.
x264	20190925, 20201026	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	x264 is a free software library and application for encoding video streams into the H.264/MPEG-4 AVC compression format, and is released under the terms of the GNU GPL.
x265	3.2, 3.3	2019b, 2020b	broadwell, skylake, gpu, epyc	iris, aion	x265 is a free software library and application for encoding video streams into the H.265 AVC compression format, and is released under the terms of the GNU GPL.
xprop	1.2.4, 1.2.5	2019b, 2020b	broadwell, skylake, epyc	iris, aion	The xprop utility is for displaying window and font properties in an X server. One window or font is selected using the command line arguments or possibly in the case of a window, by clicking on the desired window. A list of properties is then given, possibly with formatting information.

2019b

Alphabetical list of available ULHPC software belonging to the '2019b' software set. To load a software of this set, use:


# Eventually: resif-load-swset-[...]
module load <category>/<software>[/<version>]
Software	Architectures	Clusters	Category	Description
ABAQUS 2018	broadwell, skylake	iris	CFD/Finite element modelling	Finite Element Analysis software for modeling, visualization and best-in-class implicit and explicit dynamics FEA.
ACTC 1.1	broadwell, skylake	iris	Libraries	ACTC converts independent triangles into triangle strips or fans.
ANSYS 19.4	broadwell, skylake	iris	Utilities	ANSYS simulation software enables organizations to confidently predict how their products will operate in the real world. We believe that every product is a promise of something greater.
ANSYS 21.1	broadwell, skylake	iris	Utilities	ANSYS simulation software enables organizations to confidently predict how their products will operate in the real world. We believe that every product is a promise of something greater.
ASE 3.19.0	broadwell, skylake	iris	Chemistry	ASE is a python package providing an open source Atomic Simulation Environment in the Python scripting language. From version 3.20.1 we also include the ase-ext package, it contains optional reimplementations in C of functions in ASE. ASE uses it automatically when installed.
ATK 2.34.1	broadwell, skylake	iris	Visualisation	ATK provides the set of accessibility interfaces that are implemented by other toolkits and applications. Using the ATK interfaces, accessibility tools have full access to view and control running applications.
Advisor 2019_update5	broadwell, skylake	iris	Performance measurements	Vectorization Optimization and Thread Prototyping - Vectorize & thread code or performance “dies” - Easy workflow + data + tips = faster code faster - Prioritize, Prototype & Predict performance gain
Anaconda3 2020.02	broadwell, skylake	iris	Programming Languages	Built to complement the rich, open source Python community, the Anaconda platform provides an enterprise-ready data analytics platform that empowers companies to adopt a modern open data science analytics architecture.
ArmForge 20.0.3	broadwell, skylake	iris	Utilities	The industry standard development package for C, C++ and Fortran high performance code on Linux. Forge is designed to handle the complex software projects - including parallel, multiprocess and multithreaded code. Arm Forge combines an industry-leading debugger, Arm DDT, and an out-of-the-box-ready profiler, Arm MAP.
ArmReports 20.0.3	broadwell, skylake	iris	Utilities	Arm Performance Reports - a low-overhead tool that produces one-page text and HTML reports summarizing and characterizing both scalar and MPI application performance. Arm Performance Reports runs transparently on optimized production-ready codes by adding a single command to your scripts, and provides the most effective way to characterize and understand the performance of HPC application runs.
Armadillo 9.900.1	broadwell, skylake	iris	Numerical libraries	Armadillo is an open-source C++ linear algebra library (matrix maths) aiming towards a good balance between speed and ease of use. Integer, floating point and complex numbers are supported, as well as a subset of trigonometric and statistics functions.
Arrow 0.16.0	broadwell, skylake	iris	Data processing	Apache Arrow (incl. PyArrow Python bindings)), a cross-language development platform for in-memory data.
Aspera-CLI 3.9.1	broadwell, skylake	iris	Utilities	IBM Aspera Command-Line Interface (the Aspera CLI) is a collection of Aspera tools for performing high-speed, secure data transfers from the command line. The Aspera CLI is for users and organizations who want to automate their transfer workflows.
Autoconf 2.69	broadwell, skylake, gpu	iris	Development	Autoconf is an extensible package of M4 macros that produce shell scripts to automatically configure software source code packages. These scripts can adapt the packages to many kinds of UNIX-like systems without manual user intervention. Autoconf creates a configuration script for a package from a template file that lists the operating system features that the package can use, in the form of M4 macro calls.
Automake 1.16.1	broadwell, skylake, gpu	iris	Development	Automake: GNU Standards-compliant Makefile generator
Autotools 20180311	broadwell, skylake, gpu	iris	Development	This bundle collect the standard GNU build tools: Autoconf, Automake and libtool
BEDTools 2.29.2	broadwell, skylake	iris	Biology	BEDTools: a powerful toolset for genome arithmetic. The BEDTools utilities allow one to address common genomics tasks such as finding feature overlaps and computing coverage. The utilities are largely based on four widely-used file formats: BED, GFF/GTF, VCF, and SAM/BAM.
BLAST+ 2.9.0	broadwell, skylake	iris	Biology	Basic Local Alignment Search Tool, or BLAST, is an algorithm for comparing primary biological sequence information, such as the amino-acid sequences of different proteins or the nucleotides of DNA sequences.
BWA 0.7.17	broadwell, skylake	iris	Biology	Burrows-Wheeler Aligner (BWA) is an efficient program that aligns relatively short nucleotide sequences against a long reference sequence such as the human genome.
BamTools 2.5.1	broadwell, skylake	iris	Biology	BamTools provides both a programmer's API and an end-user's toolkit for handling BAM files.
Bazel 0.26.1	gpu	iris	Development	Bazel is a build tool that builds code quickly and reliably. It is used to build the majority of Google's software.
Bazel 0.29.1	gpu	iris	Development	Bazel is a build tool that builds code quickly and reliably. It is used to build the majority of Google's software.
BioPerl 1.7.2	broadwell, skylake	iris	Biology	Bioperl is the product of a community effort to produce Perl code which is useful in biology. Examples include Sequence objects, Alignment objects and database searching objects.
Bison 3.3.2	broadwell, skylake, gpu	iris	Programming Languages	Bison is a general-purpose parser generator that converts an annotated context-free grammar into a deterministic LR or generalized LR (GLR) parser employing LALR(1) parser tables.
Boost 1.71.0	broadwell, skylake	iris	Development	Boost provides free peer-reviewed portable C++ source libraries.
Bowtie2 2.3.5.1	broadwell, skylake	iris	Biology	Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters, and particularly good at aligning to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an FM Index to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 GB. Bowtie 2 supports gapped, local, and paired-end alignment modes.
CGAL 4.14.1	broadwell, skylake	iris	Numerical libraries	The goal of the CGAL Open Source Project is to provide easy access to efficient and reliable geometric algorithms in the form of a C++ library.
CMake 3.15.3	broadwell, skylake, gpu	iris	Development	CMake, the cross-platform, open-source build system. CMake is a family of tools designed to build, test and package software.
CPLEX 12.10	broadwell, skylake	iris	Mathematics	IBM ILOG CPLEX Optimizer's mathematical programming technology enables analytical decision support for improving efficiency, reducing costs, and increasing profitability.
CRYSTAL 17	broadwell, skylake	iris	Chemistry	The CRYSTAL package performs ab initio calculations of the ground state energy, energy gradient, electronic wave function and properties of periodic systems. Hartree-Fock or Kohn- Sham Hamiltonians (that adopt an Exchange-Correlation potential following the postulates of Density-Functional Theory) can be used.
CUDA 10.1.243	gpu	iris	System-level software	CUDA (formerly Compute Unified Device Architecture) is a parallel computing platform and programming model created by NVIDIA and implemented by the graphics processing units (GPUs) that they produce. CUDA gives developers access to the virtual instruction set and memory of the parallel computational elements in CUDA GPUs.
Clang 9.0.1	broadwell, skylake, gpu	iris	Compilers	C, C++, Objective-C compiler, based on LLVM. Does not include C++ standard library -- use libstdc++ from GCC.
CubeGUI 4.4.4	broadwell, skylake	iris	Performance measurements	Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube graphical report explorer.
CubeLib 4.4.4	broadwell, skylake	iris	Performance measurements	Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube general purpose C++ library component and command-line tools.
CubeWriter 4.4.3	broadwell, skylake	iris	Performance measurements	Cube, which is used as performance report explorer for Scalasca and Score-P, is a generic tool for displaying a multi-dimensional performance space consisting of the dimensions (i) performance metric, (ii) call path, and (iii) system resource. Each dimension can be represented as a tree, where non-leaf nodes of the tree can be collapsed or expanded to achieve the desired level of granularity. This module provides the Cube high-performance C writer library component.
DB 18.1.32	broadwell, skylake	iris	Utilities	Berkeley DB enables the development of custom data management solutions, without the overhead traditionally associated with such custom projects.
DBus 1.13.12	broadwell, skylake	iris	Development	D-Bus is a message bus system, a simple way for applications to talk to one another. In addition to interprocess communication, D-Bus helps coordinate process lifecycle; it makes it simple and reliable to code a "single instance" application or daemon, and to launch applications and daemons on demand when their services are needed.
DMTCP 2.5.2	broadwell, skylake	iris	Utilities	DMTCP is a tool to transparently checkpoint the state of multiple simultaneous applications, including multi-threaded and distributed applications. It operates directly on the user binary executable, without any Linux kernel modules or other kernel modifications.
Dakota 6.11.0	broadwell, skylake	iris	Mathematics	The Dakota project delivers both state-of-the-art research and robust, usable software for optimization and UQ. Broadly, the Dakota software's advanced parametric analyses enable design exploration, model calibration, risk analysis, and quantification of margins and uncertainty with computational models."
Doxygen 1.8.16	broadwell, skylake, gpu	iris	Development	Doxygen is a documentation system for C++, C, Java, Objective-C, Python, IDL (Corba and Microsoft flavors), Fortran, VHDL, PHP, C#, and to some extent D.
ELPA 2019.11.001	broadwell	iris	Mathematics	Eigenvalue SoLvers for Petaflop-Applications .
EasyBuild 4.3.0	broadwell, skylake, gpu	iris	Utilities	EasyBuild is a software build and installation framework written in Python that allows you to install software in a structured, repeatable and robust way.
EasyBuild 4.3.3	broadwell, skylake, gpu	iris	Utilities	EasyBuild is a software build and installation framework written in Python that allows you to install software in a structured, repeatable and robust way.
Eigen 3.3.7	broadwell, skylake, gpu	iris	Mathematics	Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.
Elk 6.3.2	broadwell, skylake	iris	Physics	An all-electron full-potential linearised augmented-plane wave (FP-LAPW) code with many advanced features. Written originally at Karl-Franzens-Universität Graz as a milestone of the EXCITING EU Research and Training Network, the code is designed to be as simple as possible so that new developments in the field of density functional theory (DFT) can be added quickly and reliably.
FDS 6.7.1	broadwell, skylake	iris	Physics	Fire Dynamics Simulator (FDS) is a large-eddy simulation (LES) code for low-speed flows, with an emphasis on smoke and heat transport from fires.
FFTW 3.3.8	broadwell, skylake, gpu	iris	Numerical libraries	FFTW is a C subroutine library for computing the discrete Fourier transform (DFT) in one or more dimensions, of arbitrary input size, and of both real and complex data.
FFmpeg 4.2.1	broadwell, skylake, gpu	iris	Visualisation	A complete, cross-platform solution to record, convert and stream audio and video.
FLTK 1.3.5	broadwell, skylake	iris	Visualisation	FLTK is a cross-platform C++ GUI toolkit for UNIX/Linux (X11), Microsoft Windows, and MacOS X. FLTK provides modern GUI functionality without the bloat and supports 3D graphics via OpenGL and its built-in GLUT emulation.
FastQC 0.11.9	broadwell, skylake	iris	Biology	FastQC is a quality control application for high throughput sequence data. It reads in sequence data in a variety of formats and can either provide an interactive application to review the results of several different QC checks, or create an HTML based report which can be integrated into a pipeline.
FriBidi 1.0.5	broadwell, skylake, gpu	iris	Programming Languages	The Free Implementation of the Unicode Bidirectional Algorithm.
GCC 8.3.0	broadwell, skylake, gpu	iris	Compilers	The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Java, and Ada, as well as libraries for these languages (libstdc++, libgcj,...).
GCCcore 8.3.0	broadwell, skylake, gpu	iris	Compilers	The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Java, and Ada, as well as libraries for these languages (libstdc++, libgcj,...).
GDAL 3.0.2	broadwell, skylake, gpu	iris	Data processing	GDAL is a translator library for raster geospatial data formats that is released under an X/MIT style Open Source license by the Open Source Geospatial Foundation. As a library, it presents a single abstract data model to the calling application for all supported formats. It also comes with a variety of useful commandline utilities for data translation and processing.
GDB 9.1	broadwell, skylake	iris	Debugging	The GNU Project Debugger
GEOS 3.8.0	broadwell, skylake, gpu	iris	Mathematics	GEOS (Geometry Engine - Open Source) is a C++ port of the Java Topology Suite (JTS)
GLPK 4.65	broadwell, skylake	iris	Utilities	The GLPK (GNU Linear Programming Kit) package is intended for solving large-scale linear programming (LP), mixed integer programming (MIP), and other related problems. It is a set of routines written in ANSI C and organized in the form of a callable library.
GLib 2.62.0	broadwell, skylake, gpu	iris	Visualisation	GLib is one of the base libraries of the GTK+ project
GMP 6.1.2	broadwell, skylake, gpu	iris	Mathematics	GMP is a free library for arbitrary precision arithmetic, operating on signed integers, rational numbers, and floating point numbers.
GObject-Introspection 1.63.1	broadwell, skylake	iris	Development	GObject introspection is a middleware layer between C libraries (using GObject) and language bindings. The C library can be scanned at compile time and generate a metadata file, in addition to the actual native C library. Then at runtime, language bindings can read this metadata and automatically provide bindings to call into the C library.
GPAW-setups 0.9.20000	broadwell, skylake	iris	Chemistry	PAW setup for the GPAW Density Functional Theory package. Users can install setups manually using 'gpaw install-data' or use setups from this package. The versions of GPAW and GPAW-setups can be intermixed.
GPAW 20.1.0	broadwell, skylake	iris	Chemistry	GPAW is a density-functional theory (DFT) Python code based on the projector-augmented wave (PAW) method and the atomic simulation environment (ASE). It uses real-space uniform grids and multigrid methods or atom-centered basis-functions.
GROMACS 2019.4	broadwell, skylake	iris	Biology	GROMACS is a versatile package to perform molecular dynamics, i.e. simulate the Newtonian equations of motion for systems with hundreds to millions of particles. This is a CPU only build, containing both MPI and threadMPI builds for both single and double precision. It also contains the gmxapi extension for the single precision MPI build.
GROMACS 2019.6	broadwell, skylake	iris	Biology	GROMACS is a versatile package to perform molecular dynamics, i.e. simulate the Newtonian equations of motion for systems with hundreds to millions of particles. This is a CPU only build, containing both MPI and threadMPI builds for both single and double precision. It also contains the gmxapi extension for the single precision MPI build.
GROMACS 2020	broadwell, skylake	iris	Biology	GROMACS is a versatile package to perform molecular dynamics, i.e. simulate the Newtonian equations of motion for systems with hundreds to millions of particles. This is a CPU only build, containing both MPI and threadMPI builds for both single and double precision. It also contains the gmxapi extension for the single precision MPI build.
GSL 2.6	broadwell, skylake, gpu	iris	Numerical libraries	The GNU Scientific Library (GSL) is a numerical library for C and C++ programmers. The library provides a wide range of mathematical routines such as random number generators, special functions and least-squares fitting.
GTK+ 3.24.13	broadwell, skylake	iris	Visualisation	GTK+ is the primary library used to construct user interfaces in GNOME. It provides all the user interface controls, or widgets, used in a common graphical application. Its object-oriented API allows you to construct user interfaces without dealing with the low-level details of drawing and device interaction.
Gdk-Pixbuf 2.38.2	broadwell, skylake	iris	Visualisation	The Gdk Pixbuf is a toolkit for image loading and pixel buffer manipulation. It is used by GTK+ 2 and GTK+ 3 to load and manipulate images. In the past it was distributed as part of GTK+ 2 but it was split off into a separate package in preparation for the change to GTK+ 3.
Ghostscript 9.50	broadwell, skylake, gpu	iris	Utilities	Ghostscript is a versatile processor for PostScript data with the ability to render PostScript to different targets. It used to be part of the cups printing stack, but is no longer used for that.
Go 1.14.1	broadwell, skylake	iris	Compilers	Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.
Guile 1.8.8	broadwell, skylake	iris	Programming Languages	Guile is a programming language, designed to help programmers create flexible applications that can be extended by users or other programmers with plug-ins, modules, or scripts.
Guile 2.2.4	broadwell, skylake	iris	Programming Languages	Guile is a programming language, designed to help programmers create flexible applications that can be extended by users or other programmers with plug-ins, modules, or scripts.
Gurobi 9.0.0	broadwell, skylake	iris	Mathematics	The Gurobi Optimizer is a state-of-the-art solver for mathematical programming. The solvers in the Gurobi Optimizer were designed from the ground up to exploit modern architectures and multi-core processors, using the most advanced implementations of the latest algorithms.
HDF5 1.10.5	broadwell, skylake, gpu	iris	Data processing	HDF5 is a data model, library, and file format for storing and managing data. It supports an unlimited variety of datatypes, and is designed for flexible and efficient I/O and for high volume and complex data.
HTSlib 1.10.2	broadwell, skylake	iris	Biology	A C library for reading/writing high-throughput sequencing data. This package includes the utilities bgzip and tabix
HarfBuzz 2.6.4	broadwell, skylake	iris	Visualisation	HarfBuzz is an OpenType text shaping engine.
Harminv 1.4.1	broadwell, skylake	iris	Mathematics	Harminv is a free program (and accompanying library) to solve the problem of harmonic inversion - given a discrete-time, finite-length signal that consists of a sum of finitely-many sinusoids (possibly exponentially decaying) in a given bandwidth, it determines the frequencies, decay constants, amplitudes, and phases of those sinusoids.
Horovod 0.19.1	broadwell, skylake, gpu	iris	Utilities	Horovod is a distributed training framework for TensorFlow.
ICU 64.2	broadwell, skylake, gpu	iris	Libraries	ICU is a mature, widely used set of C/C++ and Java libraries providing Unicode and Globalization support for software applications.
ImageMagick 7.0.9-5	broadwell, skylake, gpu	iris	Visualisation	ImageMagick is a software suite to create, edit, compose, or convert bitmap images
Inspector 2019_update5	broadwell, skylake	iris	Utilities	Intel Inspector XE is an easy to use memory error checker and thread checker for serial and parallel applications
JasPer 2.0.14	broadwell, skylake, gpu	iris	Visualisation	The JasPer Project is an open-source initiative to provide a free software-based reference implementation of the codec specified in the JPEG-2000 Part-1 standard.
Java 1.8.0_241	broadwell, skylake, gpu	iris	Programming Languages	Java Platform, Standard Edition (Java SE) lets you develop and deploy Java applications on desktops and servers.
Java 11.0.2	broadwell, skylake, gpu	iris	Programming Languages	Java Platform, Standard Edition (Java SE) lets you develop and deploy Java applications on desktops and servers.
Java 13.0.2	broadwell, skylake, gpu	iris	Programming Languages	Java Platform, Standard Edition (Java SE) lets you develop and deploy Java applications on desktops and servers.
Jellyfish 2.3.0	broadwell, skylake	iris	Biology	Jellyfish is a tool for fast, memory-efficient counting of k-mers in DNA.
JsonCpp 1.9.3	broadwell, skylake, gpu	iris	Libraries	JsonCpp is a C++ library that allows manipulating JSON values, including serialization and deserialization to and from strings. It can also preserve existing comment in unserialization/serialization steps, making it a convenient format to store user input files.
Julia 1.4.1	broadwell, skylake	iris	Programming Languages	Julia is a high-level, high-performance dynamic programming language for numerical computing
Keras 2.3.1	gpu	iris	Mathematics	Keras is a deep learning API written in Python, running on top of the machine learning platform TensorFlow.
LAME 3.100	broadwell, skylake, gpu	iris	Data processing	LAME is a high quality MPEG Audio Layer III (MP3) encoder licensed under the LGPL.
LLVM 9.0.0	broadwell, skylake, gpu	iris	Compilers	The LLVM Core libraries provide a modern source- and target-independent optimizer, along with code generation support for many popular CPUs (as well as some less common ones!) These libraries are built around a well specified code representation known as the LLVM intermediate representation ("LLVM IR"). The LLVM Core libraries are well documented, and it is particularly easy to invent your own language (or port an existing compiler) to use LLVM as an optimizer and code generator.
LLVM 9.0.1	broadwell, skylake, gpu	iris	Compilers	The LLVM Core libraries provide a modern source- and target-independent optimizer, along with code generation support for many popular CPUs (as well as some less common ones!) These libraries are built around a well specified code representation known as the LLVM intermediate representation ("LLVM IR"). The LLVM Core libraries are well documented, and it is particularly easy to invent your own language (or port an existing compiler) to use LLVM as an optimizer and code generator.
LMDB 0.9.24	broadwell, skylake, gpu	iris	Libraries	LMDB is a fast, memory-efficient database. With memory-mapped files, it has the read performance of a pure in-memory database while retaining the persistence of standard disk-based databases.
LibTIFF 4.0.10	broadwell, skylake, gpu	iris	Libraries	tiff: Library and tools for reading and writing TIFF data files
LittleCMS 2.9	broadwell, skylake, gpu	iris	Visualisation	Little CMS intends to be an OPEN SOURCE small-footprint color management engine, with special focus on accuracy and performance.
Lua 5.1.5	broadwell, skylake	iris	Programming Languages	Lua is a powerful, fast, lightweight, embeddable scripting language. Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode for a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping.
M4 1.4.18	broadwell, skylake, gpu	iris	Development	GNU M4 is an implementation of the traditional Unix macro processor. It is mostly SVR4 compatible although it has some extensions (for example, handling more than 9 positional parameters to macros). GNU M4 also has built-in functions for including files, running shell commands, doing arithmetic, etc.
MATLAB 2019b	broadwell, skylake	iris	Mathematics	MATLAB is a high-level language and interactive environment that enables you to perform computationally intensive tasks faster than with traditional programming languages such as C, C++, and Fortran.
MATLAB 2020a	broadwell, skylake	iris	Mathematics	MATLAB is a high-level language and interactive environment that enables you to perform computationally intensive tasks faster than with traditional programming languages such as C, C++, and Fortran.
METIS 5.1.0	broadwell, skylake	iris	Mathematics	METIS is a set of serial programs for partitioning graphs, partitioning finite element meshes, and producing fill reducing orderings for sparse matrices. The algorithms implemented in METIS are based on the multilevel recursive-bisection, multilevel k-way, and multi-constraint partitioning schemes.
MPFR 4.0.2	broadwell, skylake, gpu	iris	Mathematics	The MPFR library is a C library for multiple-precision floating-point computations with correct rounding.
Mako 1.1.0	broadwell, skylake, gpu	iris	Development	A super-fast templating language that borrows the best ideas from the existing templating languages
Mathematica 12.0.0	broadwell, skylake	iris	Mathematics	Mathematica is a computational software program used in many scientific, engineering, mathematical and computing fields.
Maven 3.6.3	broadwell, skylake	iris	Development	Binary maven install, Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information.
Meep 1.4.3	broadwell, skylake	iris	Physics	Meep (or MEEP) is a free finite-difference time-domain (FDTD) simulation software package developed at MIT to model electromagnetic systems.
Mesa 19.1.7	broadwell, skylake, gpu	iris	Visualisation	Mesa is an open-source implementation of the OpenGL specification - a system for rendering interactive 3D graphics.
Mesa 19.2.1	broadwell, skylake, gpu	iris	Visualisation	Mesa is an open-source implementation of the OpenGL specification - a system for rendering interactive 3D graphics.
Meson 0.51.2	broadwell, skylake, gpu	iris	Utilities	Meson is a cross-platform build system designed to be both as fast and as user friendly as possible.
Mesquite 2.3.0	broadwell, skylake	iris	Mathematics	Mesh-Quality Improvement Library
NAMD 2.13	broadwell, skylake	iris	Chemistry	NAMD is a parallel molecular dynamics code designed for high-performance simulation of large biomolecular systems.
NASM 2.14.02	broadwell, skylake, gpu	iris	Programming Languages	NASM: General-purpose x86 assembler
NCCL 2.4.8	gpu	iris	Libraries	The NVIDIA Collective Communications Library (NCCL) implements multi-GPU and multi-node collective communication primitives that are performance optimized for NVIDIA GPUs.
NLopt 2.6.1	broadwell, skylake, gpu	iris	Numerical libraries	NLopt is a free/open-source library for nonlinear optimization, providing a common interface for a number of different free optimization routines available online as well as original implementations of various other algorithms.
NSPR 4.21	broadwell, skylake	iris	Libraries	Netscape Portable Runtime (NSPR) provides a platform-neutral API for system level and libc-like functions.
NSS 3.45	broadwell, skylake	iris	Libraries	Network Security Services (NSS) is a set of libraries designed to support cross-platform development of security-enabled client and server applications.
Ninja 1.9.0	broadwell, skylake, gpu	iris	Utilities	Ninja is a small build system with a focus on speed.
OPARI2 2.0.5	broadwell, skylake	iris	Performance measurements	OPARI2, the successor of Forschungszentrum Juelich's OPARI, is a source-to-source instrumentation tool for OpenMP and hybrid codes. It surrounds OpenMP directives and runtime library calls with calls to the POMP2 measurement interface.
OTF2 2.2	broadwell, skylake	iris	Performance measurements	The Open Trace Format 2 is a highly scalable, memory efficient event trace data format plus support library. It is the new standard trace format for Scalasca, Vampir, and TAU and is open for other tools.
OpenBLAS 0.3.7	broadwell, skylake, gpu	iris	Numerical libraries	OpenBLAS is an optimized BLAS library based on GotoBLAS2 1.13 BSD version.
OpenCV 4.2.0	broadwell, skylake	iris	Visualisation	OpenCV (Open Source Computer Vision Library) is an open source computer vision and machine learning software library. OpenCV was built to provide a common infrastructure for computer vision applications and to accelerate the use of machine perception in the commercial products. Includes extra modules for OpenCV from the contrib repository.
OpenFOAM-Extend 4.1-20200408	broadwell, skylake	iris	CFD/Finite element modelling	OpenFOAM is a free, open source CFD software package. OpenFOAM has an extensive range of features to solve anything from complex fluid flows involving chemical reactions, turbulence and heat transfer, to solid dynamics and electromagnetics.
OpenFOAM v1912	broadwell, skylake	iris	CFD/Finite element modelling	OpenFOAM is a free, open source CFD software package. OpenFOAM has an extensive range of features to solve anything from complex fluid flows involving chemical reactions, turbulence and heat transfer, to solid dynamics and electromagnetics.
OpenMPI 3.1.4	broadwell, skylake, gpu	iris	MPI	The Open MPI Project is an open source MPI-3 implementation.
PAPI 6.0.0	broadwell, skylake	iris	Performance measurements	PAPI provides the tool designer and application engineer with a consistent interface and methodology for use of the performance counter hardware found in most major microprocessors. PAPI enables software engineers to see, in near real time, the relation between software performance and processor events. In addition Component PAPI provides access to a collection of components that expose performance measurement opportunites across the hardware and software stack.
PCRE2 10.33	broadwell, skylake	iris	Development	The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.
PCRE 8.43	broadwell, skylake, gpu	iris	Development	The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.
PDT 3.25	broadwell, skylake	iris	Performance measurements	Program Database Toolkit (PDT) is a framework for analyzing source code written in several programming languages and for making rich program knowledge accessible to developers of static and dynamic analysis tools. PDT implements a standard program representation, the program database (PDB), that can be accessed in a uniform way through a class library supporting common PDB operations.
PGI 19.10	broadwell, skylake	iris	Compilers	C, C++ and Fortran compilers from The Portland Group - PGI
PLUMED 2.5.3	broadwell, skylake	iris	Chemistry	PLUMED is an open source library for free energy calculations in molecular systems which works together with some of the most popular molecular dynamics engines. Free energy calculations can be performed as a function of many order parameters with a particular focus on biological problems, using state of the art methods such as metadynamics, umbrella sampling and Jarzynski-equation based steered MD. The software, written in C++, can be easily interfaced with both fortran and C/C++ codes.
PROJ 6.2.1	broadwell, skylake, gpu	iris	Libraries	Program proj is a standard Unix filter function which converts geographic longitude and latitude coordinates into cartesian coordinates
Pango 1.44.7	broadwell, skylake	iris	Visualisation	Pango is a library for laying out and rendering of text, with an emphasis on internationalization. Pango can be used anywhere that text layout is needed, though most of the work on Pango so far has been done in the context of the GTK+ widget toolkit. Pango forms the core of text and font handling for GTK+-2.x.
ParMETIS 4.0.3	broadwell, skylake	iris	Mathematics	ParMETIS is an MPI-based parallel library that implements a variety of algorithms for partitioning unstructured graphs, meshes, and for computing fill-reducing orderings of sparse matrices. ParMETIS extends the functionality provided by METIS and includes routines that are especially suited for parallel AMR computations and large scale numerical simulations. The algorithms implemented in ParMETIS are based on the parallel multilevel k-way graph-partitioning, adaptive repartitioning, and parallel multi-constrained partitioning schemes.
ParMGridGen 1.0	broadwell, skylake	iris	Mathematics	ParMGridGen is an MPI-based parallel library that is based on the serial package MGridGen, that implements (serial) algorithms for obtaining a sequence of successive coarse grids that are well-suited for geometric multigrid methods.
ParaView 5.6.2	broadwell, skylake	iris	Visualisation	ParaView is a scientific parallel visualizer.
Perl 5.30.0	broadwell, skylake, gpu	iris	Programming Languages	Larry Wall's Practical Extraction and Report Language This is a minimal build without any modules. Should only be used for build dependencies.
Pillow 6.2.1	broadwell, skylake, gpu	iris	Visualisation	Pillow is the 'friendly PIL fork' by Alex Clark and Contributors. PIL is the Python Imaging Library by Fredrik Lundh and Contributors.
PyTorch 1.4.0	broadwell, skylake	iris	Development	Tensors and Dynamic neural networks in Python with strong GPU acceleration. PyTorch is a deep learning framework that puts Python first.
PyTorch 1.7.1	broadwell, skylake	iris	Development	Tensors and Dynamic neural networks in Python with strong GPU acceleration. PyTorch is a deep learning framework that puts Python first.
PyYAML 5.1.2	broadwell, skylake, gpu	iris	Libraries	PyYAML is a YAML parser and emitter for the Python programming language.
Python 2.7.16	broadwell, skylake, gpu	iris	Programming Languages	Python is a programming language that lets you work more quickly and integrate your systems more effectively.
Python 3.7.4	broadwell, skylake, gpu	iris	Programming Languages	Python is a programming language that lets you work more quickly and integrate your systems more effectively.
Qt5 5.13.1	broadwell, skylake	iris	Development	Qt is a comprehensive cross-platform C++ application framework.
QuantumESPRESSO 6.7	broadwell	iris	Chemistry	Quantum ESPRESSO is an integrated suite of computer codes for electronic-structure calculations and materials modeling at the nanoscale. It is based on density-functional theory, plane waves, and pseudopotentials (both norm-conserving and ultrasoft).
R 3.6.2	broadwell, skylake, gpu	iris	Programming Languages	R is a free software environment for statistical computing and graphics.
ReFrame 2.21	broadwell, skylake	iris	Development	ReFrame is a framework for writing regression tests for HPC systems.
Ruby 2.7.1	broadwell, skylake	iris	Programming Languages	Ruby is a dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write.
Rust 1.37.0	broadwell, skylake	iris	Programming Languages	Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.
SAMtools 1.10	broadwell, skylake	iris	Biology	SAM Tools provide various utilities for manipulating alignments in the SAM format, including sorting, merging, indexing and generating alignments in a per-position format.
SCOTCH 6.0.9	broadwell, skylake	iris	Mathematics	Software package and libraries for sequential and parallel graph partitioning, static mapping, and sparse matrix block ordering, and sequential mesh and hypergraph partitioning.
SIONlib 1.7.6	broadwell, skylake	iris	Libraries	SIONlib is a scalable I/O library for parallel access to task-local files. The library not only supports writing and reading binary data to or from several thousands of processors into a single or a small number of physical files, but also provides global open and close functions to access SIONlib files in parallel. This package provides a stripped-down installation of SIONlib for use with performance tools (e.g., Score-P), with renamed symbols to avoid conflicts when an application using SIONlib itself is linked against a tool requiring a different SIONlib version.
SQLite 3.29.0	broadwell, skylake, gpu	iris	Development	SQLite: SQL Database Engine in a C Library
SWIG 4.0.1	broadwell, skylake, gpu	iris	Development	SWIG is a software development tool that connects programs written in C and C++ with a variety of high-level programming languages.
Salmon 1.1.0	broadwell, skylake	iris	Biology	Salmon is a wicked-fast program to produce a highly-accurate, transcript-level quantification estimates from RNA-seq data.
Salome 8.5.0	broadwell, skylake	iris	CFD/Finite element modelling	The SALOME platform is an open source software framework for pre- and post-processing and integration of numerical solvers from various scientific fields. CEA and EDF use SALOME to perform a large number of simulations, typically related to power plant equipment and alternative energy. To address these challenges, SALOME includes a CAD/CAE modelling tool, mesh generators, an advanced 3D visualization tool, etc.
ScaLAPACK 2.0.2	broadwell, skylake, gpu	iris	Numerical libraries	The ScaLAPACK (or Scalable LAPACK) library includes a subset of LAPACK routines redesigned for distributed memory MIMD parallel computers.
Scalasca 2.5	broadwell, skylake	iris	Performance measurements	Scalasca is a software tool that supports the performance optimization of parallel programs by measuring and analyzing their runtime behavior. The analysis identifies potential performance bottlenecks -- in particular those concerning communication and synchronization -- and offers guidance in exploring their causes.
SciPy-bundle 2019.10	broadwell, skylake, gpu	iris	Programming Languages	Bundle of Python packages for scientific software
Score-P 6.0	broadwell, skylake	iris	Performance measurements	The Score-P measurement infrastructure is a highly scalable and easy-to-use tool suite for profiling, event tracing, and online analysis of HPC applications.
Singularity 3.6.0	broadwell, skylake	iris	Utilities	SingularityCE is an open source container platform designed to be simple, fast, and secure. Singularity is optimized for EPC and HPC workloads, allowing untrusted users to run untrusted containers in a trusted way.
Spack 0.12.1	broadwell, skylake	iris	Development	Spack is a package manager for supercomputers, Linux, and macOS. It makes installing scientific software easy. With Spack, you can build a package with multiple versions, configurations, platforms, and compilers, and all of these builds can coexist on the same machine.
Spark 2.4.3	broadwell, skylake	iris	Development	Spark is Hadoop MapReduce done in memory
Sumo 1.3.1	broadwell, skylake	iris	Utilities	Sumo is an open source, highly portable, microscopic and continuous traffic simulation package designed to handle large road networks.
Szip 2.1.1	broadwell, skylake, gpu	iris	Utilities	Szip compression software, providing lossless compression of scientific data
Tcl 8.6.9	broadwell, skylake, gpu	iris	Programming Languages	Tcl (Tool Command Language) is a very powerful but easy to learn dynamic programming language, suitable for a very wide range of uses, including web and desktop applications, networking, administration, testing and many more.
TensorFlow 1.15.5	gpu	iris	Libraries	An open-source software library for Machine Intelligence
TensorFlow 2.1.0	gpu	iris	Libraries	An open-source software library for Machine Intelligence
Theano 1.0.4	gpu	iris	Mathematics	Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently.
Tk 8.6.9	broadwell, skylake, gpu	iris	Visualisation	Tk is an open source, cross-platform widget toolchain that provides a library of basic elements for building a graphical user interface (GUI) in many different programming languages.
Tkinter 3.7.4	broadwell, skylake	iris	Programming Languages	Tkinter module, built with the Python buildsystem
TopHat 2.1.2	broadwell, skylake	iris	Biology	TopHat is a fast splice junction mapper for RNA-Seq reads.
Trinity 2.10.0	broadwell, skylake	iris	Biology	Trinity represents a novel method for the efficient and robust de novo reconstruction of transcriptomes from RNA-Seq data. Trinity combines three independent software modules: Inchworm, Chrysalis, and Butterfly, applied sequentially to process large volumes of RNA-Seq reads.
UDUNITS 2.2.26	broadwell, skylake, gpu	iris	Physics	UDUNITS supports conversion of unit specifications between formatted and binary forms, arithmetic manipulation of units, and conversion of values between compatible scales of measurement.
ULHPC-bio 2019b	broadwell, skylake	iris	System-level software	Generic Module bundle for Bioinformatics, biology and biomedical software in use on the UL HPC Facility, especially at LCSB
ULHPC-cs 2019b	broadwell, skylake	iris	System-level software	Generic Module bundle for Computational science software in use on the UL HPC Facility, including: - Computer Aided Engineering, incl. CFD - Chemistry, Computational Chemistry and Quantum Chemistry - Data management & processing tools - Earth Sciences - Quantum Computing - Physics and physical systems simulations
ULHPC-dl 2019b	broadwell, skylake	iris	System-level software	Generic Module bundle for (CPU-version) of AI / Deep Learning / Machine Learning software in use on the UL HPC Facility
ULHPC-gpu 2019b	gpu	iris	System-level software	Generic Module bundle for GPU accelerated User Software in use on the UL HPC Facility
ULHPC-math 2019b	broadwell, skylake	iris	System-level software	Generic Module bundle for High-level mathematical software and Linear Algrebra libraries in use on the UL HPC Facility
ULHPC-toolchains 2019b	broadwell, skylake	iris	System-level software	Generic Module bundle that contains all the dependencies required to enable toolchains and building tools/programming language in use on the UL HPC Facility
ULHPC-tools 2019b	broadwell, skylake	iris	System-level software	Misc tools, incl. - perf: Performance tools - tools: General purpose tools
VASP 5.4.4	broadwell, skylake	iris	Physics	The Vienna Ab initio Simulation Package (VASP) is a computer program for atomic scale materials modelling, e.g. electronic structure calculations and quantum-mechanical molecular dynamics, from first principles.
VTK 8.2.0	broadwell, skylake	iris	Visualisation	The Visualization Toolkit (VTK) is an open-source, freely available software system for 3D computer graphics, image processing and visualization. VTK consists of a C++ class library and several interpreted interface layers including Tcl/Tk, Java, and Python. VTK supports a wide variety of visualization algorithms including: scalar, vector, tensor, texture, and volumetric methods; and advanced modeling techniques such as: implicit modeling, polygon reduction, mesh smoothing, cutting, contouring, and Delaunay triangulation.
VTune 2019_update8	broadwell, skylake	iris	Utilities	Intel VTune Amplifier XE is the premier performance profiler for C, C++, C#, Fortran, Assembly and Java.
Valgrind 3.15.0	broadwell, skylake	iris	Debugging	Valgrind: Debugging and profiling tools
VirtualGL 2.6.2	broadwell, skylake	iris	Visualisation	VirtualGL is an open source toolkit that gives any Linux or Unix remote display software the ability to run OpenGL applications with full hardware acceleration.
Voro++ 0.4.6	broadwell, skylake	iris	Mathematics	Voro++ is a software library for carrying out three-dimensional computations of the Voronoi tessellation. A distinguishing feature of the Voro++ library is that it carries out cell-based calculations, computing the Voronoi cell for each particle individually. It is particularly well-suited for applications that rely on cell-based statistics, where features of Voronoi cells (eg. volume, centroid, number of faces) can be used to analyze a system of particles.
X11 20190717	broadwell, skylake, gpu	iris	Visualisation	The X Window System (X11) is a windowing system for bitmap displays
XML-LibXML 2.0201	broadwell, skylake	iris	Data processing	Perl binding for libxml2
XZ 5.2.4	broadwell, skylake, gpu	iris	Utilities	xz: XZ utilities
Xerces-C++ 3.2.2	broadwell, skylake	iris	Libraries	Xerces-C++ is a validating XML parser written in a portable subset of C++. Xerces-C++ makes it easy to give your application the ability to read and write XML data. A shared library is provided for parsing, generating, manipulating, and validating XML documents using the DOM, SAX, and SAX2 APIs.
Yasm 1.3.0	broadwell, skylake, gpu	iris	Programming Languages	Yasm: Complete rewrite of the NASM assembler with BSD license
Zip 3.0	broadwell, skylake, gpu	iris	Utilities	Zip is a compression and file packaging/archive utility. Although highly compatible both with PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP's own UnZip, our primary objectives have been portability and other-than-MSDOS functionality
ant 1.10.6	broadwell, skylake	iris	Development	Apache Ant is a Java library and command-line tool whose mission is to drive processes described in build files as targets and extension points dependent upon each other. The main known usage of Ant is the build of Java applications.
ant 1.10.7	broadwell, skylake	iris	Development	Apache Ant is a Java library and command-line tool whose mission is to drive processes described in build files as targets and extension points dependent upon each other. The main known usage of Ant is the build of Java applications.
archspec 0.1.0	broadwell, skylake	iris	Utilities	A library for detecting, labeling, and reasoning about microarchitectures
arpack-ng 3.7.0	broadwell, skylake	iris	Numerical libraries	ARPACK is a collection of Fortran77 subroutines designed to solve large scale eigenvalue problems.
at-spi2-atk 2.34.1	broadwell, skylake	iris	Visualisation	AT-SPI 2 toolkit bridge
at-spi2-core 2.34.0	broadwell, skylake	iris	Visualisation	Assistive Technology Service Provider Interface.
binutils 2.32	broadwell, skylake, gpu	iris	Utilities	binutils: GNU binary utilities
bzip2 1.0.8	broadwell, skylake, gpu	iris	Utilities	bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.
cURL 7.66.0	broadwell, skylake, gpu	iris	Utilities	libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more.
cairo 1.16.0	broadwell, skylake, gpu	iris	Visualisation	Cairo is a 2D graphics library with support for multiple output devices. Currently supported output targets include the X Window System (via both Xlib and XCB), Quartz, Win32, image buffers, PostScript, PDF, and SVG file output. Experimental backends include OpenGL, BeOS, OS/2, and DirectFB
cuDNN 7.6.4.38	gpu	iris	Numerical libraries	The NVIDIA CUDA Deep Neural Network library (cuDNN) is a GPU-accelerated library of primitives for deep neural networks.
double-conversion 3.1.4	broadwell, skylake, gpu	iris	Libraries	Efficient binary-decimal and decimal-binary conversion routines for IEEE doubles.
expat 2.2.7	broadwell, skylake, gpu	iris	Utilities	Expat is an XML parser library written in C. It is a stream-oriented parser in which an application registers handlers for things the parser might find in the XML document (like start tags)
flatbuffers 1.12.0	broadwell, skylake, gpu	iris	Development	FlatBuffers: Memory Efficient Serialization Library
flex 2.6.4	broadwell, skylake, gpu	iris	Programming Languages	Flex (Fast Lexical Analyzer) is a tool for generating scanners. A scanner, sometimes called a tokenizer, is a program which recognizes lexical patterns in text.
fontconfig 2.13.1	broadwell, skylake, gpu	iris	Visualisation	Fontconfig is a library designed to provide system-wide font configuration, customization and application access.
foss 2019b	broadwell, skylake	iris	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain, including OpenMPI for MPI support, OpenBLAS (BLAS and LAPACK support), FFTW and ScaLAPACK.
fosscuda 2019b	gpu	iris	Toolchains (software stacks)	GCC based compiler toolchain with CUDA support, and including OpenMPI for MPI support, OpenBLAS (BLAS and LAPACK support), FFTW and ScaLAPACK.
freetype 2.10.1	broadwell, skylake, gpu	iris	Visualisation	FreeType 2 is a software font engine that is designed to be small, efficient, highly customizable, and portable while capable of producing high-quality output (glyph images). It can be used in graphics libraries, display servers, font conversion tools, text image generation tools, and many other products as well.
gc 7.6.12	broadwell, skylake	iris	Libraries	The Boehm-Demers-Weiser conservative garbage collector can be used as a garbage collecting replacement for C malloc or C++ new.
gcccuda 2019b	gpu	iris	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain, along with CUDA toolkit.
gettext 0.19.8.1	broadwell, skylake, gpu	iris	Utilities	GNU 'gettext' is an important step for the GNU Translation Project, as it is an asset on which we may build many other steps. This package offers to programmers, translators, and even users, a well integrated set of tools and documentation
gettext 0.20.1	broadwell, skylake, gpu	iris	Utilities	GNU 'gettext' is an important step for the GNU Translation Project, as it is an asset on which we may build many other steps. This package offers to programmers, translators, and even users, a well integrated set of tools and documentation
gflags 2.2.2	broadwell, skylake	iris	Development	The gflags package contains a C++ library that implements commandline flags processing. It includes built-in support for standard types such as string and the ability to define flags in the source file in which they are used.
giflib 5.2.1	broadwell, skylake, gpu	iris	Libraries	giflib is a library for reading and writing gif images. It is API and ABI compatible with libungif which was in wide use while the LZW compression algorithm was patented.
git 2.23.0	broadwell, skylake, gpu	iris	Utilities	Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.
glog 0.4.0	broadwell, skylake	iris	Development	A C++ implementation of the Google logging module.
gmsh 4.4.0	broadwell, skylake	iris	CFD/Finite element modelling	Salome is an open-source software that provides a generic Pre- and Post-Processing platform for numerical simulation. It is based on an open and flexible architecture made of reusable components.
gnuplot 5.2.8	broadwell, skylake	iris	Visualisation	Portable interactive, function plotting utility
gocryptfs 1.7.1	broadwell, skylake	iris	Utilities	Encrypted overlay filesystem written in Go. gocryptfs uses file-based encryption that is implemented as a mountable FUSE filesystem. Each file in gocryptfs is stored as one corresponding encrypted file on the hard disk.
gompi 2019b	broadwell, skylake	iris	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain, including OpenMPI for MPI support.
gompic 2019b	gpu	iris	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain along with CUDA toolkit, including OpenMPI for MPI support with CUDA features enabled.
googletest 1.10.0	broadwell, skylake	iris	Development	Google's framework for writing C++ tests on a variety of platforms
gperf 3.1	broadwell, skylake, gpu	iris	Development	GNU gperf is a perfect hash function generator. For a given list of strings, it produces a hash function and hash table, in form of C or C++ code, for looking up a value depending on the input string. The hash function is perfect, which means that the hash table has no collisions, and the hash table lookup needs a single string comparison only.
gzip 1.10	broadwell, skylake	iris	Utilities	gzip (GNU zip) is a popular data compression program as a replacement for compress
h5py 2.10.0	broadwell, skylake, gpu	iris	Data processing	HDF5 for Python (h5py) is a general-purpose Python interface to the Hierarchical Data Format library, version 5. HDF5 is a versatile, mature scientific software library designed for the fast, flexible storage of enormous amounts of data.
help2man 1.47.4	broadwell, skylake, gpu	iris	Utilities	help2man produces simple manual pages from the '--help' and '--version' output of other commands.
help2man 1.47.8	broadwell, skylake, gpu	iris	Utilities	help2man produces simple manual pages from the '--help' and '--version' output of other commands.
hwloc 1.11.12	broadwell, skylake, gpu	iris	System-level software	The Portable Hardware Locality (hwloc) software package provides a portable abstraction (across OS, versions, architectures, ...) of the hierarchical topology of modern architectures, including NUMA memory nodes, sockets, shared caches, cores and simultaneous multithreading. It also gathers various system attributes such as cache and memory information as well as the locality of I/O devices such as network interfaces, InfiniBand HCAs or GPUs. It primarily aims at helping applications with gathering information about modern computing hardware so as to exploit it accordingly and efficiently.
hypothesis 4.44.2	broadwell, skylake, gpu	iris	Utilities	Hypothesis is an advanced testing library for Python. It lets you write tests which are parametrized by a source of examples, and then generates simple and comprehensible examples that make your tests fail. This lets you find more bugs in your code with less work.
iccifort 2019.5.281	broadwell, skylake, gpu	iris	Compilers	Intel C, C++ & Fortran compilers
iccifortcuda 2019b	gpu	iris	Toolchains (software stacks)	Intel C, C++ & Fortran compilers with CUDA toolkit
iimpi 2019b	broadwell, skylake	iris	Toolchains (software stacks)	Intel C/C++ and Fortran compilers, alongside Intel MPI.
iimpic 2019b	gpu	iris	Toolchains (software stacks)	Intel C/C++ and Fortran compilers, alongside Intel MPI and CUDA.
imkl 2019.5.281	broadwell, skylake, gpu	iris	Numerical libraries	Intel Math Kernel Library is a library of highly optimized, extensively threaded math routines for science, engineering, and financial applications that require maximum performance. Core math functions include BLAS, LAPACK, ScaLAPACK, Sparse Solvers, Fast Fourier Transforms, Vector Math, and more.
impi 2018.5.288	broadwell, skylake, gpu	iris	MPI	Intel MPI Library, compatible with MPICH ABI
intel 2019b	broadwell, skylake	iris	Toolchains (software stacks)	Compiler toolchain including Intel compilers, Intel MPI and Intel Math Kernel Library (MKL).
intelcuda 2019b	gpu	iris	Toolchains (software stacks)	Intel Cluster Toolkit Compiler Edition provides Intel C/C++ and Fortran compilers, Intel MPI & Intel MKL, with CUDA toolkit
intltool 0.51.0	broadwell, skylake, gpu	iris	Development	intltool is a set of tools to centralize translation of many different file formats using GNU gettext-compatible PO files.
itac 2019.4.036	broadwell, skylake	iris	Utilities	The Intel Trace Collector is a low-overhead tracing library that performs event-based tracing in applications. The Intel Trace Analyzer provides a convenient way to monitor application activities gathered by the Intel Trace Collector through graphical displays.
jemalloc 5.2.1	broadwell, skylake	iris	Libraries	jemalloc is a general purpose malloc(3) implementation that emphasizes fragmentation avoidance and scalable concurrency support.
kallisto 0.46.1	broadwell, skylake	iris	Biology	kallisto is a program for quantifying abundances of transcripts from RNA-Seq data, or more generally of target sequences using high-throughput sequencing reads.
kim-api 2.1.3	broadwell, skylake	iris	Chemistry	Open Knowledgebase of Interatomic Models. KIM is an API and OpenKIM is a collection of interatomic models (potentials) for atomistic simulations. This is a library that can be used by simulation programs to get access to the models in the OpenKIM database. This EasyBuild only installs the API, the models can be installed with the package openkim-models, or the user can install them manually by running kim-api-collections-management install user MODELNAME or kim-api-collections-management install user OpenKIM to install them all.
libGLU 9.0.1	broadwell, skylake, gpu	iris	Visualisation	The OpenGL Utility Library (GLU) is a computer graphics library for OpenGL.
libcerf 1.13	broadwell, skylake	iris	Mathematics	libcerf is a self-contained numeric library that provides an efficient and accurate implementation of complex error functions, along with Dawson, Faddeeva, and Voigt functions.
libctl 4.0.0	broadwell, skylake	iris	Chemistry	libctl is a free Guile-based library implementing flexible control files for scientific simulations.
libdrm 2.4.99	broadwell, skylake, gpu	iris	Libraries	Direct Rendering Manager runtime library.
libepoxy 1.5.4	broadwell, skylake	iris	Libraries	Epoxy is a library for handling OpenGL function pointer management for you
libevent 2.1.11	broadwell, skylake	iris	Libraries	The libevent API provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached. Furthermore, libevent also support callbacks due to signals or regular timeouts.
libffi 3.2.1	broadwell, skylake, gpu	iris	Libraries	The libffi library provides a portable, high level programming interface to various calling conventions. This allows a programmer to call any function specified by a call interface description at run-time.
libgd 2.2.5	broadwell, skylake	iris	Libraries	GD is an open source code library for the dynamic creation of images by programmers.
libgeotiff 1.5.1	broadwell, skylake, gpu	iris	Libraries	Library for reading and writing coordinate system information from/to GeoTIFF files
libglvnd 1.2.0	broadwell, skylake	iris	Libraries	libglvnd is a vendor-neutral dispatch layer for arbitrating OpenGL API calls between multiple vendors.
libgpuarray 0.7.6	gpu	iris	Libraries	Library to manipulate tensors on the GPU.
libiconv 1.16	broadwell, skylake, gpu	iris	Libraries	Libiconv converts from one character encoding to another through Unicode conversion
libjpeg-turbo 2.0.3	broadwell, skylake, gpu	iris	Libraries	libjpeg-turbo is a fork of the original IJG libjpeg which uses SIMD to accelerate baseline JPEG compression and decompression. libjpeg is a library that implements JPEG image encoding, decoding and transcoding.
libmatheval 1.1.11	broadwell, skylake	iris	Libraries	GNU libmatheval is a library (callable from C and Fortran) to parse and evaluate symbolic expressions input as text.
libpciaccess 0.14	broadwell, skylake, gpu	iris	System-level software	Generic PCI access library.
libpng 1.6.37	broadwell, skylake, gpu	iris	Libraries	libpng is the official PNG reference library
libreadline 8.0	broadwell, skylake, gpu	iris	Libraries	The GNU Readline library provides a set of functions for use by applications that allow users to edit command lines as they are typed in. Both Emacs and vi editing modes are available. The Readline library includes additional functions to maintain a list of previously-entered command lines, to recall and perhaps reedit those lines, and perform csh-like history expansion on previous commands.
libsndfile 1.0.28	broadwell, skylake, gpu	iris	Libraries	Libsndfile is a C library for reading and writing files containing sampled sound (such as MS Windows WAV and the Apple/SGI AIFF format) through one standard library interface.
libtool 2.4.6	broadwell, skylake, gpu	iris	Libraries	GNU libtool is a generic library support script. Libtool hides the complexity of using shared libraries behind a consistent, portable interface.
libunistring 0.9.10	broadwell, skylake	iris	Libraries	This library provides functions for manipulating Unicode strings and for manipulating C strings according to the Unicode standard.
libunwind 1.3.1	broadwell, skylake, gpu	iris	Libraries	The primary goal of libunwind is to define a portable and efficient C programming interface (API) to determine the call-chain of a program. The API additionally provides the means to manipulate the preserved (callee-saved) state of each call-frame and to resume execution at any point in the call-chain (non-local goto). The API supports both local (same-process) and remote (across-process) operation. As such, the API is useful in a number of applications
libxc 4.3.4	broadwell, skylake	iris	Chemistry	Libxc is a library of exchange-correlation functionals for density-functional theory. The aim is to provide a portable, well tested and reliable set of exchange and correlation functionals.
libxml2 2.9.9	broadwell, skylake, gpu	iris	Libraries	Libxml2 is the XML C parser and toolchain developed for the Gnome project (but usable outside of the Gnome platform).
libxslt 1.1.34	broadwell, skylake	iris	Libraries	Libxslt is the XSLT C library developed for the GNOME project (but usable outside of the Gnome platform).
libyaml 0.2.2	broadwell, skylake, gpu	iris	Libraries	LibYAML is a YAML parser and emitter written in C.
lxml 4.4.2	broadwell, skylake	iris	Libraries	The lxml XML toolkit is a Pythonic binding for the C libraries libxml2 and libxslt.
magma 2.5.1	gpu	iris	Mathematics	The MAGMA project aims to develop a dense linear algebra library similar to LAPACK but for heterogeneous/hybrid architectures, starting with current Multicore+GPU systems.
magma 2.5.4	gpu	iris	Mathematics	The MAGMA project aims to develop a dense linear algebra library similar to LAPACK but for heterogeneous/hybrid architectures, starting with current Multicore+GPU systems.
matplotlib 3.1.1	broadwell, skylake	iris	Visualisation	matplotlib is a python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. matplotlib can be used in python scripts, the python and ipython shell, web application servers, and six graphical user interface toolkits.
molmod 1.4.5	broadwell, skylake	iris	Mathematics	MolMod is a Python library with many compoments that are useful to write molecular modeling programs.
ncurses 6.0	broadwell, skylake, gpu	iris	Development	The Ncurses (new curses) library is a free software emulation of curses in System V Release 4.0, and more. It uses Terminfo format, supports pads and color and multiple highlights and forms characters and function-key mapping, and has all the other SYSV-curses enhancements over BSD Curses.
ncurses 6.1	broadwell, skylake, gpu	iris	Development	The Ncurses (new curses) library is a free software emulation of curses in System V Release 4.0, and more. It uses Terminfo format, supports pads and color and multiple highlights and forms characters and function-key mapping, and has all the other SYSV-curses enhancements over BSD Curses.
netCDF-Fortran 4.5.2	broadwell, skylake	iris	Data processing	NetCDF (network Common Data Form) is a set of software libraries and machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.
netCDF 4.7.1	broadwell, skylake, gpu	iris	Data processing	NetCDF (network Common Data Form) is a set of software libraries and machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.
nettle 3.5.1	broadwell, skylake, gpu	iris	Libraries	Nettle is a cryptographic library that is designed to fit easily in more or less any context: In crypto toolkits for object-oriented languages (C++, Python, Pike, ...), in applications like LSH or GNUPG, or even in kernel space.
nsync 1.24.0	broadwell, skylake, gpu	iris	Development	nsync is a C library that exports various synchronization primitives, such as mutexes
numactl 2.0.12	broadwell, skylake, gpu	iris	Utilities	The numactl program allows you to run your application program on specific cpu's and memory nodes. It does this by supplying a NUMA memory policy to the operating system before running your program. The libnuma library provides convenient ways for you to add NUMA memory policies into your own program.
phonopy 2.2.0	broadwell, skylake	iris	Libraries	Phonopy is an open source package of phonon calculations based on the supercell approach.
pixman 0.38.4	broadwell, skylake, gpu	iris	Visualisation	Pixman is a low-level software library for pixel manipulation, providing features such as image compositing and trapezoid rasterization. Important users of pixman are the cairo graphics library and the X server.
pkg-config 0.29.2	broadwell, skylake, gpu	iris	Development	pkg-config is a helper tool used when compiling applications and libraries. It helps you insert the correct compiler options on the command line so an application can use gcc -o test test.c pkg-config --libs --cflags glib-2.0 for instance, rather than hard-coding values on where to find glib (or other libraries).
pkgconfig 1.5.1	broadwell, skylake, gpu	iris	Development	pkgconfig is a Python module to interface with the pkg-config command line tool
pocl 1.4	gpu	iris	Libraries	Pocl is a portable open source (MIT-licensed) implementation of the OpenCL standard
protobuf-python 3.10.0	broadwell, skylake, gpu	iris	Development	Python Protocol Buffers runtime library.
protobuf 2.5.0	broadwell, skylake	iris	Development	Google Protocol Buffers
protobuf 3.10.0	broadwell, skylake	iris	Development	Google Protocol Buffers
pybind11 2.4.3	broadwell, skylake, gpu	iris	Libraries	pybind11 is a lightweight header-only library that exposes C++ types in Python and vice versa, mainly to create Python bindings of existing C++ code.
re2c 1.2.1	broadwell, skylake	iris	Utilities	re2c is a free and open-source lexer generator for C and C++. Its main goal is generating fast lexers: at least as fast as their reasonably optimized hand-coded counterparts. Instead of using traditional table-driven approach, re2c encodes the generated finite state automata directly in the form of conditional jumps and comparisons.
scipy 1.4.1	broadwell, skylake, gpu	iris	Mathematics	SciPy is a collection of mathematical algorithms and convenience functions built on the Numpy extension for Python.
setuptools 41.0.1	broadwell, skylake	iris	Development	Easily download, build, install, upgrade, and uninstall Python packages
snappy 1.1.7	broadwell, skylake, gpu	iris	Libraries	Snappy is a compression/decompression library. It does not aim for maximum compression, or compatibility with any other compression library; instead, it aims for very high speeds and reasonable compression.
sparsehash 2.0.3	broadwell, skylake	iris	Development	An extremely memory-efficient hash_map implementation. 2 bits/entry overhead! The SparseHash library contains several hash-map implementations, including implementations that optimize for space or speed.
tbb 2019_U9	broadwell, skylake	iris	Libraries	Intel(R) Threading Building Blocks (Intel(R) TBB) lets you easily write parallel C++ programs that take full advantage of multicore performance, that are portable, composable and have future-proof scalability.
tbb 2020.2	broadwell, skylake	iris	Libraries	Intel(R) Threading Building Blocks (Intel(R) TBB) lets you easily write parallel C++ programs that take full advantage of multicore performance, that are portable, composable and have future-proof scalability.
texinfo 6.7	broadwell, skylake	iris	Development	Texinfo is the official documentation format of the GNU project.
typing-extensions 3.7.4.3	gpu	iris	Development	Typing Extensions – Backported and Experimental Type Hints for Python
util-linux 2.34	broadwell, skylake, gpu	iris	Utilities	Set of Linux utilities
x264 20190925	broadwell, skylake, gpu	iris	Visualisation	x264 is a free software library and application for encoding video streams into the H.264/MPEG-4 AVC compression format, and is released under the terms of the GNU GPL.
x265 3.2	broadwell, skylake, gpu	iris	Visualisation	x265 is a free software library and application for encoding video streams into the H.265 AVC compression format, and is released under the terms of the GNU GPL.
xorg-macros 1.19.2	broadwell, skylake, gpu	iris	Development	X.org macros utilities.
xprop 1.2.4	broadwell, skylake	iris	Visualisation	The xprop utility is for displaying window and font properties in an X server. One window or font is selected using the command line arguments or possibly in the case of a window, by clicking on the desired window. A list of properties is then given, possibly with formatting information.
yaff 1.6.0	broadwell, skylake	iris	Chemistry	Yaff stands for 'Yet another force field'. It is a pythonic force-field code.
zlib 1.2.11	broadwell, skylake, gpu	iris	Libraries	zlib is designed to be a free, general-purpose, legally unencumbered -- that is, not covered by any patents -- lossless data-compression library for use on virtually any computer hardware and operating system.

2020a

Alphabetical list of available ULHPC software belonging to the '2020b' software set. To load a software of this set, use:


# Eventually: resif-load-swset-[...]
module load <category>/<software>[/<version>]
Software	Architectures	Clusters	Category	Description
ABAQUS 2021	broadwell, epyc, skylake	aion, iris	CFD/Finite element modelling	Finite Element Analysis software for modeling, visualization and best-in-class implicit and explicit dynamics FEA.
ABINIT 9.4.1	epyc	aion	Chemistry	ABINIT is a package whose main program allows one to find the total energy, charge density and electronic structure of systems made of electrons and nuclei (molecules and periodic solids) within Density Functional Theory (DFT), using pseudopotentials and a planewave or wavelet basis.
ABySS 2.2.5	broadwell, epyc, skylake	aion, iris	Biology	Assembly By Short Sequences - a de novo, parallel, paired-end sequence assembler
ACTC 1.1	broadwell, skylake	iris	Libraries	ACTC converts independent triangles into triangle strips or fans.
ANSYS 21.1	broadwell, skylake	iris	Utilities	ANSYS simulation software enables organizations to confidently predict how their products will operate in the real world. We believe that every product is a promise of something greater.
AOCC 3.1.0	epyc	aion	Compilers	AMD Optimized C/C++ & Fortran compilers (AOCC) based on LLVM 12.0
ASE 3.20.1	broadwell, epyc, skylake, gpu	aion, iris	Chemistry	ASE is a python package providing an open source Atomic Simulation Environment in the Python scripting language. From version 3.20.1 we also include the ase-ext package, it contains optional reimplementations in C of functions in ASE. ASE uses it automatically when installed.
ASE 3.21.1	broadwell, epyc, skylake, gpu	aion, iris	Chemistry	ASE is a python package providing an open source Atomic Simulation Environment in the Python scripting language. From version 3.20.1 we also include the ase-ext package, it contains optional reimplementations in C of functions in ASE. ASE uses it automatically when installed.
ATK 2.36.0	broadwell, epyc, skylake	aion, iris	Visualisation	ATK provides the set of accessibility interfaces that are implemented by other toolkits and applications. Using the ATK interfaces, accessibility tools have full access to view and control running applications.
Anaconda3 2020.11	broadwell, epyc, skylake	aion, iris	Programming Languages	Built to complement the rich, open source Python community, the Anaconda platform provides an enterprise-ready data analytics platform that empowers companies to adopt a modern open data science analytics architecture.
ArmForge 20.0.3	broadwell, skylake	iris	Utilities	The industry standard development package for C, C++ and Fortran high performance code on Linux. Forge is designed to handle the complex software projects - including parallel, multiprocess and multithreaded code. Arm Forge combines an industry-leading debugger, Arm DDT, and an out-of-the-box-ready profiler, Arm MAP.
ArmReports 20.0.3	broadwell, skylake	iris	Utilities	Arm Performance Reports - a low-overhead tool that produces one-page text and HTML reports summarizing and characterizing both scalar and MPI application performance. Arm Performance Reports runs transparently on optimized production-ready codes by adding a single command to your scripts, and provides the most effective way to characterize and understand the performance of HPC application runs.
Armadillo 10.5.3	broadwell, epyc, skylake	aion, iris	Numerical libraries	Armadillo is an open-source C++ linear algebra library (matrix maths) aiming towards a good balance between speed and ease of use. Integer, floating point and complex numbers are supported, as well as a subset of trigonometric and statistics functions.
Aspera-CLI 3.9.6	broadwell, epyc, skylake	aion, iris	Utilities	IBM Aspera Command-Line Interface (the Aspera CLI) is a collection of Aspera tools for performing high-speed, secure data transfers from the command line. The Aspera CLI is for users and organizations who want to automate their transfer workflows.
Autoconf 2.69	broadwell, skylake, gpu	iris	Development	Autoconf is an extensible package of M4 macros that produce shell scripts to automatically configure software source code packages. These scripts can adapt the packages to many kinds of UNIX-like systems without manual user intervention. Autoconf creates a configuration script for a package from a template file that lists the operating system features that the package can use, in the form of M4 macro calls.
Automake 1.16.2	broadwell, epyc, skylake, gpu	aion, iris	Development	Automake: GNU Standards-compliant Makefile generator
Autotools 20200321	broadwell, epyc, skylake, gpu	aion, iris	Development	This bundle collect the standard GNU build tools: Autoconf, Automake and libtool
BEDTools 2.30.0	broadwell, epyc, skylake	aion, iris	Biology	BEDTools: a powerful toolset for genome arithmetic. The BEDTools utilities allow one to address common genomics tasks such as finding feature overlaps and computing coverage. The utilities are largely based on four widely-used file formats: BED, GFF/GTF, VCF, and SAM/BAM.
BLAST+ 2.11.0	broadwell, epyc, skylake	aion, iris	Biology	Basic Local Alignment Search Tool, or BLAST, is an algorithm for comparing primary biological sequence information, such as the amino-acid sequences of different proteins or the nucleotides of DNA sequences.
BWA 0.7.17	broadwell, skylake	iris	Biology	Burrows-Wheeler Aligner (BWA) is an efficient program that aligns relatively short nucleotide sequences against a long reference sequence such as the human genome.
BamTools 2.5.1	broadwell, skylake	iris	Biology	BamTools provides both a programmer's API and an end-user's toolkit for handling BAM files.
Bazel 3.7.2	broadwell, epyc, skylake, gpu	aion, iris	Development	Bazel is a build tool that builds code quickly and reliably. It is used to build the majority of Google's software.
BioPerl 1.7.8	broadwell, epyc, skylake	aion, iris	Biology	Bioperl is the product of a community effort to produce Perl code which is useful in biology. Examples include Sequence objects, Alignment objects and database searching objects.
Bison 3.5.3	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Bison is a general-purpose parser generator that converts an annotated context-free grammar into a deterministic LR or generalized LR (GLR) parser employing LALR(1) parser tables.
Bison 3.7.1	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Bison is a general-purpose parser generator that converts an annotated context-free grammar into a deterministic LR or generalized LR (GLR) parser employing LALR(1) parser tables.
Boost.Python 1.74.0	broadwell, epyc, skylake	aion, iris	Libraries	Boost.Python is a C++ library which enables seamless interoperability between C++ and the Python programming language.
Boost 1.74.0	broadwell, epyc, skylake	aion, iris	Development	Boost provides free peer-reviewed portable C++ source libraries.
Bowtie2 2.4.2	broadwell, epyc, skylake	aion, iris	Biology	Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters, and particularly good at aligning to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an FM Index to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 GB. Bowtie 2 supports gapped, local, and paired-end alignment modes.
CGAL 5.2	broadwell, epyc, skylake	aion, iris	Numerical libraries	The goal of the CGAL Open Source Project is to provide easy access to efficient and reliable geometric algorithms in the form of a C++ library.
CMake 3.18.4	broadwell, epyc, skylake, gpu	aion, iris	Development	CMake, the cross-platform, open-source build system. CMake is a family of tools designed to build, test and package software.
CMake 3.20.1	broadwell, epyc, skylake, gpu	aion, iris	Development	CMake, the cross-platform, open-source build system. CMake is a family of tools designed to build, test and package software.
CUDA 11.1.1	gpu	iris	System-level software	CUDA (formerly Compute Unified Device Architecture) is a parallel computing platform and programming model created by NVIDIA and implemented by the graphics processing units (GPUs) that they produce. CUDA gives developers access to the virtual instruction set and memory of the parallel computational elements in CUDA GPUs.
CUDAcore 11.1.1	gpu	iris	System-level software	CUDA (formerly Compute Unified Device Architecture) is a parallel computing platform and programming model created by NVIDIA and implemented by the graphics processing units (GPUs) that they produce. CUDA gives developers access to the virtual instruction set and memory of the parallel computational elements in CUDA GPUs.
Check 0.15.2	gpu	iris	Libraries	Check is a unit testing framework for C. It features a simple interface for defining unit tests, putting little in the way of the developer. Tests are run in a separate address space, so both assertion failures and code errors that cause segmentation faults or other signals can be caught. Test results are reportable in the following: Subunit, TAP, XML, and a generic logging format.
Clang 11.0.1	broadwell, epyc, skylake, gpu	aion, iris	Compilers	C, C++, Objective-C compiler, based on LLVM. Does not include C++ standard library -- use libstdc++ from GCC.
DB 18.1.40	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Berkeley DB enables the development of custom data management solutions, without the overhead traditionally associated with such custom projects.
DB_File 1.855	broadwell, epyc, skylake	aion, iris	Data processing	Perl5 access to Berkeley DB version 1.x.
DBus 1.13.18	broadwell, epyc, skylake	aion, iris	Development	D-Bus is a message bus system, a simple way for applications to talk to one another. In addition to interprocess communication, D-Bus helps coordinate process lifecycle; it makes it simple and reliable to code a "single instance" application or daemon, and to launch applications and daemons on demand when their services are needed.
Dakota 6.15.0	broadwell, skylake	iris	Mathematics	The Dakota project delivers both state-of-the-art research and robust, usable software for optimization and UQ. Broadly, the Dakota software's advanced parametric analyses enable design exploration, model calibration, risk analysis, and quantification of margins and uncertainty with computational models."
Doxygen 1.8.20	broadwell, epyc, skylake, gpu	aion, iris	Development	Doxygen is a documentation system for C++, C, Java, Objective-C, Python, IDL (Corba and Microsoft flavors), Fortran, VHDL, PHP, C#, and to some extent D.
ELPA 2020.11.001	broadwell, epyc, skylake	aion, iris	Mathematics	Eigenvalue SoLvers for Petaflop-Applications .
EasyBuild 4.4.1	broadwell, epyc, skylake	aion, iris	Utilities	EasyBuild is a software build and installation framework written in Python that allows you to install software in a structured, repeatable and robust way.
EasyBuild 4.4.2	broadwell, epyc, skylake	aion, iris	Utilities	EasyBuild is a software build and installation framework written in Python that allows you to install software in a structured, repeatable and robust way.
EasyBuild 4.5.4	broadwell, epyc, skylake	aion, iris	Utilities	EasyBuild is a software build and installation framework written in Python that allows you to install software in a structured, repeatable and robust way.
Eigen 3.3.8	broadwell, epyc, skylake, gpu	aion, iris	Mathematics	Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.
Eigen 3.4.0	broadwell, epyc, skylake, gpu	aion, iris	Mathematics	Eigen is a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.
Elk 7.0.12	broadwell, epyc, skylake	aion, iris	Physics	An all-electron full-potential linearised augmented-plane wave (FP-LAPW) code with many advanced features. Written originally at Karl-Franzens-Universität Graz as a milestone of the EXCITING EU Research and Training Network, the code is designed to be as simple as possible so that new developments in the field of density functional theory (DFT) can be added quickly and reliably.
FDS 6.7.6	broadwell, epyc, skylake	aion, iris	Physics	Fire Dynamics Simulator (FDS) is a large-eddy simulation (LES) code for low-speed flows, with an emphasis on smoke and heat transport from fires.
FFTW 3.3.8	broadwell, skylake, gpu	iris	Numerical libraries	FFTW is a C subroutine library for computing the discrete Fourier transform (DFT) in one or more dimensions, of arbitrary input size, and of both real and complex data.
FFmpeg 4.3.1	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	A complete, cross-platform solution to record, convert and stream audio and video.
FLAC 1.3.3	broadwell, epyc, skylake, gpu	aion, iris	Libraries	FLAC stands for Free Lossless Audio Codec, an audio format similar to MP3, but lossless, meaning that audio is compressed in FLAC without any loss in quality.
FLTK 1.3.5	broadwell, skylake	iris	Visualisation	FLTK is a cross-platform C++ GUI toolkit for UNIX/Linux (X11), Microsoft Windows, and MacOS X. FLTK provides modern GUI functionality without the bloat and supports 3D graphics via OpenGL and its built-in GLUT emulation.
FastQC 0.11.9	broadwell, skylake	iris	Biology	FastQC is a quality control application for high throughput sequence data. It reads in sequence data in a variety of formats and can either provide an interactive application to review the results of several different QC checks, or create an HTML based report which can be integrated into a pipeline.
Flask 1.1.2	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Flask is a lightweight WSGI web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications. This module includes the Flask extensions: Flask-Cors
Flink 1.11.2	broadwell, epyc, skylake	aion, iris	Development	Apache Flink is a framework and distributed processing engine for stateful computations over unbounded and bounded data streams. Flink has been designed to run in all common cluster environments, perform computations at in-memory speed and at any scale.
FreeImage 3.18.0	broadwell, epyc, skylake	aion, iris	Visualisation	FreeImage is an Open Source library project for developers who would like to support popular graphics image formats like PNG, BMP, JPEG, TIFF and others as needed by today's multimedia applications. FreeImage is easy to use, fast, multithreading safe.
FriBidi 1.0.10	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	The Free Implementation of the Unicode Bidirectional Algorithm.
GCC 10.2.0	broadwell, epyc, skylake, gpu	aion, iris	Compilers	The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Java, and Ada, as well as libraries for these languages (libstdc++, libgcj,...).
GCCcore 10.2.0	broadwell, epyc, skylake, gpu	aion, iris	Compilers	The GNU Compiler Collection includes front ends for C, C++, Objective-C, Fortran, Java, and Ada, as well as libraries for these languages (libstdc++, libgcj,...).
GDAL 3.2.1	broadwell, epyc, skylake, gpu	aion, iris	Data processing	GDAL is a translator library for raster geospatial data formats that is released under an X/MIT style Open Source license by the Open Source Geospatial Foundation. As a library, it presents a single abstract data model to the calling application for all supported formats. It also comes with a variety of useful commandline utilities for data translation and processing.
GDB 10.1	broadwell, epyc, skylake	aion, iris	Debugging	The GNU Project Debugger
GDRCopy 2.1	gpu	iris	Libraries	A low-latency GPU memory copy library based on NVIDIA GPUDirect RDMA technology.
GEOS 3.9.1	broadwell, epyc, skylake, gpu	aion, iris	Mathematics	GEOS (Geometry Engine - Open Source) is a C++ port of the Java Topology Suite (JTS)
GLPK 4.65	broadwell, skylake	iris	Utilities	The GLPK (GNU Linear Programming Kit) package is intended for solving large-scale linear programming (LP), mixed integer programming (MIP), and other related problems. It is a set of routines written in ANSI C and organized in the form of a callable library.
GLib 2.66.1	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	GLib is one of the base libraries of the GTK+ project
GMP 6.2.0	broadwell, epyc, skylake, gpu	aion, iris	Mathematics	GMP is a free library for arbitrary precision arithmetic, operating on signed integers, rational numbers, and floating point numbers.
GObject-Introspection 1.66.1	broadwell, epyc, skylake	aion, iris	Development	GObject introspection is a middleware layer between C libraries (using GObject) and language bindings. The C library can be scanned at compile time and generate a metadata file, in addition to the actual native C library. Then at runtime, language bindings can read this metadata and automatically provide bindings to call into the C library.
GROMACS 2021	broadwell, epyc, skylake	aion, iris	Biology	GROMACS is a versatile package to perform molecular dynamics, i.e. simulate the Newtonian equations of motion for systems with hundreds to millions of particles. This is a CPU only build, containing both MPI and threadMPI builds for both single and double precision. It also contains the gmxapi extension for the single precision MPI build.
GROMACS 2021.2	broadwell, epyc, skylake	aion, iris	Biology	GROMACS is a versatile package to perform molecular dynamics, i.e. simulate the Newtonian equations of motion for systems with hundreds to millions of particles. This is a CPU only build, containing both MPI and threadMPI builds for both single and double precision. It also contains the gmxapi extension for the single precision MPI build.
GSL 2.6	broadwell, skylake, gpu	iris	Numerical libraries	The GNU Scientific Library (GSL) is a numerical library for C and C++ programmers. The library provides a wide range of mathematical routines such as random number generators, special functions and least-squares fitting.
GTK+ 3.24.23	broadwell, epyc, skylake	aion, iris	Visualisation	GTK+ is the primary library used to construct user interfaces in GNOME. It provides all the user interface controls, or widgets, used in a common graphical application. Its object-oriented API allows you to construct user interfaces without dealing with the low-level details of drawing and device interaction.
Gdk-Pixbuf 2.40.0	broadwell, epyc, skylake	aion, iris	Visualisation	The Gdk Pixbuf is a toolkit for image loading and pixel buffer manipulation. It is used by GTK+ 2 and GTK+ 3 to load and manipulate images. In the past it was distributed as part of GTK+ 2 but it was split off into a separate package in preparation for the change to GTK+ 3.
Ghostscript 9.53.3	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Ghostscript is a versatile processor for PostScript data with the ability to render PostScript to different targets. It used to be part of the cups printing stack, but is no longer used for that.
Go 1.14.1	broadwell, skylake	iris	Compilers	Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.
Go 1.16.6	broadwell, epyc, skylake	aion, iris	Compilers	Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.
Gurobi 9.1.2	broadwell, epyc, skylake	aion, iris	Mathematics	The Gurobi Optimizer is a state-of-the-art solver for mathematical programming. The solvers in the Gurobi Optimizer were designed from the ground up to exploit modern architectures and multi-core processors, using the most advanced implementations of the latest algorithms.
HDF5 1.10.7	broadwell, epyc, skylake, gpu	aion, iris	Data processing	HDF5 is a data model, library, and file format for storing and managing data. It supports an unlimited variety of datatypes, and is designed for flexible and efficient I/O and for high volume and complex data.
HDF 4.2.15	broadwell, epyc, skylake, gpu	aion, iris	Data processing	HDF (also known as HDF4) is a library and multi-object file format for storing and managing data between machines.
HTSlib 1.12	broadwell, epyc, skylake	aion, iris	Biology	A C library for reading/writing high-throughput sequencing data. This package includes the utilities bgzip and tabix
Hadoop 2.10.0	broadwell, epyc, skylake	aion, iris	Utilities	Hadoop MapReduce by Cloudera
HarfBuzz 2.6.7	broadwell, epyc, skylake	aion, iris	Visualisation	HarfBuzz is an OpenType text shaping engine.
Horovod 0.22.0	gpu	iris	Utilities	Horovod is a distributed training framework for TensorFlow.
Hypre 2.20.0	broadwell, epyc, skylake	aion, iris	Numerical libraries	Hypre is a library for solving large, sparse linear systems of equations on massively parallel computers. The problems of interest arise in the simulation codes being developed at LLNL and elsewhere to study physical phenomena in the defense, environmental, energy, and biological sciences.
ICU 67.1	broadwell, epyc, skylake, gpu	aion, iris	Libraries	ICU is a mature, widely used set of C/C++ and Java libraries providing Unicode and Globalization support for software applications.
ISL 0.23	broadwell, epyc, skylake	aion, iris	Mathematics	isl is a library for manipulating sets and relations of integer points bounded by linear constraints.
ImageMagick 7.0.10-35	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	ImageMagick is a software suite to create, edit, compose, or convert bitmap images
JasPer 2.0.24	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	The JasPer Project is an open-source initiative to provide a free software-based reference implementation of the codec specified in the JPEG-2000 Part-1 standard.
Java 1.8.0_241	broadwell, skylake, gpu	iris	Programming Languages	Java Platform, Standard Edition (Java SE) lets you develop and deploy Java applications on desktops and servers.
Java 11.0.2	broadwell, epyc, skylake	aion, iris	Programming Languages	Java Platform, Standard Edition (Java SE) lets you develop and deploy Java applications on desktops and servers.
Java 13.0.2	broadwell, epyc, skylake	aion, iris	Programming Languages	Java Platform, Standard Edition (Java SE) lets you develop and deploy Java applications on desktops and servers.
Java 16.0.1	broadwell, epyc, skylake	aion, iris	Programming Languages	Java Platform, Standard Edition (Java SE) lets you develop and deploy Java applications on desktops and servers.
JsonCpp 1.9.4	broadwell, epyc, skylake, gpu	aion, iris	Libraries	JsonCpp is a C++ library that allows manipulating JSON values, including serialization and deserialization to and from strings. It can also preserve existing comment in unserialization/serialization steps, making it a convenient format to store user input files.
Julia 1.6.2	broadwell, epyc, skylake	aion, iris	Programming Languages	Julia is a high-level, high-performance dynamic programming language for numerical computing
Keras 2.4.3	broadwell, epyc, skylake, gpu	aion, iris	Mathematics	Keras is a deep learning API written in Python, running on top of the machine learning platform TensorFlow.
LAME 3.100	broadwell, skylake, gpu	iris	Data processing	LAME is a high quality MPEG Audio Layer III (MP3) encoder licensed under the LGPL.
LLVM 10.0.1	broadwell, epyc, skylake, gpu	aion, iris	Compilers	The LLVM Core libraries provide a modern source- and target-independent optimizer, along with code generation support for many popular CPUs (as well as some less common ones!) These libraries are built around a well specified code representation known as the LLVM intermediate representation ("LLVM IR"). The LLVM Core libraries are well documented, and it is particularly easy to invent your own language (or port an existing compiler) to use LLVM as an optimizer and code generator.
LLVM 11.0.0	broadwell, epyc, skylake, gpu	aion, iris	Compilers	The LLVM Core libraries provide a modern source- and target-independent optimizer, along with code generation support for many popular CPUs (as well as some less common ones!) These libraries are built around a well specified code representation known as the LLVM intermediate representation ("LLVM IR"). The LLVM Core libraries are well documented, and it is particularly easy to invent your own language (or port an existing compiler) to use LLVM as an optimizer and code generator.
LMDB 0.9.24	broadwell, skylake, gpu	iris	Libraries	LMDB is a fast, memory-efficient database. With memory-mapped files, it has the read performance of a pure in-memory database while retaining the persistence of standard disk-based databases.
LibTIFF 4.1.0	broadwell, epyc, skylake, gpu	aion, iris	Libraries	tiff: Library and tools for reading and writing TIFF data files
LittleCMS 2.11	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Little CMS intends to be an OPEN SOURCE small-footprint color management engine, with special focus on accuracy and performance.
Lua 5.4.2	broadwell, epyc, skylake	aion, iris	Programming Languages	Lua is a powerful, fast, lightweight, embeddable scripting language. Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode for a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping.
M4 1.4.18	broadwell, skylake, gpu	iris	Development	GNU M4 is an implementation of the traditional Unix macro processor. It is mostly SVR4 compatible although it has some extensions (for example, handling more than 9 positional parameters to macros). GNU M4 also has built-in functions for including files, running shell commands, doing arithmetic, etc.
MATLAB 2021a	broadwell, epyc, skylake	aion, iris	Mathematics	MATLAB is a high-level language and interactive environment that enables you to perform computationally intensive tasks faster than with traditional programming languages such as C, C++, and Fortran.
METIS 5.1.0	broadwell, skylake	iris	Mathematics	METIS is a set of serial programs for partitioning graphs, partitioning finite element meshes, and producing fill reducing orderings for sparse matrices. The algorithms implemented in METIS are based on the multilevel recursive-bisection, multilevel k-way, and multi-constraint partitioning schemes.
MPC 1.2.1	broadwell, epyc, skylake	aion, iris	Mathematics	Gnu Mpc is a C library for the arithmetic of complex numbers with arbitrarily high precision and correct rounding of the result. It extends the principles of the IEEE-754 standard for fixed precision real floating point numbers to complex numbers, providing well-defined semantics for every operation. At the same time, speed of operation at high precision is a major design goal.
MPFR 4.1.0	broadwell, epyc, skylake, gpu	aion, iris	Mathematics	The MPFR library is a C library for multiple-precision floating-point computations with correct rounding.
MUMPS 5.3.5	broadwell, epyc, skylake	aion, iris	Mathematics	A parallel sparse direct solver
Mako 1.1.3	broadwell, epyc, skylake, gpu	aion, iris	Development	A super-fast templating language that borrows the best ideas from the existing templating languages
Mathematica 12.1.0	broadwell, epyc, skylake	aion, iris	Mathematics	Mathematica is a computational software program used in many scientific, engineering, mathematical and computing fields.
Maven 3.6.3	broadwell, skylake	iris	Development	Binary maven install, Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information.
Mesa 20.2.1	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Mesa is an open-source implementation of the OpenGL specification - a system for rendering interactive 3D graphics.
Meson 0.55.3	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Meson is a cross-platform build system designed to be both as fast and as user friendly as possible.
NASM 2.15.05	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	NASM: General-purpose x86 assembler
NCCL 2.8.3	gpu	iris	Libraries	The NVIDIA Collective Communications Library (NCCL) implements multi-GPU and multi-node collective communication primitives that are performance optimized for NVIDIA GPUs.
NLopt 2.6.2	broadwell, epyc, skylake, gpu	aion, iris	Numerical libraries	NLopt is a free/open-source library for nonlinear optimization, providing a common interface for a number of different free optimization routines available online as well as original implementations of various other algorithms.
NSPR 4.29	broadwell, epyc, skylake	aion, iris	Libraries	Netscape Portable Runtime (NSPR) provides a platform-neutral API for system level and libc-like functions.
NSS 3.57	broadwell, epyc, skylake	aion, iris	Libraries	Network Security Services (NSS) is a set of libraries designed to support cross-platform development of security-enabled client and server applications.
Ninja 1.10.1	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Ninja is a small build system with a focus on speed.
OpenBLAS 0.3.12	broadwell, epyc, skylake, gpu	aion, iris	Numerical libraries	OpenBLAS is an optimized BLAS library based on GotoBLAS2 1.13 BSD version.
OpenCV 4.5.1	broadwell, epyc, skylake	aion, iris	Visualisation	OpenCV (Open Source Computer Vision Library) is an open source computer vision and machine learning software library. OpenCV was built to provide a common infrastructure for computer vision applications and to accelerate the use of machine perception in the commercial products. Includes extra modules for OpenCV from the contrib repository.
OpenEXR 2.5.5	broadwell, epyc, skylake	aion, iris	Visualisation	OpenEXR is a high dynamic-range (HDR) image file format developed by Industrial Light & Magic for use in computer imaging applications
OpenFOAM 8	epyc	aion	CFD/Finite element modelling	OpenFOAM is a free, open source CFD software package. OpenFOAM has an extensive range of features to solve anything from complex fluid flows involving chemical reactions, turbulence and heat transfer, to solid dynamics and electromagnetics.
OpenMPI 4.0.5	broadwell, epyc, skylake, gpu	aion, iris	MPI	The Open MPI Project is an open source MPI-3 implementation.
PAPI 6.0.0	broadwell, skylake	iris	Performance measurements	PAPI provides the tool designer and application engineer with a consistent interface and methodology for use of the performance counter hardware found in most major microprocessors. PAPI enables software engineers to see, in near real time, the relation between software performance and processor events. In addition Component PAPI provides access to a collection of components that expose performance measurement opportunites across the hardware and software stack.
PCRE2 10.35	broadwell, epyc, skylake, gpu	aion, iris	Development	The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.
PCRE 8.44	broadwell, epyc, skylake, gpu	aion, iris	Development	The PCRE library is a set of functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5.
PETSc 3.14.4	broadwell, epyc, skylake	aion, iris	Numerical libraries	PETSc, pronounced PET-see (the S is silent), is a suite of data structures and routines for the scalable (parallel) solution of scientific applications modeled by partial differential equations.
PLUMED 2.7.0	broadwell, epyc, skylake	aion, iris	Chemistry	PLUMED is an open source library for free energy calculations in molecular systems which works together with some of the most popular molecular dynamics engines. Free energy calculations can be performed as a function of many order parameters with a particular focus on biological problems, using state of the art methods such as metadynamics, umbrella sampling and Jarzynski-equation based steered MD. The software, written in C++, can be easily interfaced with both fortran and C/C++ codes.
POV-Ray 3.7.0.8	broadwell, epyc, skylake	aion, iris	Visualisation	The Persistence of Vision Raytracer, or POV-Ray, is a ray tracing program which generates images from a text-based scene description, and is available for a variety of computer platforms. POV-Ray is a high-quality, Free Software tool for creating stunning three-dimensional graphics. The source code is available for those wanting to do their own ports.
PROJ 7.2.1	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Program proj is a standard Unix filter function which converts geographic longitude and latitude coordinates into cartesian coordinates
Pango 1.47.0	broadwell, epyc, skylake	aion, iris	Visualisation	Pango is a library for laying out and rendering of text, with an emphasis on internationalization. Pango can be used anywhere that text layout is needed, though most of the work on Pango so far has been done in the context of the GTK+ widget toolkit. Pango forms the core of text and font handling for GTK+-2.x.
ParaView 5.8.1	broadwell, epyc, skylake	aion, iris	Visualisation	ParaView is a scientific parallel visualizer.
Perl 5.32.0	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Larry Wall's Practical Extraction and Report Language This is a minimal build without any modules. Should only be used for build dependencies.
Pillow 8.0.1	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Pillow is the 'friendly PIL fork' by Alex Clark and Contributors. PIL is the Python Imaging Library by Fredrik Lundh and Contributors.
PyOpenGL 3.1.5	broadwell, epyc, skylake	aion, iris	Visualisation	PyOpenGL is the most common cross platform Python binding to OpenGL and related APIs.
PyQt5 5.15.1	broadwell, epyc, skylake	aion, iris	Visualisation	PyQt5 is a set of Python bindings for v5 of the Qt application framework from The Qt Company. This bundle includes PyQtWebEngine, a set of Python bindings for The Qt Company’s Qt WebEngine framework.
PyQtGraph 0.11.1	broadwell, epyc, skylake	aion, iris	Visualisation	PyQtGraph is a pure-python graphics and GUI library built on PyQt5/PySide2 and numpy.
PyTorch-Geometric 1.6.3	broadwell, epyc, skylake, gpu	aion, iris	Libraries	PyTorch Geometric (PyG) is a geometric deep learning extension library for PyTorch.
PyTorch 1.7.1	gpu	iris	Development	Tensors and Dynamic neural networks in Python with strong GPU acceleration. PyTorch is a deep learning framework that puts Python first.
PyTorch 1.8.1	broadwell, epyc, skylake, gpu	aion, iris	Development	Tensors and Dynamic neural networks in Python with strong GPU acceleration. PyTorch is a deep learning framework that puts Python first.
PyTorch 1.9.0	broadwell, epyc, skylake, gpu	aion, iris	Development	Tensors and Dynamic neural networks in Python with strong GPU acceleration. PyTorch is a deep learning framework that puts Python first.
PyYAML 5.3.1	broadwell, epyc, skylake, gpu	aion, iris	Libraries	PyYAML is a YAML parser and emitter for the Python programming language.
Python 2.7.18	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Python is a programming language that lets you work more quickly and integrate your systems more effectively.
Python 3.8.6	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Python is a programming language that lets you work more quickly and integrate your systems more effectively.
Qt5 5.14.2	broadwell, epyc, skylake	aion, iris	Development	Qt is a comprehensive cross-platform C++ application framework.
QuantumESPRESSO 6.7	broadwell	iris	Chemistry	Quantum ESPRESSO is an integrated suite of computer codes for electronic-structure calculations and materials modeling at the nanoscale. It is based on density-functional theory, plane waves, and pseudopotentials (both norm-conserving and ultrasoft).
RDFlib 5.0.0	broadwell, epyc, skylake, gpu	aion, iris	Libraries	RDFLib is a Python library for working with RDF, a simple yet powerful language for representing information.
R 4.0.5	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	R is a free software environment for statistical computing and graphics.
ReFrame 3.6.3	broadwell, epyc, skylake	aion, iris	Development	ReFrame is a framework for writing regression tests for HPC systems.
Ruby 2.7.2	broadwell, epyc, skylake	aion, iris	Programming Languages	Ruby is a dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax that is natural to read and easy to write.
SAMtools 1.12	broadwell, epyc, skylake	aion, iris	Biology	SAM Tools provide various utilities for manipulating alignments in the SAM format, including sorting, merging, indexing and generating alignments in a per-position format.
SCOTCH 6.1.0	broadwell, epyc, skylake	aion, iris	Mathematics	Software package and libraries for sequential and parallel graph partitioning, static mapping, and sparse matrix block ordering, and sequential mesh and hypergraph partitioning.
SDL2 2.0.14	broadwell, epyc, skylake	aion, iris	Libraries	SDL: Simple DirectMedia Layer, a cross-platform multimedia library
SLEPc 3.14.2	broadwell, epyc, skylake	aion, iris	Numerical libraries	SLEPc (Scalable Library for Eigenvalue Problem Computations) is a software library for the solution of large scale sparse eigenvalue problems on parallel computers. It is an extension of PETSc and can be used for either standard or generalized eigenproblems, with real or complex arithmetic. It can also be used for computing a partial SVD of a large, sparse, rectangular matrix, and to solve quadratic eigenvalue problems.
SQLite 3.33.0	broadwell, epyc, skylake, gpu	aion, iris	Development	SQLite: SQL Database Engine in a C Library
SWIG 4.0.2	broadwell, epyc, skylake	aion, iris	Development	SWIG is a software development tool that connects programs written in C and C++ with a variety of high-level programming languages.
Salome 9.8.0	broadwell, epyc, skylake	aion, iris	CFD/Finite element modelling	The SALOME platform is an open source software framework for pre- and post-processing and integration of numerical solvers from various scientific fields. CEA and EDF use SALOME to perform a large number of simulations, typically related to power plant equipment and alternative energy. To address these challenges, SALOME includes a CAD/CAE modelling tool, mesh generators, an advanced 3D visualization tool, etc.
ScaLAPACK 2.1.0	broadwell, epyc, skylake, gpu	aion, iris	Numerical libraries	The ScaLAPACK (or Scalable LAPACK) library includes a subset of LAPACK routines redesigned for distributed memory MIMD parallel computers.
SciPy-bundle 2020.11	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Bundle of Python packages for scientific software
Singularity 3.8.1	broadwell, epyc, skylake	aion, iris	Utilities	SingularityCE is an open source container platform designed to be simple, fast, and secure. Singularity is optimized for EPC and HPC workloads, allowing untrusted users to run untrusted containers in a trusted way.
Spack 0.12.1	broadwell, skylake	iris	Development	Spack is a package manager for supercomputers, Linux, and macOS. It makes installing scientific software easy. With Spack, you can build a package with multiple versions, configurations, platforms, and compilers, and all of these builds can coexist on the same machine.
Stata 17	broadwell, epyc, skylake	aion, iris	Mathematics	Stata is a complete, integrated statistical software package that provides everything you need for data analysis, data management, and graphics.
SuiteSparse 5.8.1	broadwell, epyc, skylake	aion, iris	Numerical libraries	SuiteSparse is a collection of libraries manipulate sparse matrices.
Szip 2.1.1	broadwell, skylake, gpu	iris	Utilities	Szip compression software, providing lossless compression of scientific data
Tcl 8.6.10	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Tcl (Tool Command Language) is a very powerful but easy to learn dynamic programming language, suitable for a very wide range of uses, including web and desktop applications, networking, administration, testing and many more.
TensorFlow 2.4.1	broadwell, epyc, skylake, gpu	aion, iris	Libraries	An open-source software library for Machine Intelligence
TensorFlow 2.5.0	broadwell, epyc, skylake, gpu	aion, iris	Libraries	An open-source software library for Machine Intelligence
Theano 1.1.2	broadwell, epyc, skylake, gpu	aion, iris	Mathematics	Theano is a Python library that allows you to define, optimize, and evaluate mathematical expressions involving multi-dimensional arrays efficiently.
Tk 8.6.10	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Tk is an open source, cross-platform widget toolchain that provides a library of basic elements for building a graphical user interface (GUI) in many different programming languages.
Tkinter 3.8.6	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Tkinter module, built with the Python buildsystem
TopHat 2.1.2	broadwell, skylake	iris	Biology	TopHat is a fast splice junction mapper for RNA-Seq reads.
UCX 1.9.0	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Unified Communication X An open-source production grade communication framework for data centric and high-performance applications
UDUNITS 2.2.26	broadwell, skylake, gpu	iris	Physics	UDUNITS supports conversion of unit specifications between formatted and binary forms, arithmetic manipulation of units, and conversion of values between compatible scales of measurement.
ULHPC-bd 2020b	broadwell, epyc, skylake	aion, iris	System-level software	Generic Module bundle for BigData Analytics software in use on the UL HPC Facility
ULHPC-bio 2020b	broadwell, epyc, skylake	aion, iris	System-level software	Generic Module bundle for Bioinformatics, biology and biomedical software in use on the UL HPC Facility, especially at LCSB
ULHPC-cs 2020b	epyc	aion	System-level software	Generic Module bundle for Computational science software in use on the UL HPC Facility, including: - Computer Aided Engineering, incl. CFD - Chemistry, Computational Chemistry and Quantum Chemistry - Data management & processing tools - Earth Sciences - Quantum Computing - Physics and physical systems simulations
ULHPC-dl 2020b	broadwell, epyc, skylake	aion, iris	System-level software	Generic Module bundle for (CPU-version) of AI / Deep Learning / Machine Learning software in use on the UL HPC Facility
ULHPC-gpu 2020b	gpu	iris	System-level software	Generic Module bundle for GPU accelerated User Software in use on the UL HPC Facility
ULHPC-math 2020b	broadwell, epyc, skylake	aion, iris	System-level software	Generic Module bundle for High-level mathematical software and Linear Algrebra libraries in use on the UL HPC Facility
ULHPC-toolchains 2020b	broadwell, epyc, skylake	aion, iris	System-level software	Generic Module bundle that contains all the dependencies required to enable toolchains and building tools/programming language in use on the UL HPC Facility
ULHPC-tools 2020b	broadwell, epyc, skylake	aion, iris	System-level software	Misc tools, incl. - perf: Performance tools - tools: General purpose tools
UnZip 6.0	broadwell, epyc, skylake, gpu	aion, iris	Utilities	UnZip is an extraction utility for archives compressed in .zip format (also called "zipfiles"). Although highly compatible both with PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP's own Zip program, our primary objectives have been portability and non-MSDOS functionality.
VASP 5.4.4	broadwell, skylake	iris	Physics	The Vienna Ab initio Simulation Package (VASP) is a computer program for atomic scale materials modelling, e.g. electronic structure calculations and quantum-mechanical molecular dynamics, from first principles.
VASP 6.2.1	broadwell, epyc, skylake	aion, iris	Physics	The Vienna Ab initio Simulation Package (VASP) is a computer program for atomic scale materials modelling, e.g. electronic structure calculations and quantum-mechanical molecular dynamics, from first principles.
VMD 1.9.4a51	broadwell, epyc, skylake	aion, iris	Visualisation	VMD is a molecular visualization program for displaying, animating, and analyzing large biomolecular systems using 3-D graphics and built-in scripting.
VTK 9.0.1	broadwell, epyc, skylake	aion, iris	Visualisation	The Visualization Toolkit (VTK) is an open-source, freely available software system for 3D computer graphics, image processing and visualization. VTK consists of a C++ class library and several interpreted interface layers including Tcl/Tk, Java, and Python. VTK supports a wide variety of visualization algorithms including: scalar, vector, tensor, texture, and volumetric methods; and advanced modeling techniques such as: implicit modeling, polygon reduction, mesh smoothing, cutting, contouring, and Delaunay triangulation.
VTune 2020_update3	broadwell, epyc, skylake	aion, iris	Utilities	Intel VTune Amplifier XE is the premier performance profiler for C, C++, C#, Fortran, Assembly and Java.
Valgrind 3.16.1	broadwell, epyc, skylake	aion, iris	Debugging	Valgrind: Debugging and profiling tools
Wannier90 3.1.0	broadwell, epyc, skylake	aion, iris	Chemistry	A tool for obtaining maximally-localised Wannier functions
X11 20201008	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	The X Window System (X11) is a windowing system for bitmap displays
XML-LibXML 2.0206	broadwell, epyc, skylake	aion, iris	Data processing	Perl binding for libxml2
XZ 5.2.5	broadwell, epyc, skylake, gpu	aion, iris	Utilities	xz: XZ utilities
Xvfb 1.20.9	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Xvfb is an X server that can run on machines with no display hardware and no physical input devices. It emulates a dumb framebuffer using virtual memory.
YACS 0.1.8	broadwell, epyc, skylake	aion, iris	Libraries	YACS was created as a lightweight library to define and manage system configurations, such as those commonly found in software designed for scientific experimentation. These "configurations" typically cover concepts like hyperparameters used in training a machine learning model or configurable model hyperparameters, such as the depth of a convolutional neural network.
Yasm 1.3.0	broadwell, skylake, gpu	iris	Programming Languages	Yasm: Complete rewrite of the NASM assembler with BSD license
Z3 4.8.10	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Z3 is a theorem prover from Microsoft Research.
Zip 3.0	broadwell, skylake, gpu	iris	Utilities	Zip is a compression and file packaging/archive utility. Although highly compatible both with PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP's own UnZip, our primary objectives have been portability and other-than-MSDOS functionality
ant 1.10.9	broadwell, epyc, skylake	aion, iris	Development	Apache Ant is a Java library and command-line tool whose mission is to drive processes described in build files as targets and extension points dependent upon each other. The main known usage of Ant is the build of Java applications.
arpack-ng 3.8.0	broadwell, epyc, skylake	aion, iris	Numerical libraries	ARPACK is a collection of Fortran77 subroutines designed to solve large scale eigenvalue problems.
at-spi2-atk 2.38.0	broadwell, epyc, skylake	aion, iris	Visualisation	AT-SPI 2 toolkit bridge
at-spi2-core 2.38.0	broadwell, epyc, skylake	aion, iris	Visualisation	Assistive Technology Service Provider Interface.
binutils 2.35	broadwell, epyc, skylake, gpu	aion, iris	Utilities	binutils: GNU binary utilities
bokeh 2.2.3	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Statistical and novel interactive HTML plots for Python
bzip2 1.0.8	broadwell, skylake, gpu	iris	Utilities	bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.
cURL 7.72.0	broadwell, epyc, skylake, gpu	aion, iris	Utilities	libcurl is a free and easy-to-use client-side URL transfer library, supporting DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP. libcurl supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication (Basic, Digest, NTLM, Negotiate, Kerberos), file transfer resume, http proxy tunneling and more.
cairo 1.16.0	broadwell, skylake, gpu	iris	Visualisation	Cairo is a 2D graphics library with support for multiple output devices. Currently supported output targets include the X Window System (via both Xlib and XCB), Quartz, Win32, image buffers, PostScript, PDF, and SVG file output. Experimental backends include OpenGL, BeOS, OS/2, and DirectFB
cuDNN 8.0.4.30	gpu	iris	Numerical libraries	The NVIDIA CUDA Deep Neural Network library (cuDNN) is a GPU-accelerated library of primitives for deep neural networks.
cuDNN 8.0.5.39	gpu	iris	Numerical libraries	The NVIDIA CUDA Deep Neural Network library (cuDNN) is a GPU-accelerated library of primitives for deep neural networks.
dask 2021.2.0	broadwell, epyc, skylake, gpu	aion, iris	Data processing	Dask natively scales Python. Dask provides advanced parallelism for analytics, enabling performance at scale for the tools you love.
double-conversion 3.1.5	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Efficient binary-decimal and decimal-binary conversion routines for IEEE doubles.
elfutils 0.183	gpu	iris	Libraries	The elfutils project provides libraries and tools for ELF files and DWARF data.
expat 2.2.9	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Expat is an XML parser library written in C. It is a stream-oriented parser in which an application registers handlers for things the parser might find in the XML document (like start tags)
flatbuffers-python 1.12	broadwell, epyc, skylake, gpu	aion, iris	Development	Python Flatbuffers runtime library.
flatbuffers 1.12.0	broadwell, skylake, gpu	iris	Development	FlatBuffers: Memory Efficient Serialization Library
flex 2.6.4	broadwell, skylake, gpu	iris	Programming Languages	Flex (Fast Lexical Analyzer) is a tool for generating scanners. A scanner, sometimes called a tokenizer, is a program which recognizes lexical patterns in text.
fontconfig 2.13.92	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Fontconfig is a library designed to provide system-wide font configuration, customization and application access.
foss 2020b	broadwell, epyc, skylake	aion, iris	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain, including OpenMPI for MPI support, OpenBLAS (BLAS and LAPACK support), FFTW and ScaLAPACK.
fosscuda 2020b	gpu	iris	Toolchains (software stacks)	GCC based compiler toolchain with CUDA support, and including OpenMPI for MPI support, OpenBLAS (BLAS and LAPACK support), FFTW and ScaLAPACK.
freetype 2.10.3	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	FreeType 2 is a software font engine that is designed to be small, efficient, highly customizable, and portable while capable of producing high-quality output (glyph images). It can be used in graphics libraries, display servers, font conversion tools, text image generation tools, and many other products as well.
gcccuda 2020b	gpu	iris	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain, along with CUDA toolkit.
gettext 0.21	broadwell, epyc, skylake, gpu	aion, iris	Utilities	GNU 'gettext' is an important step for the GNU Translation Project, as it is an asset on which we may build many other steps. This package offers to programmers, translators, and even users, a well integrated set of tools and documentation
giflib 5.2.1	broadwell, skylake, gpu	iris	Libraries	giflib is a library for reading and writing gif images. It is API and ABI compatible with libungif which was in wide use while the LZW compression algorithm was patented.
git 2.28.0	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.
gmsh 4.8.4	broadwell, epyc, skylake	aion, iris	Mathematics	Gmsh is a 3D finite element grid generator with a build-in CAD engine and post-processor.
gnuplot 5.4.1	broadwell, epyc, skylake	aion, iris	Visualisation	Portable interactive, function plotting utility
gocryptfs 2.0.1	broadwell, epyc, skylake	aion, iris	Utilities	Encrypted overlay filesystem written in Go. gocryptfs uses file-based encryption that is implemented as a mountable FUSE filesystem. Each file in gocryptfs is stored as one corresponding encrypted file on the hard disk.
gompi 2020b	broadwell, epyc, skylake	aion, iris	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain, including OpenMPI for MPI support.
gompic 2020b	gpu	iris	Toolchains (software stacks)	GNU Compiler Collection (GCC) based compiler toolchain along with CUDA toolkit, including OpenMPI for MPI support with CUDA features enabled.
gperf 3.1	broadwell, skylake, gpu	iris	Development	GNU gperf is a perfect hash function generator. For a given list of strings, it produces a hash function and hash table, in form of C or C++ code, for looking up a value depending on the input string. The hash function is perfect, which means that the hash table has no collisions, and the hash table lookup needs a single string comparison only.
groff 1.22.4	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Groff (GNU troff) is a typesetting system that reads plain text mixed with formatting commands and produces formatted output.
gzip 1.10	broadwell, skylake	iris	Utilities	gzip (GNU zip) is a popular data compression program as a replacement for compress
h5py 3.1.0	broadwell, epyc, skylake, gpu	aion, iris	Data processing	HDF5 for Python (h5py) is a general-purpose Python interface to the Hierarchical Data Format library, version 5. HDF5 is a versatile, mature scientific software library designed for the fast, flexible storage of enormous amounts of data.
help2man 1.47.16	broadwell, epyc, skylake, gpu	aion, iris	Utilities	help2man produces simple manual pages from the '--help' and '--version' output of other commands.
help2man 1.47.4	broadwell, epyc, skylake, gpu	aion, iris	Utilities	help2man produces simple manual pages from the '--help' and '--version' output of other commands.
hwloc 2.2.0	broadwell, epyc, skylake, gpu	aion, iris	System-level software	The Portable Hardware Locality (hwloc) software package provides a portable abstraction (across OS, versions, architectures, ...) of the hierarchical topology of modern architectures, including NUMA memory nodes, sockets, shared caches, cores and simultaneous multithreading. It also gathers various system attributes such as cache and memory information as well as the locality of I/O devices such as network interfaces, InfiniBand HCAs or GPUs. It primarily aims at helping applications with gathering information about modern computing hardware so as to exploit it accordingly and efficiently.
hypothesis 5.41.2	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Hypothesis is an advanced testing library for Python. It lets you write tests which are parametrized by a source of examples, and then generates simple and comprehensible examples that make your tests fail. This lets you find more bugs in your code with less work.
hypothesis 5.41.5	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Hypothesis is an advanced testing library for Python. It lets you write tests which are parametrized by a source of examples, and then generates simple and comprehensible examples that make your tests fail. This lets you find more bugs in your code with less work.
iccifort 2020.4.304	broadwell, epyc, skylake, gpu	aion, iris	Compilers	Intel C, C++ & Fortran compilers
iccifortcuda 2020b	gpu	iris	Toolchains (software stacks)	Intel C, C++ & Fortran compilers with CUDA toolkit
iimpi 2020b	broadwell, epyc, skylake, gpu	aion, iris	Toolchains (software stacks)	Intel C/C++ and Fortran compilers, alongside Intel MPI.
iimpic 2020b	gpu	iris	Toolchains (software stacks)	Intel C/C++ and Fortran compilers, alongside Intel MPI and CUDA.
imkl 2020.4.304	broadwell, epyc, skylake, gpu	aion, iris	Numerical libraries	Intel Math Kernel Library is a library of highly optimized, extensively threaded math routines for science, engineering, and financial applications that require maximum performance. Core math functions include BLAS, LAPACK, ScaLAPACK, Sparse Solvers, Fast Fourier Transforms, Vector Math, and more.
impi 2019.9.304	broadwell, epyc, skylake, gpu	aion, iris	MPI	Intel MPI Library, compatible with MPICH ABI
intel 2020b	broadwell, epyc, skylake, gpu	aion, iris	Toolchains (software stacks)	Compiler toolchain including Intel compilers, Intel MPI and Intel Math Kernel Library (MKL).
intelcuda 2020b	gpu	iris	Toolchains (software stacks)	Intel Cluster Toolkit Compiler Edition provides Intel C/C++ and Fortran compilers, Intel MPI & Intel MKL, with CUDA toolkit
intltool 0.51.0	broadwell, skylake, gpu	iris	Development	intltool is a set of tools to centralize translation of many different file formats using GNU gettext-compatible PO files.
libGLU 9.0.1	broadwell, skylake, gpu	iris	Visualisation	The OpenGL Utility Library (GLU) is a computer graphics library for OpenGL.
libarchive 3.4.3	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Multi-format archive and compression library
libcerf 1.14	broadwell, epyc, skylake	aion, iris	Mathematics	libcerf is a self-contained numeric library that provides an efficient and accurate implementation of complex error functions, along with Dawson, Faddeeva, and Voigt functions.
libdrm 2.4.102	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Direct Rendering Manager runtime library.
libepoxy 1.5.4	broadwell, skylake	iris	Libraries	Epoxy is a library for handling OpenGL function pointer management for you
libevent 2.1.12	broadwell, epyc, skylake	aion, iris	Libraries	The libevent API provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached. Furthermore, libevent also support callbacks due to signals or regular timeouts.
libffi 3.3	broadwell, epyc, skylake, gpu	aion, iris	Libraries	The libffi library provides a portable, high level programming interface to various calling conventions. This allows a programmer to call any function specified by a call interface description at run-time.
libgd 2.3.0	broadwell, epyc, skylake	aion, iris	Libraries	GD is an open source code library for the dynamic creation of images by programmers.
libgeotiff 1.6.0	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Library for reading and writing coordinate system information from/to GeoTIFF files
libglvnd 1.3.2	broadwell, epyc, skylake, gpu	aion, iris	Libraries	libglvnd is a vendor-neutral dispatch layer for arbitrating OpenGL API calls between multiple vendors.
libgpuarray 0.7.6	gpu	iris	Libraries	Library to manipulate tensors on the GPU.
libiconv 1.16	broadwell, skylake, gpu	iris	Libraries	Libiconv converts from one character encoding to another through Unicode conversion
libjpeg-turbo 2.0.5	broadwell, epyc, skylake, gpu	aion, iris	Libraries	libjpeg-turbo is a fork of the original IJG libjpeg which uses SIMD to accelerate baseline JPEG compression and decompression. libjpeg is a library that implements JPEG image encoding, decoding and transcoding.
libogg 1.3.4	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Ogg is a multimedia container format, and the native file and stream format for the Xiph.org multimedia codecs.
libpciaccess 0.16	broadwell, epyc, skylake, gpu	aion, iris	System-level software	Generic PCI access library.
libpng 1.6.37	broadwell, skylake, gpu	iris	Libraries	libpng is the official PNG reference library
libreadline 8.0	broadwell, skylake, gpu	iris	Libraries	The GNU Readline library provides a set of functions for use by applications that allow users to edit command lines as they are typed in. Both Emacs and vi editing modes are available. The Readline library includes additional functions to maintain a list of previously-entered command lines, to recall and perhaps reedit those lines, and perform csh-like history expansion on previous commands.
libsndfile 1.0.28	broadwell, skylake, gpu	iris	Libraries	Libsndfile is a C library for reading and writing files containing sampled sound (such as MS Windows WAV and the Apple/SGI AIFF format) through one standard library interface.
libtirpc 1.3.1	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Libtirpc is a port of Suns Transport-Independent RPC library to Linux.
libtool 2.4.6	broadwell, skylake, gpu	iris	Libraries	GNU libtool is a generic library support script. Libtool hides the complexity of using shared libraries behind a consistent, portable interface.
libunwind 1.4.0	broadwell, epyc, skylake, gpu	aion, iris	Libraries	The primary goal of libunwind is to define a portable and efficient C programming interface (API) to determine the call-chain of a program. The API additionally provides the means to manipulate the preserved (callee-saved) state of each call-frame and to resume execution at any point in the call-chain (non-local goto). The API supports both local (same-process) and remote (across-process) operation. As such, the API is useful in a number of applications
libvorbis 1.3.7	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Ogg Vorbis is a fully open, non-proprietary, patent-and-royalty-free, general-purpose compressed audio format
libwebp 1.1.0	broadwell, epyc, skylake	aion, iris	Libraries	WebP is a modern image format that provides superior lossless and lossy compression for images on the web. Using WebP, webmasters and web developers can create smaller, richer images that make the web faster.
libxc 4.3.4	broadwell, skylake	iris	Chemistry	Libxc is a library of exchange-correlation functionals for density-functional theory. The aim is to provide a portable, well tested and reliable set of exchange and correlation functionals.
libxc 5.1.2	broadwell, epyc, skylake	aion, iris	Chemistry	Libxc is a library of exchange-correlation functionals for density-functional theory. The aim is to provide a portable, well tested and reliable set of exchange and correlation functionals.
libxml2 2.9.10	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Libxml2 is the XML C parser and toolchain developed for the Gnome project (but usable outside of the Gnome platform).
libyaml 0.2.5	broadwell, epyc, skylake, gpu	aion, iris	Libraries	LibYAML is a YAML parser and emitter written in C.
lz4 1.9.2	broadwell, epyc, skylake, gpu	aion, iris	Libraries	LZ4 is lossless compression algorithm, providing compression speed at 400 MB/s per core. It features an extremely fast decoder, with speed in multiple GB/s per core.
magma 2.5.4	gpu	iris	Mathematics	The MAGMA project aims to develop a dense linear algebra library similar to LAPACK but for heterogeneous/hybrid architectures, starting with current Multicore+GPU systems.
makeinfo 6.7	broadwell, epyc, skylake, gpu	aion, iris	Development	makeinfo is part of the Texinfo project, the official documentation format of the GNU project.
matplotlib 3.3.3	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	matplotlib is a python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. matplotlib can be used in python scripts, the python and ipython shell, web application servers, and six graphical user interface toolkits.
ncurses 6.2	broadwell, epyc, skylake, gpu	aion, iris	Development	The Ncurses (new curses) library is a free software emulation of curses in System V Release 4.0, and more. It uses Terminfo format, supports pads and color and multiple highlights and forms characters and function-key mapping, and has all the other SYSV-curses enhancements over BSD Curses.
netCDF-Fortran 4.5.3	epyc	aion	Data processing	NetCDF (network Common Data Form) is a set of software libraries and machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.
netCDF 4.7.4	broadwell, epyc, skylake, gpu	aion, iris	Data processing	NetCDF (network Common Data Form) is a set of software libraries and machine-independent data formats that support the creation, access, and sharing of array-oriented scientific data.
nettle 3.6	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Nettle is a cryptographic library that is designed to fit easily in more or less any context: In crypto toolkits for object-oriented languages (C++, Python, Pike, ...), in applications like LSH or GNUPG, or even in kernel space.
networkx 2.5	broadwell, epyc, skylake, gpu	aion, iris	Utilities	NetworkX is a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.
nodejs 12.19.0	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Node.js is a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.
nsync 1.24.0	broadwell, skylake, gpu	iris	Development	nsync is a C library that exports various synchronization primitives, such as mutexes
numactl 2.0.13	broadwell, epyc, skylake, gpu	aion, iris	Utilities	The numactl program allows you to run your application program on specific cpu's and memory nodes. It does this by supplying a NUMA memory policy to the operating system before running your program. The libnuma library provides convenient ways for you to add NUMA memory policies into your own program.
numba 0.52.0	broadwell, epyc, skylake, gpu	aion, iris	Programming Languages	Numba is an Open Source NumPy-aware optimizing compiler for Python sponsored by Continuum Analytics, Inc. It uses the remarkable LLVM compiler infrastructure to compile Python syntax to machine code.
pixman 0.40.0	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	Pixman is a low-level software library for pixel manipulation, providing features such as image compositing and trapezoid rasterization. Important users of pixman are the cairo graphics library and the X server.
pkg-config 0.29.2	broadwell, skylake, gpu	iris	Development	pkg-config is a helper tool used when compiling applications and libraries. It helps you insert the correct compiler options on the command line so an application can use gcc -o test test.c pkg-config --libs --cflags glib-2.0 for instance, rather than hard-coding values on where to find glib (or other libraries).
pkgconfig 1.5.1	broadwell, skylake, gpu	iris	Development	pkgconfig is a Python module to interface with the pkg-config command line tool
pocl 1.6	gpu	iris	Libraries	Pocl is a portable open source (MIT-licensed) implementation of the OpenCL standard
protobuf-python 3.14.0	broadwell, epyc, skylake, gpu	aion, iris	Development	Python Protocol Buffers runtime library.
protobuf 2.5.0	broadwell, skylake	iris	Development	Google Protocol Buffers
protobuf 3.14.0	broadwell, epyc, skylake	aion, iris	Development	Google Protocol Buffers
pybind11 2.6.0	broadwell, epyc, skylake, gpu	aion, iris	Libraries	pybind11 is a lightweight header-only library that exposes C++ types in Python and vice versa, mainly to create Python bindings of existing C++ code.
re2c 2.0.3	broadwell, epyc, skylake	aion, iris	Utilities	re2c is a free and open-source lexer generator for C and C++. Its main goal is generating fast lexers: at least as fast as their reasonably optimized hand-coded counterparts. Instead of using traditional table-driven approach, re2c encodes the generated finite state automata directly in the form of conditional jumps and comparisons.
scikit-build 0.11.1	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Scikit-Build, or skbuild, is an improved build system generator for CPython C/C++/Fortran/Cython extensions.
scikit-image 0.18.1	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	scikit-image is a collection of algorithms for image processing.
scikit-learn 0.23.2	broadwell, epyc, skylake, gpu	aion, iris	Data processing	Scikit-learn integrates machine learning algorithms in the tightly-knit scientific Python world, building upon numpy, scipy, and matplotlib. As a machine-learning module, it provides versatile tools for data mining and analysis in any field of science and engineering. It strives to be simple and efficient, accessible to everybody, and reusable in various contexts.
snappy 1.1.8	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Snappy is a compression/decompression library. It does not aim for maximum compression, or compatibility with any other compression library; instead, it aims for very high speeds and reasonable compression.
sparsehash 2.0.4	broadwell, epyc, skylake	aion, iris	Development	An extremely memory-efficient hash_map implementation. 2 bits/entry overhead! The SparseHash library contains several hash-map implementations, including implementations that optimize for space or speed.
spglib-python 1.16.0	broadwell, epyc, skylake, gpu	aion, iris	Chemistry	Spglib for Python. Spglib is a library for finding and handling crystal symmetries written in C.
tbb 2020.3	broadwell, epyc, skylake	aion, iris	Libraries	Intel(R) Threading Building Blocks (Intel(R) TBB) lets you easily write parallel C++ programs that take full advantage of multicore performance, that are portable, composable and have future-proof scalability.
tqdm 4.56.2	broadwell, epyc, skylake, gpu	aion, iris	Libraries	A fast, extensible progress bar for Python and CLI
typing-extensions 3.7.4.3	gpu	iris	Development	Typing Extensions – Backported and Experimental Type Hints for Python
util-linux 2.36	broadwell, epyc, skylake, gpu	aion, iris	Utilities	Set of Linux utilities
x264 20201026	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	x264 is a free software library and application for encoding video streams into the H.264/MPEG-4 AVC compression format, and is released under the terms of the GNU GPL.
x265 3.3	broadwell, epyc, skylake, gpu	aion, iris	Visualisation	x265 is a free software library and application for encoding video streams into the H.265 AVC compression format, and is released under the terms of the GNU GPL.
xorg-macros 1.19.2	broadwell, skylake, gpu	iris	Development	X.org macros utilities.
xprop 1.2.5	broadwell, epyc, skylake	aion, iris	Visualisation	The xprop utility is for displaying window and font properties in an X server. One window or font is selected using the command line arguments or possibly in the case of a window, by clicking on the desired window. A list of properties is then given, possibly with formatting information.
zlib 1.2.11	broadwell, skylake, gpu	iris	Libraries	zlib is designed to be a free, general-purpose, legally unencumbered -- that is, not covered by any patents -- lossless data-compression library for use on virtually any computer hardware and operating system.
zstd 1.4.5	broadwell, epyc, skylake, gpu	aion, iris	Libraries	Zstandard is a real-time compression algorithm, providing high compression ratios. It offers a very wide range of compression/speed trade-off, while being backed by a very fast decoder. It also offers a special mode for small data, called dictionary compression, and can create dictionaries from any sample set.


Compiling/Building your own software

We try to provide within the ULHPC software sets the most used application among our users. It may however happen that you may find a given software you expect to use to be either missing among the available software sets, or provided in a version you considered not enough recent.

In that case, the RECOMMENDED approach is to rely on Easybuild to EXTEND the available software set. Below are guidelines to support that case.

Alternatively, you can of course follow the installation guidelines provided on the software website to compile it the way it should be. For that case, you MUST rely on the provided toolchains and compilers.

In all cases, NEVER compile or build softawre from the ULHPC frontends! Always perform these actions from the expected compute node, either reserved within an interactive job or through a passive submission

Missing or Outdated Software

You should first search if an existing Easyconfig exists for the software:


# Typical check for user on ULHPC clusters
$ si    # get an interactive job - use 'si-gpu' for GPU nodes on iris
$ module load tools/EasyBuild
$ eb -S <name>
It shoud match the available software set versions summarized below:

Name	Type	2019b (legacy)	2020b (release)	2023b (development)	(testing)
GCCCore	compiler	8.3.0	10.2.0	13.2.0	
foss	toolchain	2019b	2020b	2023b	
intel	toolchain	2019b	2020b	2023b	
binutils		2.32	2.35	2.40	
Python		3.7.4 (and 2.7.16)	3.8.6	3.11.5	
Clang	compiler	9.0.1	11.0.0	17.0.6	
OpenMPI	MPI	3.1.4	4.0.5	4.1.6	
You will then be confronted to the following cases.

An existing easyconfigs exists for the target toolchain version

You're lucky but this is very likely to happen (and justify to rely on streamline Easyconfigs)

Typical Example:
CMake-<version>-GCCcore-<gccversion>.eb: depends on GCCcore, thus common to both foss and intel. The same happens with GCC
Go-<version>.eb (no dependency on any toolchain)
Boost-<version>-{gompi,iimpi}-<toolchainversion>.eb, derived toolchains, compliant with foss (resp. intel) ones;
GDAL-<version>-{foss,intel}-<toolchainversion>-Python-<pythonversion>.eb
In that case, you MUST test the build in your home or in a shared project using the resif-load-{home,project}-swset-{prod,devel} helpers to set a consistent environment for your builds compilant with the ULHPC software sets layout (in particular with regards the $EASYBUILD_PREFIX and $MODULEPATH environment variables). See below for building instructions.

An outdated easyconfig exists

Then the easiest way is to adapt the existing easyconfig file for the target softare version AND one of the available toolchain version. You may want also to ensure an ongoing Pull-Request is not dealing with the version you're looking for.

Assuming you're looking for the software <name> (first letter <letter (in lower case), for instance if <name>=NWChem, then <letter>=n), first copy the existing easyconfig file in a convenient place


# Create host directory for your custom easyconfigs
$ mkdir -p ~/easyconfigs/<letter>/<name>

$ eb -S <name>` # find the complete path to the easyconfig file
CFGS1=[...]/path/to/easyconfigs
* $CFGS1/<letter>/<name>/<name>-<oldversion>[...].eb
* $CFGS1/<letter>/<name>/<name>-[...].patch     # Eventual Patch file

# copy/paste the definition of the CFGS1 variable (top line)
CFGS1=[...]/path/to/easyconfigs
# copy the eb file
cp $CFGS1/<letter>/<name>/<name>-<oldversion>[...].eb ~/easyconfigs/<letter>/<name>
Now (eventually) check on the software website for the most up-to-date version <version> of the software released. Adapt the filename of the copied easyconfig to match the target version / toolchain


cd ~/easyconfigs/<letter>/<name>
mv <name>-<oldversion>[...].eb <name>-<version>[...].eb
Example

cd ~/easyconfigs/n/NWCHem
mv NWChem-7.0.0-intel-2019b-Python-3.7.4.eb NWChem-7.0.2-intel-2021b.eb  # Target 2021b intel toolchain, no more need for python suffix
Now you shall edit the content of the easyconfig -- you'll typically have to adapt the version of the dependencies and the checksum(s) to match the static versions set for the target toolchain, enforce https urls etc.

Below is a past complex exemple illustrating the adaptation done for GDB


--- g/GDB/GDB-8.3-GCCcore-8.2.0-Python-3.7.2.eb 2020-03-31 12:17:03.000000000 +0200
+++ g/GDB/GDB-9.1-GCCcore-8.3.0-Python-3.7.4.eb 2020-05-08 15:49:41.000000000 +0200
@@ -1,31 +1,36 @@
 easyblock = 'ConfigureMake'

 name = 'GDB'
-version = '8.3'
+version = '9.1'
 versionsuffix = '-Python-%(pyver)s'

-homepage = 'http://www.gnu.org/software/gdb/gdb.html'
+homepage = 'https://www.gnu.org/software/gdb/gdb.html'
 description = "The GNU Project Debugger"

-toolchain = {'name': 'GCCcore', 'version': '8.2.0'}
+toolchain = {'name': 'GCCcore', 'version': '8.3.0'}

 source_urls = [GNU_SOURCE]
 sources = [SOURCELOWER_TAR_XZ]
-checksums = ['802f7ee309dcc547d65a68d61ebd6526762d26c3051f52caebe2189ac1ffd72e']
+checksums = ['699e0ec832fdd2f21c8266171ea5bf44024bd05164fdf064e4d10cc4cf0d1737']

 builddependencies = [
-    ('binutils', '2.31.1'),
-    ('texinfo', '6.6'),
+    ('binutils', '2.32'),
+    ('texinfo', '6.7'),
 ]

 dependencies = [
     ('zlib', '1.2.11'),
     ('libreadline', '8.0'),
     ('ncurses', '6.1'),
-    ('expat', '2.2.6'),
-    ('Python', '3.7.2'),
+    ('expat', '2.2.7'),
+    ('Python', '3.7.4'),
 ]

+preconfigopts = "mkdir obj && cd obj && "
+configure_cmd_prefix = '../'
+prebuildopts = "cd obj && "
+preinstallopts = prebuildopts
+
 configopts = '--with-system-zlib --with-python=$EBROOTPYTHON/bin/python --with-expat=$EBROOTEXPAT '
 configopts += '--with-system-readline --enable-tui --enable-plugins --disable-install-libbfd '
Note on dependencies version: typically as in the above example, the version to use for dependencies are not obvious to guess (Ex: texinfo, expat etc.) and you need to be aware of the matching toolchain/GCC/binutils versions for the available prod or devel software sets recalled before -- use eb -S <dependency> to find the appropriate versions.

None (or only very old/obsolete) easyconfigs are suggested

Don't panic, it simply means that the official repositories do not hold any recent reciPY for the considered software. You may find a pending Pull-request addressing the software you're looking for.

Otherwise, you can either try to create a new easyconfig file, or simply follow the installation guildes for the considered software to build it.

Using Easybuild to Build software in your Home

See also Technical documentation to better understand the Easybuild configuration.

If upon Dry-run builds (eb -Dr [...]) you find most dependencies NOT satisfied, you've likely made an error and may be trying to build a software against a toolchain/software set not supported either as prod or devel.


# BETTER work in a screen or tmux session ;)
$ si[-gpu] [-c <threads>]   # get an interactive job
$ module load tools/EasyBuild
# /!\ IMPORTANT: ensure EASYBUILD_PREFIX is correctly set to [basedir]/<cluster>/<environment>/<arch>
#                and that MODULEPATH is prefixed accordingly
$ resif-load-home-swset-{prod | devel}  # adapt environment
$ eb -S <softwarename>   # confirm <filename>.eb == <softwarename>-<version>[-<toolchain>][-<suffix>].eb
$ eb -Dr <filename>.eb   # check dependencies, normally most MUST be satisfied
$ eb -r  <filename>.eb
From that point, the compiled software and associated module is available in your home and can be used as follows in launchers etc. -- see ULHPC launcher Examples


#!/bin/bash -l # <--- DO NOT FORGET '-l' to facilitate further access to ULHPC modules
#SBATCH -p <partition>
#SBATCH -N 1
#SBATCH --ntasks-per-node <#sockets * s>
#SBATCH --ntasks-per-socket <s>
#SBATCH -c <thread>

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }
# Safeguard for NOT running this launcher on access/login nodes
module purge || print_error_and_exit "No 'module' command"

resif-load-home-swset-prod  # OR  resif-load-home-swset-devel
module load <softwarename>[/<version>]
[...]
Using Easybuild to Build software in the project

Similarly to the above home builds, you should repeat the procedure this time using the helper script resif-load-project-swset-{prod | devel}. Don't forget Project Data Management instructions: to avoid quotas issues, you have to use sg


# BETTER work in a screen or tmux session ;)
$ si[-gpu] [-c <threads>]   # get an interactive job
$ module load tools/EasyBuild
# /!\ IMPORTANT: ensure EASYBUILD_PREFIX is correctly set to [basedir]/<cluster>/<environment>/<arch>
#                and that MODULEPATH is prefixed accordingly
$ resif-load-project-swset-{prod | devel} $PROJECTHOME/<project> # /!\ ADAPT environment and <project> accordingly
$ sg <project> -c "eb -S <softwarename>"   # confirm <filename>.eb == <softwarename>-<v>-<toolchain>.eb
$ sg <project> -c "eb -Dr <filename>.eb"   # check dependencies, normally most MUST be satisfied
$ sg <project> -c "eb -r  <filename>.eb"
From that point, the compiled software and associated module is available in the project directoryand can be used by all project members as follows in launchers etc. -- see ULHPC launcher Examples


#!/bin/bash -l # <--- DO NOT FORGET '-l' to facilitate further access to ULHPC modules
#SBATCH -p <partition>
#SBATCH -N 1
#SBATCH --ntasks-per-node <#sockets * s>
#SBATCH --ntasks-per-socket <s>
#SBATCH -c <thread>

print_error_and_exit() { echo "***ERROR*** $*"; exit 1; }
# Safeguard for NOT running this launcher on access/login nodes
module purge || print_error_and_exit "No 'module' command"

resif-load-project-swset-prod  $PROJECTHOME/<project> # OR resif-load-project-swset-devel $PROJECTHOME/<project>
module load <softwarename>[/<version>]
[...]
Contribute back to Easybuild

If you developped new easyconfig(s), you are expected to contribute them back to the Easybuilders community! Consider creating a Pull-Request. You can even do it by command-line assuming you have setup your Github integration. On iris or aion, you will likely need to install the possibly-insecure, alternate keyrings keyrings.alt packages -- see https://pypi.org/project/keyring/


# checking code style - see https://easybuild.readthedocs.io/en/latest/Code_style.html#code-style
eb --check-contrib <ebfile>
eb --new-pr <ebfile>
You can can also consider using the script PR-create provided as part of the RESIF 3 project.

Once the pull request is merged, you can inform the ULHPC team to consider adding the submitted Easyconfig as part of the ULHPC bundles and see it deployed within the next ULHPC software set release.

EESSI - European Environment for Scientific Software Installations



The European Environment for Scientific Software Installations (EESSI, pronounced as "easy") is a collaboration between different European partners in HPC community. The goal of this project is to build a common stack of scientific software installations for HPC systems and beyond, including laptops, personal workstations and cloud infrastructure.

The EESSI software stack is available on the ULHPC platform, and gives you access to software modules maintained by the EESSI project and optimized for the CPU architectures available on the ULHPC platform.

On a compute node, to set up the EESSI environment, simply load the EESSI module:


module load EESSI
The first usage may be slow as the files are downloaded from an upstream Stratum 1 server, but the files are cached locally.

You should see the following output:


$ module load EESSI
EESSI/2023.06 loaded successfully
The last line is the shell output.

Your environment is now set up, you are ready to start running software provided by EESSI! To see which modules (and extensions) are available, run:


module avail
Here is a short excerpt of the output produced by module avail:


----- /cvmfs/software.eessi.io/versions/2023.06/software/linux/x86_64/amd/zen2/modules/all -----
   ALL/0.9.2-foss-2023a           ESPResSo/4.2.1-foss-2023a        foss/2023a            h5py/3.9.0-foss-2023a
   ParaView/5.11.2-foss-2023a     PyTorch/2.1.2-foss-2023a         QuantumESPRESSO/7.2-foss-2022b   VTK/9.3.0-foss-2023a
   ELPA/2022.05.001-foss-2022b    foss/2022b                       foss/2023b (D)        OpenFOAM/11-foss-2023a
...
For more precise information, please refer to the official documentation.

Containers

Many applications and libraries can also be used through container systems, with the updated Singularity tool providing many new features of which we can especially highlight support for Open Containers Initiative - OCI containers (including Docker OCI), and support for secure containers - building and running encrypted containers with RSA keys and passphrases.

Singularity


The ULHPC offers the possibilty to run Singularity containers. Singularity is an open source container platform designed to be simple, fast, and secure. Singularity is optimized for EPC and HPC workloads, allowing untrusted users to run untrusted containers in a trusted way.

Loading Singularity

To use Singularity, you need to load the corresponding Lmod module.


>$ module load tools/Singularity
Warning
Modules are not allowed on the access servers. To test interactively Singularity, rememerber to ask for an interactive job first.


salloc -p interactive --pty bash
Pulling container images

Like Docker, Singularity provide a way to pull images from a Hubs such as DockerHub and Singuarity Hub.


>$ singularity pull docker://ubuntu:latest
You should see the following output:
Output
INFO:    Converting OCI blobs to SIF format
INFO:    Starting build...
Getting image source signatures
Copying blob d72e567cc804 done
Copying blob 0f3630e5ff08 done
Copying blob b6a83d81d1f4 done
Copying config bbea2a0436 done
Writing manifest to image destination
Storing signatures
...
INFO:    Creating SIF file...
You may now test the container by executing some inner commands:


>$ singularity exec ubuntu_latest.sif cat /etc/os-release
Output
NAME="Ubuntu"
VERSION="20.04.1 LTS (Focal Fossa)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 20.04.1 LTS"
VERSION_ID="20.04"
HOME_URL="https://www.ubuntu.com/&quot;
SUPPORT_URL="https://help.ubuntu.com/&quot;
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/&quot;
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;
VERSION_CODENAME=focal
UBUNTU_CODENAME=focal
Building container images

Building container images requires to have root privileges. Therefore, users have to build images on their local machine before transfering them to the platform. Please refer to the Data transfer section for this purpose.

Note
Singularity 3 introduces the ability to build your containers in the cloud, so you can easily and securely create containers for your applications without speci al privileges or setup on your local system. The Remote Builder can securely build a container for you from a definition file entered here or via the Singularity CLI (see https://cloud.sylabs.io/builder for more details).

GPU-enabled Singularity containers

This section relies on the very excellent documentation from CSCS. In the following example, a container with CUDA features is build, transfered and tested on the ULHPC platform. This example will pull a CUDA container from DockrHub and setup CUDA examples. For this purpose, a singularity definition file, i.e., cuda_samples.def needs to be created with the following content:


Bootstrap: docker
From: nvidia/cuda:10.1-devel

%post
    apt-get update
    apt-get install -y git
    git clone https://github.com/NVIDIA/cuda-samples.git /usr/local/cuda_samples
    cd /usr/local/cuda_samples
    git fetch origin --tags
    git checkout 10.1.1
    make

%runscript
    /usr/local/cuda_samples/Samples/deviceQuery/deviceQuery
On a local machine having singularity installed, we can build the container image, i.e., cuda_samples.sif using the definition file using the follwing singularity command:


sudo singularity build cuda_samples.sif cuda_samples.def
Warning
You should have root privileges on this machine. Without this condition, you will not be able to built the definition file.

Once the container is built and transfered to your dedicated storage on the ULHPC plaform, the container can be executed with the following command:


# Inside an interactive job on a gpu-enabled node
singularity run --nv cuda_samples.sif
Warning
In order to run a CUDA-enabled container, the --nv option has to be passed to singularity run. According to this option, singularity is going to setup the container environment to use the NVIDIA GPU and the basic CUDA libraries.

Output
CUDA Device Query (Runtime API) version (CUDART static linking)

Detected 1 CUDA Capable device(s)


Device 0: "Tesla V100-SXM2-16GB"
  CUDA Driver Version / Runtime Version          10.2 / 10.1
  CUDA Capability Major/Minor version number:    7.0
  Total amount of global memory:                 16160 MBytes (16945512448 bytes)
  (80) Multiprocessors, ( 64) CUDA Cores/MP:     5120 CUDA Cores
  GPU Max Clock rate:                            1530 MHz (1.53 GHz)
  Memory Clock rate:                             877 Mhz
  Memory Bus Width:                              4096-bit
  L2 Cache Size:                                 6291456 bytes
  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)
  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers
  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers
  Total amount of constant memory:               65536 bytes
  Total amount of shared memory per block:       49152 bytes
  Total number of registers available per block: 65536
  Warp size:                                     32
  Maximum number of threads per multiprocessor:  2048
  Maximum number of threads per block:           1024
  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)
  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)
  Maximum memory pitch:                          2147483647 bytes
  Texture alignment:                             512 bytes
  Concurrent copy and kernel execution:          Yes with 5 copy engine(s)
  Run time limit on kernels:                     No
  Integrated GPU sharing Host Memory:            No
  Support host page-locked memory mapping:       Yes
  Alignment requirement for Surfaces:            Yes
  Device has ECC support:                        Enabled
  Device supports Unified Addressing (UVA):      Yes
  Device supports Compute Preemption:            Yes
  Supports Cooperative Kernel Launch:            Yes
  Supports MultiDevice Co-op Kernel Launch:      Yes
  Device PCI Domain ID / Bus ID / location ID:   0 / 30 / 0
  Compute Mode:
     < Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) >


deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 10.2, CUDA Runtime Version = 10.1, NumDevs = 1
Result = PASS

MPI and Singularity containers

This section relies on the very excellent documentation from CSCS. The following singularity definition file mpi_osu.def can be used to build a container with the osu benchmarks using mpi:


bootstrap: docker
from: debian:jessie

%post
    # Install software
    apt-get update
    apt-get install -y file g++ gcc gfortran make gdb strace realpath wget curl --no-install-recommends

    # Install mpich
    curl -kO https://www.mpich.org/static/downloads/3.1.4/mpich-3.1.4.tar.gz
    tar -zxvf mpich-3.1.4.tar.gz
    cd mpich-3.1.4
    ./configure --disable-fortran --enable-fast=all,O3 --prefix=/usr
    make -j$(nproc)
    make install
    ldconfig

    # Build osu benchmarks
    wget -q http://mvapich.cse.ohio-state.edu/download/mvapich/osu-micro-benchmarks-5.3.2.tar.gz
    tar xf osu-micro-benchmarks-5.3.2.tar.gz
    cd osu-micro-benchmarks-5.3.2
    ./configure --prefix=/usr/local CC=$(which mpicc) CFLAGS=-O3
    make
    make install
    cd ..
    rm -rf osu-micro-benchmarks-5.3.2
    rm osu-micro-benchmarks-5.3.2.tar.gz

%runscript
    /usr/local/libexec/osu-micro-benchmarks/mpi/pt2pt/osu_bw

sudo singularity build mpi_osu.sif mpi_osu.def
Once the container image is ready, you can use it for example inside the following slurm launcher to start a best-effort job:

#!/bin/bash -l
#SBATCH -J ParallelJob
#SBATCH -N 2
#SBATCH --ntasks-per-node=1
#SBATCH --time=05:00
#SBATCH -p batch
#SBATCH --qos=qos-besteffort

module load tools/Singularity
srun -n $SLURM_NTASKS singularity run mpi_osu.sif
The content of the output file:
Output
# OSU MPI Bandwidth Test v5.3.2
# Size      Bandwidth (MB/s)
1                       0.35
2                       0.78
4                       1.70
8                       3.66
16                      7.68
32                     16.38
64                     32.86
128                    66.61
256                    80.12
512                    97.68
1024                  151.57
2048                  274.60
4096                  408.71
8192                  456.51
16384                 565.84
32768                 582.62
65536                 587.17
131072                630.64
262144                656.45
524288                682.37
1048576               712.19
2097152               714.55

Arm Forge

Arm Forge is the leading server and HPC development tool suite in research, industry, and academia for C, C++, Fortran, and Python high performance code on Linux.
Arm Forge includes Arm DDT, the best debugger for time-saving high performance application debugging, Arm MAP, the trusted performance profiler for invaluable optimization advice, and Arm Performance Reports to help you analyze your HPC application runs.

Environmental models for Arm Forge in ULHPC


module purge
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load tools/ArmForge/19.1
module load tools/ArmReports/19.1
Interactive Mode

To compile


$ icc -qopenmp example.c
For debugging, profiling and analysing

# for debugging
$ ddt ./a .out

# for profiling
$ map ./a .out

# for analysis
$ perf-report ./a .out
Batch Mode

Shared memory programming model (OpenMP)

Example for the batch script:


#!/bin/bash -l
#SBATCH -J ArmForge
#SBATCH -N 1
###SBATCH -A <project_name>
#SBATCH -c 16
#SBATCH --time=00:10:00
#SBATCH -p batch

module purge
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load tools/ArmForge/19.1
module load tools/ArmReports/19.1

export OMP_NUM_THREADS=${SLURM_CPUS_PER_TASK:-1}

# for debugging
$ ddt ./a .out

# for profiling
$ map ./a .out

# for analysis
$ perf-report ./a .out
Distributed memory programming model (MPI)

Example for the batch script:


#!/bin/bash -l
#SBATCH -J ArmForge
###SBATCH -A <project_name>
#SBATCH -N 2
#SBATCH --ntasks-per-node 28
#SBATCH --time=00:10:00
#SBATCH -p batch

module purge
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load tools/ArmForge/19.1
module load tools/ArmReports/19.1

# for debugging
$ ddt srun -n ${SLURM_NTASKS} ./a .out

# for profiling
$ map srun -n ${SLURM_NTASKS} ./a .out

# for analysis
$ perf-report srun -n ${SLURM_NTASKS} ./a .out
To see the result ArmForge report
Tip
If you find some issues with the instructions above, please report it to us using support ticket.

VTune

Use Intel VTune Profiler to profile serial and multithreaded applications that are executed on a variety of hardware platforms (CPU, GPU, FPGA). The tool is delivered as a Performance Profiler with Intel Performance Snapshots and supports local and remote target analysis on the Windows, Linux, and Android* platforms. Without the right data, you’re guessing about how to improve software performance and are unlikely to make the most effective improvements. Intel® VTune™ Profiler collects key profiling data and presents it with a powerful interface that simplifies its analysis and interpretation.

Environmental models for VTune on ULHPC:


module purge 
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load tools/VTune/2019_update4
module load vis/GTK+/3.24.8-GCCcore-8.2.0
Interactive Mode


# Compilation
$ icc -qopenmp example.c

# Code execution
$ export OMP_NUM_THREADS=16
$ amplxe-cl -collect hotspots -r my_result ./a.out
To see the result in GUI $ amplxe-gui my_result
VTune OpenMP result

$ amplxe-cl will list out the analysis types and $ amplxe-cl -hlep report will list out available reports in VTune.

Batch Mode

Shared Memory Programming Model (OpenMP)


#!/bin/bash -l
#SBATCH -J VTune
###SBATCH -A <project_name>
#SBATCH -N 1
#SBATCH -c 28
#SBATCH --time=00:10:00
#SBATCH -p batch

module purge 
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load tools/VTune/2019_update4
module load vis/GTK+/3.24.8-GCCcore-8.2.0

export OMP_NUM_THREADS=16
amplxe-cl -collect hotspots-r my_result ./a.out
Distributed Memory Programming Model

To compile just MPI application run $ mpiicc example.c and for MPI+OpenMP run $ mpiicc -qopenmp example.c


#!/bin/bash -l
#SBATCH -J VTune
###SBATCH -A <project_name>
#SBATCH -N 2
#SBATCH --ntasks-per-node=28
#SBATCH --time=00:10:00
#SBATCH -p batch

module purge 
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load tools/VTune/2019_update4
module load vis/GTK+/3.24.8-GCCcore-8.2.0

srun -n ${SLURM_NTASKS} amplxe-cl -collect uarch-exploration -r vtune_mpi -- ./a.out

# Report collection
$ amplxe-cl -report uarch-exploration -report-output output -r vtune_mpi

# Result visualization 
$ amplxe-gui vtune_mpi
The below figure shows the hybrid(MPI+OpenMP) programming analysis results:
VTune MPI result

Tip
If you find some issues with the instructions above, please report it to us using support ticket.

Intel Advisor

Intel Advisor provides two workflows to help ensure that Fortran, C, and C++ applications can make the most of modern Intel processors. Advisor contains three key capabilities:

Vectorization Advisor identifies loops that will benefit most from vectorization, specifies what is blocking effective vectorization, finds the benefit of alternative data reorganizations, and increases the confidence that vectorization is safe.
Threading Advisor is used for threading design and prototyping and to analyze, design, tune, and check threading design options without disrupting normal code development.
Advisor Roofline enables visualization of actual performance against hardware-imposed performance ceilings (rooflines) such as memory bandwidth and compute capacity - which provide an ideal roadmap of potential optimization steps.
The links to each capability above provide detailed information regarding how to use each feature in Advisor. For more information on Intel Advisor, visit this page.

Environmental models for Advisor on UL-HPC¶


module purge 
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load perf/Advisor/2019_update4
module load vis/GTK+/3.24.8-GCCcore-8.2.0
Interactive mode


# Compilation
$ icc -qopenmp example.c

# Code execution
$ export OMP_NUM_THREADS=16
$ advixe-cl -collect survey -project-dir my_result -- ./a.out

# Report collection
$ advixe-cl -report survey -project-dir my_result

# To see the result in GUI
$ advixe-gui my_result
VTune OpenMP result
$ advixe-cl will list out the analysis types and $ advixe-cl -hlep report will list out available reports in Advisor.

Batch mode

Shared memory programming model (OpenMP)

Example for the batch script:


#!/bin/bash -l
#SBATCH -J Advisor
#SBATCH -N 1
###SBATCH -A <project_name>
#SBATCH -c 28
#SBATCH --time=00:10:00
#SBATCH -p batch

module purge 
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load perf/Advisor/2019_update4
module load vis/GTK+/3.24.8-GCCcore-8.2.0

export OMP_NUM_THREADS=16
advixe-cl -collect survey -project-dir my_result -- ./a.out
Distributed memory programming model (MPI)

To compile just MPI application run $ mpiicc example.c and for MPI+OpenMP run $ mpiicc -qopenmp example.c

Example for the batch script:


#!/bin/bash -l
#SBATCH -J Advisor
#SBATCH -N 2
###SBATCH -A <project_name>
#SBATCH --ntasks-per-node=28
#SBATCH --time=00:10:00
#SBATCH -p batch

module purge 
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load perf/Advisor/2019_update4
module load vis/GTK+/3.24.8-GCCcore-8.2.0

srun -n ${SLURM_NTASKS} advixe-cl --collect survey --project-dir result -- ./a.out
To collect the result and see the result in GUI use the below commands

# Report collection
$ advixe-cl --report survey --project-dir result

# Result visualization 
$ advixe-gui result
The below figure shows the hybrid(MPI+OpenMP) programming analysis results:
VTune MPI result

Tip
If you find some issues with the instructions above, please report it to us using support ticket.

Intel Inspector

Intel Inspector is a memory and threading error checking tool for users developing serial and multithreaded applications on Windows and Linux operating systems. The essential features of Intel Inspector for Linux are:

Standalone GUI and command-line environments
Preset analysis configurations (with some configurable settings) and the ability to create custom analysis configurations to help the user control analysis scope and cost
Interactive debugging capability so one can investigate problems more deeply during the analysis
A large number of reported memory errors, including on-demand memory leak detection
Memory growth measurement to help ensure that the application uses no more memory than expected
Data race, deadlock, lock hierarchy violation, and cross-thread stack access error detection
Options for the Collect Action

Option	Description
mi1	Detect memory leaks
mi2	Detect memory problems
mi3	Locate memory problems
ti1	Detect deadlocks
ti2	Detect deadlocks and data races
ti3	Locate deadlocks and data races
Options for the Report Action

Option	Description
summary	A brief statement of the total number of new problems found grouped by problem type
problems	A detailed report of detected problem sets in the result, along with their location in the source code
observations	A detailed report of all code locations used to form new problem sets
status	A brief statement of the total number of detected problems and the number that are not investigated, grouped by category
For more information on Intel Inspector, please visit https://software.intel.com/en-us/intel-inspector-xe.

Environmental models for Inspector on UL-HPC


module purge 
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load tools/Inspector/2019_update4
module load vis/GTK+/3.24.8-GCCcore-8.2.0
Interactive Mode

To launch Inspector on Iris, we recommend that you use the command line tool inspxe-cl to collect data via batch jobs and then display results using the GUI, inspxe-gui, on a login node.


# Compilation
$ icc -qopenmp example.cc

# Result collection
$ inspxe-cl -collect mi1 -result-dir mi1 -- ./a.out

# Result view
$ cat inspxe-cl.txt
=== Start: [2020/04/08 02:11:50] ===
2 new problem(s) found
1 Memory leak problem(s) detected
1 Memory not deallocated problem(s) detected
=== End: [2020/04/08 02:11:55] ===
Batch Mode

Shared memory programming model (OpenMP)

Example for the batch script:


#!/bin/bash -l
#SBATCH -J Inspector
#SBATCH -N 1
###SBATCH -A <project_name>
#SBATCH -c 28
#SBATCH --time=00:10:00
#SBATCH -p batch

module purge 
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load tools/Inspector/2019_update4
module load vis/GTK+/3.24.8-GCCcore-8.2.0

inspxe-cl -collect mi1 -result-dir mi1 -- ./a.out`
To see the result:

# Result view
$ cat inspxe-cl.txt
=== Start: [2020/04/08 02:11:50] ===
2 new problem(s) found
1 Memory leak problem(s) detected
1 Memory not deallocated problem(s) detected
=== End: [2020/04/08 02:11:55] ===
Distributed memory programming model (MPI)

To compile:


# Compilation
$ mpiicc -qopenmp example.cc
Example for batch script:

#!/bin/bash -l
#SBATCH -J Inspector
#SBATCH -N 2
###SBATCH -A <project_name>
#SBATCH --ntasks-per-node 28
#SBATCH --time=00:10:00
#SBATCH -p batch

module purge 
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load tools/Inspector/2019_update4
module load vis/GTK+/3.24.8-GCCcore-8.2.0

srun -n {SLURM_NTASKS} inspxe-cl -collect=ti2 -r result ./a.out
To see result output:


$ cat inspxe-cl.txt
0 new problem(s) found
=== End: [2020/04/08 16:41:56] ===
=== End: [2020/04/08 16:41:56] ===
0 new problem(s) found
=== End: [2020/04/08 16:41:56] ===
Tip
If you find some issues with the instructions above, please report it to us using support ticket.

Intel Trace Analyzer and Collector

Intel Trace Analyzer and Collector (ITAC) are two tools used for analyzing MPI behavior in parallel applications. ITAC identifies MPI load imbalance and communication hotspots in order to help developers optimize MPI parallelization and minimize communication and synchronization in their applications. Using Trace Collector on Cori must be done with a command line interface, while Trace Analyzer supports both a command line and graphical user interface which analyzes the data from Trace Collector.

Environmental models for ITAC in ULHPC


module load purge
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load tools/itac/2019.4.036
module load vis/GTK+/3.24.8-GCCcore-8.2.0
Interactive mode


# Compilation
$ icc -qopenmp -trance example.c

# Code execution
$ export OMP_NUM_THREADS=16
$ -trace-collective ./a.out

# Report collection
$ export VT_STATISTICS=ON
$ stftool tracefile.stf --print-statistics
Batch mode

Shared memory programming model (OpenMP)

Example for the batch script:


#!/bin/bash -l
#SBATCH -J ITAC
###SBATCH -A <project_name>
#SBATCH -N 1
#SBATCH -c 16
#SBATCH --time=00:10:00
#SBATCH -p batch

module purge
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load tools/itac/2019.4.036
module load vis/GTK+/3.24.8-GCCcore-8.2.0

$ export OMP_NUM_THREADS=16
$ -trace-collective ./a.out
To see the result


$ export VT_STATISTICS=ON
$ stftool tracefile.stf --print-statistics
Distributed memory programming model (MPI)

To compile


$ mpiicc -trace example.c
Example for the batch script:

#!/bin/bash -l
#SBATCH -J ITAC
###SBATCH -A <project_name>
#SBATCH -N 2
#SBATCH --ntasks-per-node=28
#SBATCH --time=00:10:00
#SBATCH -p batch

module purge
module load swenv/default-env/v1.2-20191021-production
module load toolchain/intel/2019a
module load tools/itac/2019.4.036
module load vis/GTK+/3.24.8-GCCcore-8.2.0

srun -n ${SLURM_NTASKS} -trace-collective ./a.out
To collect the result and see the result in GUI use the below commands

$ export VT_STATISTICS=ON
$ stftool tracefile.stf --print-statistics
ITAC Summary

ITAC profile

ITAC event time

Tip
If you find some issues with the instructions above, please report it to us using support ticket.

Scalasca

Scalasca is a performance analysis tool that supports large-scale systems, including IBM Blue Gene and CrayXT and small systems. The Scalasca provides information about the communication and synchronization among the processors. This information will help to do the performance analysis, optimization, and tunning of scientificcodes. Scalasca supports OpenMP, MPI, and hybrid programming model, and a analysis can be done by using the GUI which can be seen in below figure.

Scalasca overview

Environmental models for Scalasca on ULHPC


module load purge
module load swenv/default-env/v1.1-20180716-production
module load toolchain/foss/2018a
module load perf/Scalasca/2.3.1-foss-2018a
module load perf/Score-P/3.1-foss-2018a
Interactive Mode

Work flow:


# instrument
$ scorep mpicxx example.cc

# analyze
scalasca -analyze mpirun -n 28 ./a.out

# examine
$ scalasca -examine -s scorep_a_28_sum
INFO: Post-processing runtime summarization report...
INFO: Score report written to ./scorep_a_28_sum/scorep.score

# graphical visualization
$ scalasca -examine result_folder
Batch mode

Shared memory programming (OpenMP)


#!/bin/bash -l
#SBATCH -J Scalasca
###SBATCH -A <project_name>
#SBATCH -N 1
#SBATCH -c 16
#SBATCH --time=00:10:00
#SBATCH -p batch

module load purge
module load swenv/default-env/v1.1-20180716-production
module load toolchain/foss/2018a
module load perf/Scalasca/2.3.1-foss-2018a
module load perf/Score-P/3.1-foss-2018a

export OMP_NUM_THREADS=16

# analyze
scalasca -analyze ./a.out
Report collection and visualization

# examine
$ scalasca -examine -s scorep_a_28_sum
INFO: Post-processing runtime summarization report...
INFO: Score report written to ./scorep_a_28_sum/scorep.score

# graphical visualization
$ scalasca -examine result_folder
Distributed memory programming (MPI)


#!/bin/bash -l
#SBATCH -J Scalasca
###SBATCH -A <project_name>
#SBATCH -N 2
#SBATCH --ntasks-per-node=28
#SBATCH --time=00:10:00
#SBATCH -p batch

module load purge
module load swenv/default-env/v1.1-20180716-production
module load toolchain/foss/2018a
module load perf/Scalasca/2.3.1-foss-2018a
module load perf/Score-P/3.1-foss-2018a

scalasca -analyze srun -n ${SLURM_NTASKS} ./a.out
Tip
If you find some issues with the instructions above, please report it to us using support ticket.

Valgrind

The Valgrind tool suite provides a number of debugging and profiling tools that help you make your programs faster and more correct. The most popular of these tools is called Memcheck which can detect many memory-related errors and memory leaks.

Prepare Your Program

Compile your program with -g to include debugging information so that Memcheck's error messages include exact line numbers. Using -O0 is also a good idea, if you can tolerate the slowdown. With -O1 line numbers in error messages can be inaccurate, although generally speaking running Memcheck on code compiled at -O1 works fairly well, and the speed improvement compared to running -O0 is quite significant. Use of -O2 and above is not recommended as Memcheck occasionally reports uninitialised-value errors which don't really exist.

Environmental models for Valgrind in ULHPC


$ module purge
$ module load debugger/Valgrind/3.15.0-intel-2019a
Interactive mode

Example code:


#include <iostream>                                                                                           
using namespace std;                                                                                          
int main()                                                                                                    
{                                                                                                             
  const int SIZE = 1000;                                                                                      
  int *array = new int(SIZE);                                                                                 

  for(int i=0; i<SIZE; i++)                                                                                   
    array[i] = i+1;                                                                                           

  // delete[] array                                                                                           

  return 0;                                                                                                   
}

# Compilation
$ icc -g example.cc

# Code execution
$ valgrind --leak-check=full --show-leak-kinds=all ./a.out
Result output (with leak)
If we do not delete delete[] array the memory, then there will be a memory leak.


==26756== Memcheck, a memory error detector
==26756== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==26756== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==26756== Command: ./a.out
==26756== 
==26756== Invalid write of size 4
==26756==    at 0x401275: main (mem-leak.cc:10)
==26756==  Address 0x5309c84 is 0 bytes after a block of size 4 alloc'd
==26756==    at 0x402DBE9: operator new(unsigned long) (vg_replace_malloc.c:344)
==26756==    by 0x401265: main (mem-leak.cc:8)
==26756== 
==26756== 
==26756== HEAP SUMMARY:
==26756==     in use at exit: 4 bytes in 1 blocks
==26756==   total heap usage: 2 allocs, 1 frees, 72,708 bytes allocated
==26756== 
==26756== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==26756==    at 0x402DBE9: operator new(unsigned long) (vg_replace_malloc.c:344)
==26756==    by 0x401265: main (mem-leak.cc:8)
==26756== 
==26756== LEAK SUMMARY:
==26756==    definitely lost: 4 bytes in 1 blocks
==26756==    indirectly lost: 0 bytes in 0 blocks
==26756==      possibly lost: 0 bytes in 0 blocks
==26756==    still reachable: 0 bytes in 0 blocks
==26756==         suppressed: 0 bytes in 0 blocks
==26756== 
==26756== For lists of detected and suppressed errors, rerun with: -s
==26756== ERROR SUMMARY: 1000 errors from 2 contexts (suppressed: 0 from 0)
Result output (without leak)

When we delete delete[] array the allocated memory, there will not be leaked memory.


==26172== Memcheck, a memory error detector
==26172== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==26172== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==26172== Command: ./a.out
==26172== 
==26172== 
==26172== HEAP SUMMARY:
==26172==     in use at exit: 4 bytes in 1 blocks
==26172==   total heap usage: 2 allocs, 1 frees, 72,708 bytes allocated
==26172== 
==26172== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==26172==    at 0x402DBE9: operator new(unsigned long) (vg_replace_malloc.c:344)
==26172==    by 0x401283: main (in /mnt/irisgpfs/users/ekrishnasamy/BPG/Valgrind/a.out)
==26172== 
==26172== LEAK SUMMARY:
==26172==    definitely lost: 4 bytes in 1 blocks
==26172==    indirectly lost: 0 bytes in 0 blocks
==26172==      possibly lost: 0 bytes in 0 blocks
==26172==    still reachable: 0 bytes in 0 blocks
==26172==         suppressed: 0 bytes in 0 blocks
==26172== 
==26172== For lists of detected and suppressed errors, rerun with: -s
==26172== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
Additional information

This page is based on the "Valgrind Quick Start Page". For more information about valgrind, please refer to http://valgrind.org/.

Tip
If you find some issues with the instructions above, please report it to us using support ticket.

Application Performance Snapshot (APS)

Application Performance Snapshot (APS) is a lightweight open source profiling tool developed by the Intel VTune developers. Use Application Performance Snapshot for a quick view into a shared memory or MPI application's use of available hardware (CPU, FPU, and memory). Application Performance Snapshot analyzes your application's time spent in MPI, MPI and OpenMP imbalance, memory access efficiency, FPU usage, and I/O and memory footprint. After analysis, it displays basic performance enhancement opportunities for systems using Intel platforms. Use this tool as a first step in application performance analysis to get a simple snapshot of key optimization areas and learn about profiling tools that specialize in particular aspects of application performance.

Prerequisites

Optional Configuration
Before running the tool, set up your environment appropriately:


module purge
module load swenv/default-env/v1.2-20191021-production
module load tools/VTune/2019_update4
module load toolchain/intel/2019a
Analyzing Shared Memory Applications

Run the following commands (interactive mode):


# Compilation
$ icc -qopenmp example.c

# Code execution
aps --collection-mode=all -r report_output ./a.out
aps -help will list out --collection-mode=<mode> available in APS.


# To create a .html file
aps-report -g report_output

# To open an APS results in the browser
firefox report_output_<postfix>.html
The below figure shows the example of result can be seen in the browser:
APS OpenMP result


# To see the command line output
$ aps-report <result_dir>
Example for the batch script:


#!/bin/bash -l
#SBATCH -J APS
#SBATCH -N 1
###SBATCH -A <project_name>
#SBATCH -c 28
#SBATCH --time=00:10:00
#SBATCH -p batch
#SBATCH --nodelist=node0xx

module purge
module load swenv/default-env/v1.2-20191021-production
module load tools/VTune/2019_update4
module load toolchain/intel/2019a

export OMP_NUM_THREADS=16
aps --collection-mode=all -r report_output ./a.out
Analyzing MPI Applications

To compile just MPI application run $ mpiicc example.c and for MPI+OpenMP run $ mpiicc -qopenmp example.c

Example for the batch script:


#!/bin/bash -l
#SBATCH -J APS
#SBATCH -N 2
###SBATCH -A <project_name>
#SBATCH --ntasks-per-node=14
#SBATCH -c 2
#SBATCH --time=00:10:00
#SBATCH -p batch
#SBATCH --reservation=<name>

module purge
module load swenv/default-env/v1.2-20191021-production
module load tools/VTune/2019_update4
module load toolchain/intel/2019a

# To collect all the results
export MPS_STAT_LEVEL=${SLURM_CPUS_PER_TASK:-1}
# An option for the OpenMP+MPI application
export OMP_NUM_THREADS=${SLURM_CPUS_PER_TASK:-1}
srun -n ${SLURM_NTASKS} aps --collection-mode=mpi -r result_output ./a.out
The below figure shows the hybrid(MPI+OpenMP) programming analysis results:

APS MPI result

Next Steps

Intel Trace Analyzer and Collector is a graphical tool for understanding MPI application behavior, quickly identifying bottlenecks, improving correctness, and achieving high performance for parallel cluster applications running on Intel architecture. Improve weak and strong scaling for applications. Get started.
Intel VTune Amplifier provides a deep insight into node-level performance including algorithmic hotspot analysis, OpenMP threading, general exploration microarchitecture analysis, memory access efficiency, and more. It supports C/C++, Fortran, Java, Python, and profiling in containers. Get started.
Intel Advisor provides two tools to help ensure your Fortran, C, and C++ applications realize full performance potential on modern processors. Get started.
Vectorization Advisor is an optimization tool to identify loops that will benefit most from vectorization, analyze what is blocking effective vectorization, and forecast the benefit of alternative data reorganizations
Threading Advisor is a threading design and prototyping tool to analyze, design, tune, and check threading design options without disrupting a regular environment
Quick Metrics Reference
Documentation and Resources

Intel Performance Snapshot User Forum: User forum dedicated to all Intel Performance Snapshot tools, including Application Performance Snapshot
Application Performance Snapshot: Application Performance Snapshot product page, see this page for support and online documentation
Application Performance Snapshot User's Guide: Learn more about Application Performance Snapshot, including details on specific metrics and best practices for application optimization
Tip
If you find some issues with the instructions above, please report it to us using support ticket.

Containers

Many applications and libraries can also be used through container systems, with the updated Singularity tool providing many new features of which we can especially highlight support for Open Containers Initiative - OCI containers (including Docker OCI), and support for secure containers - building and running encrypted containers with RSA keys and passphrases.

Singularity


The ULHPC offers the possibilty to run Singularity containers. Singularity is an open source container platform designed to be simple, fast, and secure. Singularity is optimized for EPC and HPC workloads, allowing untrusted users to run untrusted containers in a trusted way.

Loading Singularity

To use Singularity, you need to load the corresponding Lmod module.


>$ module load tools/Singularity
Warning
Modules are not allowed on the access servers. To test interactively Singularity, rememerber to ask for an interactive job first.


salloc -p interactive --pty bash
Pulling container images

Like Docker, Singularity provide a way to pull images from a Hubs such as DockerHub and Singuarity Hub.


>$ singularity pull docker://ubuntu:latest
You should see the following output:
Output
INFO:    Converting OCI blobs to SIF format
INFO:    Starting build...
Getting image source signatures
Copying blob d72e567cc804 done
Copying blob 0f3630e5ff08 done
Copying blob b6a83d81d1f4 done
Copying config bbea2a0436 done
Writing manifest to image destination
Storing signatures
...
INFO:    Creating SIF file...
You may now test the container by executing some inner commands:


>$ singularity exec ubuntu_latest.sif cat /etc/os-release
Output
NAME="Ubuntu"
VERSION="20.04.1 LTS (Focal Fossa)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 20.04.1 LTS"
VERSION_ID="20.04"
HOME_URL="https://www.ubuntu.com/&quot;
SUPPORT_URL="https://help.ubuntu.com/&quot;
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/&quot;
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;
VERSION_CODENAME=focal
UBUNTU_CODENAME=focal
Building container images

Building container images requires to have root privileges. Therefore, users have to build images on their local machine before transfering them to the platform. Please refer to the Data transfer section for this purpose.

Note
Singularity 3 introduces the ability to build your containers in the cloud, so you can easily and securely create containers for your applications without speci al privileges or setup on your local system. The Remote Builder can securely build a container for you from a definition file entered here or via the Singularity CLI (see https://cloud.sylabs.io/builder for more details).

GPU-enabled Singularity containers

This section relies on the very excellent documentation from CSCS. In the following example, a container with CUDA features is build, transfered and tested on the ULHPC platform. This example will pull a CUDA container from DockrHub and setup CUDA examples. For this purpose, a singularity definition file, i.e., cuda_samples.def needs to be created with the following content:


Bootstrap: docker
From: nvidia/cuda:10.1-devel

%post
    apt-get update
    apt-get install -y git
    git clone https://github.com/NVIDIA/cuda-samples.git /usr/local/cuda_samples
    cd /usr/local/cuda_samples
    git fetch origin --tags
    git checkout 10.1.1
    make

%runscript
    /usr/local/cuda_samples/Samples/deviceQuery/deviceQuery
On a local machine having singularity installed, we can build the container image, i.e., cuda_samples.sif using the definition file using the follwing singularity command:


sudo singularity build cuda_samples.sif cuda_samples.def
Warning
You should have root privileges on this machine. Without this condition, you will not be able to built the definition file.

Once the container is built and transfered to your dedicated storage on the ULHPC plaform, the container can be executed with the following command:


# Inside an interactive job on a gpu-enabled node
singularity run --nv cuda_samples.sif
Warning
In order to run a CUDA-enabled container, the --nv option has to be passed to singularity run. According to this option, singularity is going to setup the container environment to use the NVIDIA GPU and the basic CUDA libraries.

Output
CUDA Device Query (Runtime API) version (CUDART static linking)

Detected 1 CUDA Capable device(s)


Device 0: "Tesla V100-SXM2-16GB"
  CUDA Driver Version / Runtime Version          10.2 / 10.1
  CUDA Capability Major/Minor version number:    7.0
  Total amount of global memory:                 16160 MBytes (16945512448 bytes)
  (80) Multiprocessors, ( 64) CUDA Cores/MP:     5120 CUDA Cores
  GPU Max Clock rate:                            1530 MHz (1.53 GHz)
  Memory Clock rate:                             877 Mhz
  Memory Bus Width:                              4096-bit
  L2 Cache Size:                                 6291456 bytes
  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)
  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers
  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers
  Total amount of constant memory:               65536 bytes
  Total amount of shared memory per block:       49152 bytes
  Total number of registers available per block: 65536
  Warp size:                                     32
  Maximum number of threads per multiprocessor:  2048
  Maximum number of threads per block:           1024
  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)
  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)
  Maximum memory pitch:                          2147483647 bytes
  Texture alignment:                             512 bytes
  Concurrent copy and kernel execution:          Yes with 5 copy engine(s)
  Run time limit on kernels:                     No
  Integrated GPU sharing Host Memory:            No
  Support host page-locked memory mapping:       Yes
  Alignment requirement for Surfaces:            Yes
  Device has ECC support:                        Enabled
  Device supports Unified Addressing (UVA):      Yes
  Device supports Compute Preemption:            Yes
  Supports Cooperative Kernel Launch:            Yes
  Supports MultiDevice Co-op Kernel Launch:      Yes
  Device PCI Domain ID / Bus ID / location ID:   0 / 30 / 0
  Compute Mode:
     < Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) >


deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 10.2, CUDA Runtime Version = 10.1, NumDevs = 1
Result = PASS

MPI and Singularity containers

This section relies on the very excellent documentation from CSCS. The following singularity definition file mpi_osu.def can be used to build a container with the osu benchmarks using mpi:


bootstrap: docker
from: debian:jessie

%post
    # Install software
    apt-get update
    apt-get install -y file g++ gcc gfortran make gdb strace realpath wget curl --no-install-recommends

    # Install mpich
    curl -kO https://www.mpich.org/static/downloads/3.1.4/mpich-3.1.4.tar.gz
    tar -zxvf mpich-3.1.4.tar.gz
    cd mpich-3.1.4
    ./configure --disable-fortran --enable-fast=all,O3 --prefix=/usr
    make -j$(nproc)
    make install
    ldconfig

    # Build osu benchmarks
    wget -q http://mvapich.cse.ohio-state.edu/download/mvapich/osu-micro-benchmarks-5.3.2.tar.gz
    tar xf osu-micro-benchmarks-5.3.2.tar.gz
    cd osu-micro-benchmarks-5.3.2
    ./configure --prefix=/usr/local CC=$(which mpicc) CFLAGS=-O3
    make
    make install
    cd ..
    rm -rf osu-micro-benchmarks-5.3.2
    rm osu-micro-benchmarks-5.3.2.tar.gz

%runscript
    /usr/local/libexec/osu-micro-benchmarks/mpi/pt2pt/osu_bw

sudo singularity build mpi_osu.sif mpi_osu.def
Once the container image is ready, you can use it for example inside the following slurm launcher to start a best-effort job:

#!/bin/bash -l
#SBATCH -J ParallelJob
#SBATCH -N 2
#SBATCH --ntasks-per-node=1
#SBATCH --time=05:00
#SBATCH -p batch
#SBATCH --qos=qos-besteffort

module load tools/Singularity
srun -n $SLURM_NTASKS singularity run mpi_osu.sif
The content of the output file:
Output
# OSU MPI Bandwidth Test v5.3.2
# Size      Bandwidth (MB/s)
1                       0.35
2                       0.78
4                       1.70
8                       3.66
16                      7.68
32                     16.38
64                     32.86
128                    66.61
256                    80.12
512                    97.68
1024                  151.57
2048                  274.60
4096                  408.71
8192                  456.51
16384                 565.84
32768                 582.62
65536                 587.17
131072                630.64
262144                656.45
524288                682.37
1048576               712.19
2097152               714.55

Services

The ULHPC Team is committed to excellence and support of the University research community through several side services:

ULHPC Gitlab, a comprehensive version control and collaboration (VC&C) solution to deliver better software faster.
Etherpad - a web-based collaborative real-time editor
Privatebin - secured textual data sharing
Gitlab @ Uni.lu (DEPRECATED)


Gitlab is an open source software to collaborate on code, very similar to Github. You can manage git repositories with fine grained access controls that keep your code secure and perform code reviews and enhance collaboration with merge requests. Each project can also have an issue tracker and a wiki.

The GitLab service is available for UL HPC platform users with their ULHPC account and to their external collaborators that have a GitHub account.

Decommissioning of Gitlab service
Situation: the Gitlab service has been in production since 2015 and kept up-to-date until now. Nevertheless, the ULHPC Gitlab service is now replaced by a new instance administrated by the SIU Service. For more information, search the Knowledge Base or open a ticket on ServiceNow.
[Github] External accounts access are BLOCKED by default
By default, external (github) accounts are denied and blocked on the Gitlab service.
Access can be granted on-demand after careful review of the ULHPC team and attached to the project indicated by the UL[HPC] PI in charge of the external.
Note: externals cannot create groups nor projects.
EtherPad


Etherpad is a web-based collaborative real-time editor, allowing authors to simultaneously edit a text document, and see all of the participants' edits in real-time, with the ability to display each author's text in their own color.

PrivateBin


PrivateBin is a minimalist, open source online pastebin where the server has zero knowledge of pasted data.
Data is encrypted and decrypted in the browser using 256bit AES in Galois Counter mode.



Support

ULHPC strives to support in a user friendly way your [super]computing needs. Note however that we are not here to make your PhD at your place ;)

 Service Now HPC Support Portal

FAQ/Troubleshooting

Password reset
Connection issues
File Permissions
Access rights to project directory
Quotas
Read the Friendly Manual

We have always maintained an extensive documentation and tutorials available online, which aims at being the most up-to-date and comprehensive.

So please, read the documentation first if you have a question of problem -- we probably provide detailed instructions here

Help Desk

The online help desk Service is the preferred method for contacting ULHPC.

Tips
Before reporting a problem or and issue, kindly remember that:

Your issue is probably documented here on the ULHPC Technical documentation
An event may be on-going:
Planned maintenance are announced at least 2 weeks in advance - -- see Maintenance and Downtime Policy
The proper SSH banner is displayed during planned downtime
check the state of your nodes and jobs
Joining/monitoring running jobs
Monitoring post-mortem Job status and efficiency
 Service Now HPC Support Portal

You can make code snippets, shell outputs, etc in your ticket much more readable by inserting a line with:


[code]<pre>
before the snippet, and another line with:

</pre>[/code]
after it. For a full list of formatting options, see this ServiceNow article.
Be as precise and complete as possible
ULHPC team handle thousands of support requests per year. In order to ensure efficient timely resolution of issues, ensure that:

you select the appropriate category (left menu)
you include as much of the following as possible when making a request:
Who? - Name and user id (login), eventually project name
When? - When did the problem occur?
Where? - Which cluster ? Which node ? Which job ?
Really include Job IDs
Location of relevant files
input/output, job launcher scripts, source code, executables etc.
What? - What happened? What exactly were you doing or trying to do ?
include Error messages - kindly report system or software messages literally and exactly.
output of module list
any steps you have tried
Steps to reproduce
Any part of this technical documentation you checked before opening the ticket
Access to the online help system requires logging in with your Uni.lu username, password, and eventually one-time password. If you are an existing user unable to log in, you can send us an email.

Availability and Response Time
HPC support is provided on a volunteer basis by UL HPC staff and associated UL experts working at normal business hours. We offer no guarantee on response time except with paid support contracts.

Email support

You can contact us by mail to the ULHPC Team Email (ONLY if you cannot login/access the HPC Support helpdesk portal : hpc-team@uni.lu

You may also ask the help of other ULHPC users using the HPC User community mailing list: (moderated): hpc-users@uni.lu

Overview

You are more than welcome to contribute to the development of this project. You are however expected to follow the model of Github Flow for your contributions.

What is a [good] Git Workflow?
A Git Workflow is a recipe or recommendation for how to use Git to accomplish work in a consistent and productive manner. Indeed, Git offers a lot of flexibility in how changes can be managed, yet there is no standardized process on how to interact with Git. The following questions are expected to be addressed by a successful workflow:

Q1: Does this workflow scale with team size?
Q2: Is it possible to prevent/limit mistakes and errors ?
Q3: Is it easy to undo mistakes and errors with this workflow?
Q4: Does this workflow permits to easily test new feature/functionnalities before production release ?
Q5: Does this workflow allow for Continuous Integration (even if not yet planned at the beginning)
Q6: Does this workflow permit to master the production release
Q7: Does this workflow impose any new unnecessary cognitive overhead to the team?
Q8: The workflow is easy to use/setup and maintain
In particular, the default "workflow" centralizedgitl (where everybody just commit to the single master branch), while being the only one satisfying Q7, proved to be easily error-prone and can break production system relying on the underlying repository. For this reason, other more or less complex workflows have emerged -- all feature-branch-based, that supports teams and projects where production deployments are made regularly:

Git-flow, the historical successful workflow featuring two main branches with an infinite lifetime (production and {master | devel})
all operations are facilitated by the git-flow CLI extension
maintaining both branches can be bothersome - make up
the only one permitting to really control production release
Github Flow, a lightweight version with a single branch (master)
pull-request based - requires interaction with Gitlab/Github web interface (git request-pull might help)
The ULHPC team enforces an hydrid workflow detailed below, HOWEVER you can safely contribute to this documentation by following the Github Flow explained now.

Default Git workflow for contributions

We expect contributors to follow the Github Flow concept.



This flow is ideal for organizations that need simplicity, and roll out frequently. If you are already using Git, you are probably using a version of the Github flow. Every unit of work, whether it be a bugfix or feature, is done through a branch that is created from master. After the work has been completed in the branch, it is reviewed and tested before being merged into master and pushed out to production.

In details:

As preliminaries (to be done only once), Fork the ULHPC/ulhpc-docs repository under <YOUR-USERNAME>/ulhpc-docs
A fork is a copy of a repository placed under your Github namespace. Forking a repository allows you to freely experiment with changes without affecting the original project.
In the top-right corner of the ULHPC/ulhpc-docs repository, click "Fork" button.
Under Settings, change the repository name from docs to ulhpc-docs
Once done, you can clone your copy (forked) repository: select the SSH url under the "Code" button:

# (Recommended) Place your repo in a clean (and self-explicit) directory layout
# /!\ ADAPT 'YOUR-USERNAME' with your Github username
$> mkdir -p ~/git/github.com/YOUR-USERNAME
$> cd ~/git/github.com/YOUR-USERNAME
# /!\ ADAPT 'YOUR-USERNAME' with your Github username
git clone git@github.com:YOUR-USERNAME/ulhpc-docs.git
$> cd ulhpc-docs
$> make setup
Configure your working forked copy to sync with the original ULHPC/ulhpc-docs repository through a dedicated upstream remote

# Check current remote: only 'origin' should be listed
$> git remote -v
origin  git@github.com:YOUR-USERNAME/ulhpc-docs.git (fetch)
origin  git@github.com:YOUR-USERNAME/ulhpc-docs.git (push)
# Add upstream
$> make setup-upstream
# OR, manually:
$> git remote add upstream https://github.com/ULHPC/ulhpc-docs.git
# Check the new remote
$> git remote -v
origin  git@github.com:YOUR-USERNAME/ulhpc-docs.git (fetch)
origin  git@github.com:YOUR-USERNAME/ulhpc-docs.git (push)
upstream https://github.com/ULHPC/ulhpc-docs.git (fetch)
upstream https://github.com/ULHPC/ulhpc-docs.git (push)
At this level, you probably want to follow the setup instructions to configure your ulhpc-docs python virtualenv and deploy locally the documentation with make doc
access the local documentation with your favorite browser by visiting the URL http://localhost:8000
Then, to bring your contributions:

Pull the latest changes from the upstream remote using:

make sync-upstream
Create your own feature branch with appropriate name <name>:

# IF you have installed git-flow: {brew | apt | yum |...} install gitflow git-flow
# /!\ ADAPT <name> with appropriate name: this will create and checkout to branch feature/<name>
git-flow feature start <name>
# OR
git checkout -b feature/<name>
Commit your changes once satisfied with them

git add [...]
git commit -s -m 'Added some feature'
Push to the feature branch and publish it

# IF you have installed git-flow
# /!\ ADAPT <name> accordingly
git-flow feature publish <name>
# OR
git push -u origin feature/<name>
Create a new Pull Request to submit your changes to the ULHPC team.
Commit first!

# check what would be put in the pull request
git request-pull master ./
# Open Pull Request from web interface
# Github: Open 'new pull request'
#      Base = feature/<name>,   compare = master
Pull request will be reviewed, eventually with comments/suggestion for modifications -- see official doc
you may need to apply new commits to resolve the comments -- remember to mention the pull request in the commit message with the prefix '[PR#<ID>]' (Ex: [PR#5]) in your commit message

cd /path/to/ulhpc-docs
git checkout feature/<name>
git pull
# [...]
git add [...]
# /!\ ADAPT Pull Request ID accordingly
git commit -s -m '[PR#<ID>] ...'
After your pull request has been reviewed and merged, you can safely delete the feature branch.


# Adapt <name> accordingly
git checkout feature/<name> # Eventually, if needed
make sync-upstream
git-flow feature finish <name> # feature branch 'feature/<name>' will be merged into 'devel'
#                              # feature branch 'feature/<name>' will be locally deleted
#                              # you will checkout back to the 'master' branch
git push origin --delete feature/<name>   # /!\ WARNING: Ensure you delete the CORRECT remote branch
git push  # sync master branch
ULHPC Git Workflow

Throughout all its projects, the ULHPC team has enforced a stricter workflow for Git repository summarized in the below figure:



The main concepts inherited from both advanced workflows (Git-flow and Github Flow) are listed below:

The central repository holds two main branches with an infinite lifetime:
production: the production-ready branch, used for the deployed version of the documentation.
devel | master | main (master in this case): the main (master) branch where the latest developments intervene (name depends on repository purpose). This is the default branch you get when you clone the repository.
You should always setup your local copy of the repository with make setup
ensure also you have installed the gitflow extension
ensure you are properly made the initial configuration of git -- see also sample .gitconfig
In compliment to the Github Flow described above, several additional operations are facilitated by the root Makefile:

Initial setup of the repository with make setup
Release of a new version of this repository with make start_bump_{patch,minor,major} and make release
this action is managed by the ULHPC team according to the semantic versioning scheme implemented within this this project.

Semantic Versioning

The operation consisting of releasing a new version of this repository is automated by a set of tasks within the root Makefile. In this context, a version number have the following format:


  <major>.<minor>.<patch>[-b<build>]
where:

< major > corresponds to the major version number
< minor > corresponds to the minor version number
< patch > corresponds to the patching version number
(eventually) < build > states the build number i.e. the total number of commits within the devel branch.
Example: `1.0.0-b28`.

VERSION file
The current version number is stored in the root file VERSION. /!\ IMPORTANT: NEVER MAKE ANY MANUAL CHANGES TO THIS FILE

ULHPC/docs repository release
Only the ULHPC team is allowed to perform the releasing operations (and push to the production branch). By default, the main documentation website is built against the production branch.

For more information on the version, run:


 $> make versioninfo
ULHPC Team procedure for repository release







